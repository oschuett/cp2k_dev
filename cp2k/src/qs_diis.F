!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 1999  MPI fuer Festkoerperforschung, Stuttgart              !
!-----------------------------------------------------------------------------!

#include "cp_prep_globals.h"

!!****** cp2k/qs_diis [1.0] *
!!
!!   NAME
!!     qs_diis
!!
!!   FUNCTION
!!     Perform a direct inversion in the iterative subspace (DIIS).
!!
!!   AUTHOR
!!     Matthias Krack (28.06.2000)
!!
!!   MODIFICATION HISTORY
!!     - Changed to BLACS matrix usage (08.06.2001,MK)
!!     - rewritten to include LSD (1st attempt) (01.2003, Joost VandeVondele)
!!
!!   SOURCE
!******************************************************************************

MODULE qs_diis
  USE cp_error_handling,               ONLY: cp_a_l,&
                                             cp_assert,&
                                             cp_assertion_failed,&
                                             cp_debug,&
                                             cp_error_check,&
                                             cp_error_dealloc_ref,&
                                             cp_error_get_logger,&
                                             cp_error_init,&
                                             cp_error_message,&
                                             cp_error_type,&
                                             cp_internal_error,&
                                             cp_unimplemented_error
  USE cp_fm_struct,                    ONLY: cp_fm_struct_type
  USE cp_fm_types,                     ONLY: cp_fm_create,&
                                             cp_fm_get_info,&
                                             cp_fm_maxval,&
                                             cp_fm_set_all,&
                                             cp_fm_p_type,&
                                             cp_fm_type
  USE cp_fm_basic_linalg,              ONLY: cp_fm_scale_and_add,&
                                             cp_fm_gemm,&
                                             cp_fm_symm,&
                                             cp_fm_trace
  USE cp_sm_fm_interactions,           ONLY: copy_fm_to_sm, &
                                             copy_sm_to_fm
  USE cp_log_handling,                 ONLY: cp_failure_level,&
                                             cp_fatal_level,&
                                             cp_log,&
                                             cp_logger_get_default_unit_nr,&
                                             cp_logger_type,&
                                             cp_note_level,&
                                             cp_to_string,&
                                             cp_warning_level
  USE kinds,                           ONLY: wp => dp,&
                                             wp_size => dp_size
  USE mathlib,                         ONLY: diagonalize_matrix,&
                                             symmetrize_matrix
  USE qs_blacs,                        ONLY: copy_blacs_to_blacs_matrix,&
                                             replicate_blacs_matrix
  USE qs_diis_types,                   ONLY: qs_diis_b_release,&
                                             qs_diis_b_retain,&
                                             qs_diis_buffer_type
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_environment_type
  USE qs_mo_types,                     ONLY: get_mo_set,&
                                             mo_set_p_type,&
                                             mo_set_type
  USE scf_control_types,               ONLY: scf_control_type
  USE sparse_matrix_types,             ONLY: real_matrix_p_type
  USE termination,                     ONLY: stop_memory
  USE timings,                         ONLY: timeset,&
                                             timestop
  IMPLICIT NONE

  PRIVATE

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN="qs_diis"
  INTEGER, SAVE, PRIVATE :: last_diis_b_id=0

  ! *** Public subroutines ***

  PUBLIC :: qs_diis_b_step, qs_diis_b_create, qs_diis_b_clear
!!***
  ! *****************************************************************************

CONTAINS

!!****f* qs_diis/qs_diis_b_create [1.0] *
!!
!!   NAME
!!     qs_diis_b_create
!!
!!   SYNOPSIS
!!     Subroutine qs_diis_b_create(diis_buffer, nbuffer, error)
!!       Type(qs_diis_buffer_type), Pointer:: diis_buffer
!!       Integer, Intent (IN):: nbuffer
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine qs_diis_b_create
!!
!!   FUNCTION
!!     allocates an scf buffer
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - diis_buffer: the buffer to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     fawzi
!!
!!   MODIFICATION HISTORY
!!     02.2003 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE qs_diis_b_create(diis_buffer,nbuffer,error)
    TYPE(qs_diis_buffer_type), POINTER :: diis_buffer
    INTEGER, INTENT(in) :: nbuffer
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='qs_diis_b_create',&
         routineP=moduleN//':'//routineN
    INTEGER :: stat

    failure=.FALSE.

    ALLOCATE(diis_buffer,stat=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       diis_buffer%nbuffer=nbuffer
       diis_buffer%ncall=0
       last_diis_b_id=last_diis_b_id+1
       diis_buffer%id_nr=last_diis_b_id
       diis_buffer%ref_count=1
       NULLIFY(diis_buffer%error,diis_buffer%parameter, diis_buffer%b_matrix)
    END IF
  END SUBROUTINE qs_diis_b_create
  !***************************************************************************

!!****f* qs_diis/qs_diis_b_check_i_alloc [1.0] *
!!
!!   NAME
!!     qs_diis_b_check_i_alloc
!!
!!   FUNCTION
!!     Allocate and initialize a DIIS buffer for "nao*nao" parameter
!!     variables and with a buffer size of "nbuffer".
!!
!!   NOTES
!!     check to allocate matrixes only when needed, using a linked list?
!!
!!   ARGUMENTS
!!     - diis_buffer: the buffer to initialize
!!     - matrix_struct: the structure for the matrix of the buffer
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Matthias Krack
!!
!!   MODIFICATION HISTORY
!!     - Creation (07.05.2001, Matthias Krack)
!!     - Changed to BLACS matrix usage (08.06.2001, MK)
!!
!!*** *********************************************************************
  SUBROUTINE qs_diis_b_check_i_alloc(diis_buffer,&
       matrix_struct,nspin,error)

    TYPE(qs_diis_buffer_type), POINTER :: diis_buffer
    TYPE(cp_fm_struct_type), POINTER :: matrix_struct
    INTEGER, INTENT(IN)                :: nspin
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    !   *** Local parameters ***

    CHARACTER(LEN=*), PARAMETER :: routineN='qs_diis_b_check_i_alloc',&
         routineP=moduleN//':'//routineN

    !   *** Local variables ***

    TYPE(cp_logger_type), POINTER :: logger
    INTEGER :: ibuffer,istat,ispin,nbuffer
    LOGICAL :: failure

    !   ---------------------------------------------------------------------------

    failure=.FALSE.
    logger => cp_error_get_logger(error)
    CPPrecondition(ASSOCIATED(diis_buffer),cp_failure_level,routineP,error,failure)
    CPPrecondition(diis_buffer%ref_count>0,cp_failure_level,routineP,error,failure)

    nbuffer=diis_buffer%nbuffer

    IF (.NOT.ASSOCIATED(diis_buffer%error)) THEN
       ALLOCATE (diis_buffer%error(nbuffer,nspin),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"diis_buffer%error",0)

       DO ispin=1,nspin
          DO ibuffer=1,nbuffer
             NULLIFY (diis_buffer%error(ibuffer,ispin)%matrix)
             CALL cp_fm_create(&
                  diis_buffer%error(ibuffer,ispin)%matrix,&
                  name="qs_diis_b"//&
                  TRIM(ADJUSTL(cp_to_string(diis_buffer%id_nr)))//&
                  "%error("//&
                  TRIM(ADJUSTL(cp_to_string(ibuffer)))//","//&
                  TRIM(ADJUSTL(cp_to_string(ibuffer)))//")",&
                  matrix_struct=matrix_struct)
          END DO
       END DO
    END IF

    IF (.NOT.ASSOCIATED(diis_buffer%parameter)) THEN
       ALLOCATE (diis_buffer%parameter(nbuffer,nspin),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"diis_buffer%parameter",0)

       DO ispin=1,nspin
          DO ibuffer=1,nbuffer
             NULLIFY (diis_buffer%parameter(ibuffer,ispin)%matrix)
             CALL cp_fm_create(&
                  diis_buffer%parameter(ibuffer,ispin)%matrix,&
                  name="qs_diis_b"//&
                  TRIM(ADJUSTL(cp_to_string(diis_buffer%id_nr)))//&
                  "%parameter("//&
                  TRIM(ADJUSTL(cp_to_string(ibuffer)))//","//&
                  TRIM(ADJUSTL(cp_to_string(ibuffer)))//")",&
                  matrix_struct=matrix_struct)
          END DO
       END DO
    END IF

    IF (.NOT.ASSOCIATED(diis_buffer%b_matrix)) THEN
       ALLOCATE (diis_buffer%b_matrix(nbuffer+1,nbuffer+1),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"diis_buffer%b_matrix",&
            (nbuffer + 1)**2*wp_size)
       IF (logger%para_env%source==logger%para_env%mepos.AND.&
            logger%print_keys%diis_information) THEN
          WRITE (UNIT=cp_logger_get_default_unit_nr(logger),FMT="(/,T2,A)")&
               "The SCF DIIS buffer was allocated and initialised"
       END IF
    END IF

  END SUBROUTINE qs_diis_b_check_i_alloc
  ! *****************************************************************************

!!****f* qs_diis/qs_diis_b_step [1.0] *
!!
!!   NAME
!!     qs_diis_b_step
!!
!!   SYNOPSIS
!!     Subroutine qs_diis_b_step(diis_buffer, mo_array, kc, sc, delta,&
!!         error_max, diis_step, qs_env, error)
!!       Type(qs_diis_buffer_type), Pointer:: diis_buffer
!!       Type(cp_fm_type), Pointer:: sc
!!       Type(cp_fm_p_type), Dimension(:), Pointer:: kc
!!       Type(cp_error_type), Intent (INOUT), Optional:: error
!!       Type(mo_set_p_type), Dimension(:), Pointer:: mo_array
!!       Type(qs_environment_type), Intent (IN):: qs_env
!!       Real(Kind=wp), Intent (IN):: delta
!!       Real(Kind=wp), Intent (OUT):: error_max
!!       Logical, Intent (OUT):: diis_step
!!     End Subroutine qs_diis_b_step
!!
!!   FUNCTION
!!     Update the SCF DIIS buffer, and if appropriate does a diis step.
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     to do
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Matthias Krack
!!
!!   MODIFICATION HISTORY
!!     - Creation (07.05.2001, Matthias Krack)
!!     - Changed to BLACS matrix usage (08.06.2001, MK)
!!     - 03.2003 rewamped [fawzi]
!!
!!*** *********************************************************************
  SUBROUTINE qs_diis_b_step(diis_buffer,mo_array,kc,sc,delta,error_max,&
       diis_step,qs_env,error)

    TYPE(qs_diis_buffer_type), POINTER                 :: diis_buffer
    TYPE(cp_fm_type), POINTER                 :: sc
    TYPE(cp_fm_p_type),DIMENSION(:), POINTER  :: kc
    TYPE(cp_error_type), INTENT(inout), OPTIONAL       :: error
    TYPE(mo_set_type), POINTER                         :: mo_set
    TYPE(mo_set_p_type), DIMENSION(:), POINTER         :: mo_array
    TYPE(qs_environment_type), INTENT(IN)              :: qs_env
    REAL(wp), INTENT(IN)                               :: delta
    REAL(wp), INTENT(OUT)                              :: error_max
    LOGICAL, INTENT(OUT)                               :: diis_step

    !   *** Local parameters ***

    CHARACTER(LEN=*), PARAMETER :: routineN='qs_diis_b_step',&
         routineP=moduleN//':'//routineN

    !   *** Local variables ***

    TYPE(cp_fm_type), POINTER  :: c
    TYPE(scf_control_type), POINTER     :: scf_control

    INTEGER :: handle,ib,istat,jb,nao,nb,nb1,nmo,output_unit,&
         nspin,ispin
    LOGICAL :: ionode, failure
    REAL(wp) :: eps_diis,tmp

    TYPE(real_matrix_p_type), DIMENSION(:), POINTER :: s
    TYPE(cp_fm_type), POINTER :: new_errors,old_errors,parameters
    TYPE(cp_fm_struct_type), POINTER :: matrix_struct
    TYPE(cp_logger_type), POINTER :: logger

    REAL(wp), DIMENSION(:), ALLOCATABLE :: ev
    REAL(wp), DIMENSION(:,:), POINTER   :: a,b

    !   ---------------------------------------------------------------------------

    CALL timeset("scf_diis","I","",handle)

    nspin=SIZE(mo_array)
    failure=.FALSE.
    NULLIFY(c,scf_control,s,new_errors,old_errors,parameters,matrix_struct,a,b)
    logger => cp_error_get_logger(error)

    diis_step = .FALSE.

    ionode = logger%para_env%source==logger%para_env%mepos
    output_unit= cp_logger_get_default_unit_nr(logger,local=.FALSE.)

    CALL get_qs_env(qs_env=qs_env,s=s,scf_control=scf_control)

    eps_diis=scf_control%eps_diis

    !   *** Quick return, if no DIIS is requested ***
    IF ( diis_buffer%nbuffer < 1) THEN
       CALL timestop(0.0_wp,handle)
       RETURN
    END IF

    CALL cp_fm_get_info(kc(1)%matrix,matrix_struct=matrix_struct,error=error)
    CALL qs_diis_b_check_i_alloc(diis_buffer,matrix_struct=matrix_struct,&
         nspin=nspin)

    error_max=0.0_wp

    ib = MODULO(diis_buffer%ncall,diis_buffer%nbuffer) + 1
    diis_buffer%ncall = diis_buffer%ncall + 1
    nb = MIN(diis_buffer%ncall,diis_buffer%nbuffer)

    DO ispin=1,nspin

       CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
            nao=nao,&
            homo=nmo,&
            eigenvectors=c)


       parameters => diis_buffer%parameter(ib,ispin)%matrix
       CALL copy_blacs_to_blacs_matrix(kc(ispin)%matrix,parameters)
       CALL cp_fm_symm("L","U",nao,nmo,2.0_wp,parameters,c,0.0_wp,kc(ispin)%matrix)

       new_errors => diis_buffer%error(ib,ispin)%matrix
       ! I guess that this copy can be avoided for LSD
       CALL copy_sm_to_fm(s(1)%matrix,new_errors)
       CALL cp_fm_symm("L","U",nao,nmo,2.0_wp,new_errors,c,0.0_wp,sc)

       CALL cp_fm_gemm("N","T",nao,nao,nmo,1.0_wp,sc,kc(ispin)%matrix, 0.0_wp,new_errors)
       CALL cp_fm_gemm("N","T",nao,nao,nmo,1.0_wp,kc(ispin)%matrix,sc,-1.0_wp,new_errors)

       CALL cp_fm_maxval(new_errors,tmp)
       error_max=MAX(error_max,tmp)

    ENDDO

    IF (ionode.AND.logger%print_keys%diis_information) THEN
       WRITE (UNIT=output_unit,FMT="(/,T2,A,E12.3)")&
            "Maximum SCF DIIS error vector element:",error_max
    END IF

    !   *** Check, if a DIIS step is appropiate ***

    diis_step = ((diis_buffer%ncall > 1).AND.(delta < eps_diis))

    !   *** Update the SCF DIIS buffer ***

    IF (error_max < eps_diis) THEN

       b => diis_buffer%b_matrix

       DO jb=1,nb
          b(jb,ib)=0.0_wp
          DO ispin=1,nspin
             old_errors => diis_buffer%error(jb,ispin)%matrix
             new_errors => diis_buffer%error(ib,ispin)%matrix
             CALL cp_fm_trace(old_errors,new_errors,tmp)
             b(jb,ib)=b(jb,ib)+tmp
          ENDDO
          b(ib,jb) = b(jb,ib)
       END DO

       IF (ionode.AND.logger%print_keys%diis_information) THEN
          WRITE (UNIT=output_unit,FMT="(/,T2,A)")&
               "The SCF DIIS buffer was updated"
       END IF

    ELSE

       diis_step = .FALSE.

    END IF

    !   *** Perform DIIS update ***

    IF (diis_step) THEN

       nb1 = nb + 1

       ALLOCATE (a(nb1,nb1),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"a",nb1*nb1*wp_size)
       ALLOCATE (b(nb1,nb1),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"b",nb1*nb1*wp_size)
       ALLOCATE (ev(nb1),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"ev",nb1*wp_size)

       !     *** Set up the linear DIIS equation system ***

       b(1:nb,1:nb) = diis_buffer%b_matrix(1:nb,1:nb)

       b(1:nb,nb1) = -1.0_wp
       b(nb1,1:nb) = -1.0_wp
       b(nb1,nb1) = 0.0_wp

       !     *** Solve the linear DIIS equation system ***

       CALL diagonalize_matrix(b(1:nb1,1:nb1),ev(1:nb1))

       a(1:nb1,1:nb1) = b(1:nb1,1:nb1)

       DO jb=1,nb1
          IF (ABS(ev(jb)) < 1.0E-12_wp) THEN
             a(1:nb1,jb) = 0.0_wp
          ELSE
             a(1:nb1,jb) = a(1:nb1,jb)/ev(jb)
          END IF
       END DO

       ev(1:nb) = MATMUL(a(1:nb,1:nb1),b(nb1,1:nb1))

       !     *** Update Kohn-Sham matrix ***

       DO ispin=1,nspin
          CALL cp_fm_set_all(kc(ispin)%matrix,0.0_wp)
          DO jb=1,nb
             parameters => diis_buffer%parameter(jb,ispin)%matrix
             CALL cp_fm_scale_and_add(1.0_wp,kc(ispin)%matrix,-ev(jb),parameters)
          END DO
       ENDDO

       DEALLOCATE (a,STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"a")
       DEALLOCATE (b,STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"b")
       DEALLOCATE (ev,STAT=istat)
       IF (istat /= 0) CALL stop_memory(routineP,"ev")

    ELSE

       DO ispin=1,nspin
          parameters => diis_buffer%parameter(ib,ispin)%matrix
          CALL copy_blacs_to_blacs_matrix(parameters,kc(ispin)%matrix)
       ENDDO

    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE qs_diis_b_step
  ! *****************************************************************************

!!****f* qs_diis/qs_diis_b_clear [1.0] *
!!
!!   NAME
!!     qs_diis_b_clear
!!
!!   SYNOPSIS
!!     Subroutine qs_diis_b_clear(diis_buffer, error)
!!       Type(qs_diis_buffer_type), Pointer:: diis_buffer
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine qs_diis_b_clear
!!
!!   FUNCTION
!!     clears the buffer
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - diis_buffer: the buffer to clear
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     fawzi
!!
!!   MODIFICATION HISTORY
!!     02.2003 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE qs_diis_b_clear(diis_buffer,error)
    TYPE(qs_diis_buffer_type), POINTER :: diis_buffer
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='qs_diis_b_clear',&
         routineP=moduleN//':'//routineN

    failure=.FALSE.

    CPPrecondition(ASSOCIATED(diis_buffer),cp_failure_level,routineP,error,failure)
    CPPrecondition(diis_buffer%ref_count>0,cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       diis_buffer%ncall=0
    END IF
  END SUBROUTINE qs_diis_b_clear
  !***************************************************************************

END MODULE qs_diis
