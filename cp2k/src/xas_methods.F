!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2008  CP2K developers group                          !
!-----------------------------------------------------------------------------!

! *****************************************************************************
!> \brief driver for the xas calculation and xas_scf for the tp method
!> \par History
!>      created 05.2005
!> \author MI (05.2005)
! *****************************************************************************
MODULE xas_methods

  USE ai_overlap_new,                  ONLY: overlap
  USE atomic_kind_types,               ONLY: atomic_kind_type,&
                                             get_atomic_kind
  USE basis_set_types,                 ONLY: allocate_sto_basis_set,&
                                             create_gto_from_sto_basis,&
                                             deallocate_sto_basis_set,&
                                             get_gto_basis_set,&
                                             gto_basis_set_type,&
                                             init_orb_basis_set,&
                                             set_sto_basis_set,&
                                             sto_basis_set_type
  USE cell_types,                      ONLY: cell_type,&
                                             pbc
  USE cp_array_r_utils,                ONLY: cp_2d_r_p_type
  USE cp_control_types,                ONLY: dft_control_type
  USE cp_fm_basic_linalg,              ONLY: cp_fm_gemm
  USE cp_fm_pool_types,                ONLY: fm_pool_create_fm
  USE cp_fm_struct,                    ONLY: cp_fm_struct_create,&
                                             cp_fm_struct_release,&
                                             cp_fm_struct_type
  USE cp_fm_types,                     ONLY: cp_fm_create,&
                                             cp_fm_get_element,&
                                             cp_fm_get_submatrix,&
                                             cp_fm_p_type,&
                                             cp_fm_set_all,&
                                             cp_fm_set_submatrix,&
                                             cp_fm_to_fm,&
                                             cp_fm_type
  USE cp_output_handling,              ONLY: cp_p_file,&
                                             cp_print_key_finished_output,&
                                             cp_print_key_should_output,&
                                             cp_print_key_unit_nr
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE cp_sm_fm_interactions,           ONLY: cp_sm_fm_multiply
  USE global_types,                    ONLY: global_environment_type
  USE input_constants,                 ONLY: &
       do_loc_none, state_loc_all, state_loc_list, state_loc_range, &
       xas_1s_type, xas_2p_type, xas_2s_type, xas_dip_len2, xas_dip_vel, &
       xas_dscf, xas_scf_general, xas_tp_fh, xas_tp_hh, xas_tp_xfh, &
       xas_tp_xhh, xes_tp_val
  USE input_section_types,             ONLY: section_vals_get_subs_vals,&
                                             section_vals_type,&
                                             section_vals_val_get
  USE kinds,                           ONLY: default_string_length,&
                                             dp
  USE mathconstants,                   ONLY: twopi
  USE memory_utilities,                ONLY: reallocate
  USE orbital_pointers,                ONLY: ncoset
  USE particle_types,                  ONLY: get_particle_set,&
                                             particle_type
  USE periodic_table,                  ONLY: ptable
  USE physcon,                         ONLY: evolt
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_environment_type,&
                                             set_qs_env
  USE qs_loc_control,                  ONLY: localized_wfn_control_release,&
                                             localized_wfn_control_retain,&
                                             localized_wfn_control_type,&
                                             set_loc_centers,&
                                             set_loc_wfn_lists
  USE qs_loc_methods,                  ONLY: qs_loc_driver,&
                                             qs_print_cubes
  USE qs_loc_types,                    ONLY: qs_loc_env_create,&
                                             qs_loc_env_new_type,&
                                             qs_loc_env_release
  USE qs_loc_utils,                    ONLY: qs_loc_env_init
  USE qs_matrix_pools,                 ONLY: mpools_get,&
                                             qs_matrix_pools_type
  USE qs_mo_methods,                   ONLY: calculate_subspace_eigenvalues
  USE qs_mo_types,                     ONLY: get_mo_set,&
                                             mo_set_p_type,&
                                             set_mo_set,&
                                             write_mo_set
  USE qs_operators_ao,                 ONLY: p_xyz_ao,&
                                             rRc_xyz_ao,&
                                             set_up_op_sm
  USE qs_scf,                          ONLY: init_scf_loop,&
                                             init_scf_run,&
                                             scf_env_cleanup
  USE qs_scf_types,                    ONLY: ao_mixing_nr,&
                                             general_diag_method_nr,&
                                             ot_method_nr,&
                                             qs_scf_env_type
  USE scf_control_types,               ONLY: scf_control_type
  USE semi_empirical_parameters,       ONLY: srules
  USE sparse_matrix_types,             ONLY: allocate_matrix_set,&
                                             real_matrix_p_type,&
                                             replicate_matrix_structure,&
                                             set_matrix
  USE termination,                     ONLY: external_control,&
                                             stop_program
  USE timings,                         ONLY: timeset,&
                                             timestop
  USE xas_control,                     ONLY: xas_control_type
  USE xas_env_types,                   ONLY: get_xas_env,&
                                             set_xas_env,&
                                             xas_env_create,&
                                             xas_env_release,&
                                             xas_environment_type
  USE xas_restart,                     ONLY: xas_read_restart
  USE xas_tp_scf,                      ONLY: xas_do_tp_scf,&
                                             xes_scf_once
#include "cp_common_uses.h"

  IMPLICIT NONE
  PRIVATE

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'xas_methods'

! *** Public subroutines ***

  PUBLIC :: xas

CONTAINS

! *****************************************************************************
!> \brief Driver for xas calculations
!>      The initial mos are prepared
!>      A loop on the atoms to be excited is started
!>      For each atom the state to be excited is identified
!>      An scf optimization using the TP scheme or TD-DFT is used
!>      to evaluate the spectral energies and oscillator strengths
!> \param qs_env the qs_env, the xas_env lives in
!> \param globenv global environment for i/o and error
!> \param error variable to control error logging, stopping,...
!>        see module cp_error_handling
!> \note
!>      the iteration counter is not finilized yet
!>      only the transition potential approach is active
!>      the localization can be switched off, otherwise
!>      it uses by default the berry phase approach
!>      The number of states to be localized is xas_control%nexc_search
!>      In general only the core states are needed
!> \par History
!>      05.2005 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE xas(qs_env, xas_control, globenv, error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(xas_control_type)                   :: xas_control
    TYPE(global_environment_type), POINTER   :: globenv
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'xas', &
      routineP = moduleN//':'//routineN

    INTEGER :: handle, homo, i, iat, iatom, ispin, istat, iter, method0, &
      mixing0, my_homo(2), nao, nelectron, nexc_search, nmo, nspins, &
      output_unit, state_to_be_excited, xas_iter_count
    INTEGER, DIMENSION(:), POINTER           :: state_of_atom
    LOGICAL :: ch_method_flags, converged, failure, ionode, my_uocc(2), &
      should_stop, skip_scf, transition_potential, uocc
    REAL(dp)                                 :: maxocc
    REAL(dp), DIMENSION(:), POINTER          :: eigenvalues, &
                                                occupation_numbers
    REAL(dp), DIMENSION(:, :), POINTER       :: vecbuffer
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_fm_p_type), DIMENSION(:), &
      POINTER                                :: groundstate_coeff
    TYPE(cp_fm_type), POINTER                :: all_vectors, excvec_coeff, &
                                                mo_coeff
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(localized_wfn_control_type), &
      POINTER                                :: my_localized_wfn_control
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(qs_loc_env_new_type), POINTER       :: qs_loc_env
    TYPE(qs_scf_env_type), POINTER           :: scf_env
    TYPE(real_matrix_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks, op_sm, ostrength_sm
    TYPE(scf_control_type), POINTER          :: scf_control
    TYPE(section_vals_type), POINTER         :: dft_section, loc_section, &
                                                scf_section, xas_section
    TYPE(xas_environment_type), POINTER      :: xas_env

!   ---------------------------------------------------------------------------

    CALL timeset(routineN,"I",'',handle)

    failure = .FALSE.
    transition_potential = .FALSE.
    skip_scf = .FALSE.
    converged = .TRUE.
    should_stop = .FALSE.

    NULLIFY(logger)
    logger => cp_error_get_logger(error)
    ionode = logger%para_env%mepos==logger%para_env%source
    IF (ionode) THEN
      output_unit= cp_logger_get_default_unit_nr(logger)
    ELSE
      output_unit = -1
    END IF

    NULLIFY(xas_env, groundstate_coeff, ostrength_sm, op_sm)
    NULLIFY(excvec_coeff, state_of_atom, qs_loc_env, cell)
    NULLIFY(occupation_numbers,my_localized_wfn_control,matrix_ks)
    NULLIFY(all_vectors,state_of_atom)
    NULLIFY(dft_section, xas_section, loc_section)
    dft_section => section_vals_get_subs_vals(qs_env%input,"DFT",error=error)
    scf_section => section_vals_get_subs_vals(dft_section,"SCF",error=error)
    xas_section => section_vals_get_subs_vals(dft_section,"XAS",error=error)
    loc_section => section_vals_get_subs_vals(xas_section,"LOCALIZE",error=error)

    output_unit = cp_print_key_unit_nr(logger,xas_section,"PRINT%PROGRAM_RUN_INFO",&
         extension=".Log",error=error)
    IF (output_unit>0) THEN
       WRITE (UNIT=output_unit,FMT="(/,T3,A,/,T25,A,/,T3,A,/)")&
            REPEAT("=",77),&
            "START CORE LEVEL SPECTROSCOPY CALCULATION",&
            REPEAT("=",77)
    END IF

!   Create the xas environment
    CALL get_qs_env(qs_env,xas_env=xas_env,error=error)
    IF (.NOT.ASSOCIATED(xas_env)) THEN
       IF (output_unit>0) THEN
          WRITE (UNIT=output_unit,FMT="(/,T10,A,/)")&
           "Create and initialize the xas environment"
       END IF
      CALL xas_env_create(xas_env, error=error)
      CALL xas_env_init(xas_env, xas_control, qs_env, xas_section, logger, error=error)
      CALL set_qs_env(qs_env,xas_env=xas_env, error=error)
      CALL xas_env_release(xas_env,error=error)
      CALL get_qs_env(qs_env,xas_env=xas_env,error=error)
    END IF

!   Initialize the type of calculation
    NULLIFY(atomic_kind_set, dft_control, scf_control, mos, para_env, particle_set)
    CALL get_qs_env(qs_env=qs_env, atomic_kind_set=atomic_kind_set, &
         cell = cell, dft_control=dft_control, scf_control=scf_control,&
         matrix_ks=matrix_ks,mos=mos, para_env=para_env, particle_set=particle_set ,error=error)

!   The eigenstate of the KS Hamiltonian are nedeed
    NULLIFY(mo_coeff,eigenvalues)
    IF(scf_control%use_ot) THEN
       IF (output_unit>0) THEN
          WRITE (UNIT=output_unit,FMT="(/,T10,A,/)")&
               "Get eigenstates and eigenvalues from ground state MOs"
       END IF
      DO ispin = 1,dft_control%nspins
        CALL get_mo_set(mos(ispin)%mo_set, mo_coeff=mo_coeff,nao=nao,nmo=nmo,&
             eigenvalues=eigenvalues,homo=homo)
        CALL calculate_subspace_eigenvalues(mo_coeff,&
             matrix_ks(ispin)%matrix,eigenvalues, &
             para_env=para_env, &
             do_rotation=.TRUE.,error=error)
      END DO
    END IF

!   Set initial occupation numbers, and store the original ones
    DO ispin = 1,dft_control%nspins
        CALL get_mo_set(mos(ispin)%mo_set,nelectron=nelectron,maxocc=maxocc,&
             homo=my_homo(ispin),uniform_occupation=my_uocc(ispin))
      IF(scf_control%smear /= 0.0_dp) THEN
        homo = NINT(nelectron/maxocc)
        uocc = .TRUE.
        CALL set_mo_set(mos(ispin)%mo_set, homo=homo,uniform_occupation=uocc,error=error)
      END IF
    END DO

    nspins = dft_control%nspins
    transition_potential = (xas_control%xas_method==xas_tp_hh).OR.&
                           (xas_control%xas_method==xas_tp_fh).OR.&
                           (xas_control%xas_method==xas_tp_xhh).OR.&
                           (xas_control%xas_method==xas_tp_xfh).OR.&
                           (xas_control%xas_method==xas_dscf)
    IF(nspins==1 .AND. transition_potential) THEN
       CALL stop_program(routineP,"xas with tp method requires LSD calculations")
    END IF

!   Set of states among which there is the state to be excited
    CALL get_mo_set(mos(1)%mo_set,nao=nao,homo=homo)
    IF(xas_control%nexc_search < 0) xas_control%nexc_search = homo
    nexc_search = xas_control%nexc_search

    CALL get_xas_env(xas_env=xas_env,iter_count=xas_iter_count,&
         state_of_atom=state_of_atom,all_vectors=all_vectors,&
         groundstate_coeff=groundstate_coeff,excvec_coeff=excvec_coeff,error=error)

    xas_iter_count =  xas_iter_count + 1
    CALL set_xas_env(xas_env=xas_env,iter_count=xas_iter_count,error=error)

!   SCF for only XES using occupied core and empty homo (only one SCF)
!   Probably better not to do the localization in this case, but only single out the
!   core orbital for the specific atom for which the spectrum is computed
    IF(xas_control%xas_method==xes_tp_val .AND. &
                   xas_control%xes_core_occupation==1.0_dp) THEN
      IF(.NOT.xas_control%emission) THEN
        CALL stop_program(routineP,"CLS: emission is required")
      END IF
      IF (output_unit>0) WRITE(UNIT=output_unit,FMT='(/,/,T10,A)') &
        "START Core Level Spectroscopy Calculation for the Emission Spectrum"
      IF (output_unit>0) WRITE(UNIT=output_unit,FMT='(T10,A,/,A)')&
       "The core state is fully occupied and the homo is empty",&
       " (final state of the core hole decay). Only one SCF is needed (not one per atom)"
      skip_scf = .TRUE.

      CALL xes_scf_once(qs_env,xas_env,scf_section,globenv,converged,should_stop,error=error)

      IF(converged .AND. .NOT. should_stop) THEN

        IF (output_unit>0) WRITE(UNIT=output_unit,FMT='(/,T10,A,I6)') &
              "SCF with empty homo converged "
      ELSE
        IF (output_unit>0) WRITE(UNIT=output_unit,FMT='(/,T10,A,I6)') &
              "SCF with empty homo NOT converged"
        GOTO 1000
      END IF

    END IF

   !Define the qs_loc_env : to find centers, spread and possibly localize them
    my_localized_wfn_control =>  xas_control%localized_wfn_control
    CALL localized_wfn_control_retain(my_localized_wfn_control,error=error)
    CPPrecondition(ASSOCIATED(my_localized_wfn_control),cp_failure_level,routineP,error,failure)

    CALL get_xas_env(xas_env=xas_env, qs_loc_env=qs_loc_env,error=error)
    IF (xas_control%localized_wfn) THEN
      IF(output_unit>0) THEN
          WRITE (UNIT=output_unit,FMT="(/,T10,A,/)")&
              "Localize a sub-set of MOs with spin alpha,"//&
              " to better identify the core states that have to be excited"
          IF(&
              my_localized_wfn_control%set_of_states == state_loc_range .OR. &
              my_localized_wfn_control%set_of_states == state_loc_all) THEN
              WRITE (UNIT=output_unit,FMT="( A , I7, A, I7)") " The sub-setcontains the states from ",&
                  my_localized_wfn_control%lu_bound_states(1,1), " to ",&
                  my_localized_wfn_control%lu_bound_states(2,1)  
         ELSEIF (my_localized_wfn_control%set_of_states==state_loc_list) THEN
              WRITE (UNIT=output_unit,FMT="( A )") " The sub-set contains the states given in the input list"

         END IF

      END IF
      IF(.NOT.(ASSOCIATED(qs_loc_env))) THEN
        CALL qs_loc_env_create(qs_loc_env,error=error)
        CALL set_xas_env(xas_env=xas_env, qs_loc_env=qs_loc_env,error=error)
        CALL qs_loc_env_release(qs_loc_env,error=error)
        CALL get_xas_env(xas_env=xas_env, qs_loc_env=qs_loc_env,error=error)
        CALL qs_loc_env_init(qs_loc_env,my_localized_wfn_control,&
             qs_env,myspin=1,do_localize=xas_control%localized_wfn,error=error)
      END IF
      CALL qs_loc_driver(qs_env,qs_loc_env,loc_section,myspin=1,error=error)
    END IF

    CALL cls_assign_core_states(xas_control,xas_env,my_localized_wfn_control,&
         qs_env,error=error)

    IF(skip_scf) THEN
      CALL get_mo_set(mos(1)%mo_set,mo_coeff=mo_coeff)
      CALL cp_fm_to_fm(mo_coeff,all_vectors,ncol=nexc_search,&
             source_start=1,target_start=1)
    END IF

    CALL localized_wfn_control_release(my_localized_wfn_control,error=error)

  ! If required check the character of the states of each atom
  ! by taking the overlap with atomic-like states

    ALLOCATE(vecbuffer(1,nao),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    ALLOCATE (op_sm(3),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

  ! copy the coefficients of the mos in a temporary fm with the right structure
    IF(transition_potential) THEN
      CPPrecondition(ASSOCIATED(groundstate_coeff),cp_failure_level,routineP,error,failure)
      DO ispin = 1,nspins
       CALL get_mo_set(mos(ispin)%mo_set, mo_coeff=mo_coeff,&
            nao=nao, nmo=nmo)
       CALL cp_fm_to_fm(mo_coeff,groundstate_coeff(ispin)%matrix,nmo,1,1)
      END DO

      ! Calculate the operator
      CALL get_xas_env(xas_env=xas_env,ostrength_sm=ostrength_sm,error=error)
      DO i = 1,3
        NULLIFY(op_sm(i)%matrix)
          op_sm(i)%matrix => ostrength_sm(i)%matrix
      END DO
      IF(xas_control%dipole_form==xas_dip_vel) THEN
          CALL p_xyz_ao(op_sm,qs_env,error=error)
      END IF

    END IF
    ! by using td-dft case the oscillator strength should be obtained from the linear response orbitals

    DO iat = 1,xas_control%nexc_atoms
       iatom = xas_control%exc_atoms(iat)
       ! determine which state has to be excited in the global list
       state_to_be_excited = state_of_atom(iat)

      ! Take the state_to_be_excited vector from the full set and copy into excvec_coeff
       CALL get_mo_set(mos(1)%mo_set, &
            occupation_numbers=occupation_numbers,homo=homo,nmo=nmo,nelectron=nelectron)
       IF(xas_control%xas_method==xas_dscf .OR. xas_control%xas_method==xas_tp_xhh &
         .OR.  xas_control%xas_method==xas_tp_xfh) THEN
          homo = nelectron + 1
          CPPrecondition(.NOT.(nmo<homo),cp_failure_level,routineP,error,failure)
          CALL set_mo_set(mos(1)%mo_set, homo = homo, error=error)
       END IF
       occupation_numbers(1:homo)  = 1.0_dp
      ! If the restart file for this atom exists, the mos and the
      ! occupation numbers are overwritten
      ! It is necessary that the restart is for the same xas method
      ! otherwise the number of electrons and the occupation numbers
      ! may not  be consistent
      IF(xas_control%xas_restart) THEN
         CALL xas_read_restart(xas_control,xas_section, qs_env,iatom,&
              state_to_be_excited,error=error)
      END IF

       dft_control % xas_estate  = state_to_be_excited
       CALL get_mo_set(mos(1)%mo_set, mo_coeff=mo_coeff)
       CPPrecondition(ASSOCIATED(excvec_coeff),cp_failure_level,routineP,error,failure)
       CALL cp_fm_get_submatrix(mo_coeff,vecbuffer,1,state_to_be_excited,&
            nao,1,transpose=.TRUE.,error=error)
       CALL cp_fm_set_submatrix(excvec_coeff,vecbuffer,1,1,&
            nao,1,transpose=.TRUE.,error=error)

      IF (transition_potential) THEN

        IF(.NOT. skip_scf) THEN
          IF (output_unit>0) THEN
            IF(xas_control%xas_method==xas_dscf) THEN
              WRITE(UNIT=output_unit,FMT='(/,/,T10,A,I6)') &
              "START DeltaSCF for the first excited state from the core state of ATOM ", iatom
            ELSE
              WRITE(UNIT=output_unit,FMT='(/,/,T10,A,I6)') &
               "Start Core Level Spectroscopy Calculation with TP approach for ATOM ", iatom
              WRITE(UNIT=output_unit,FMT='(T10,A,f10.4)') "Occupation of the core orbital",&
                xas_control%occ_estate
              IF(homo==nelectron + 1) THEN
                WRITE(UNIT=output_unit,FMT='(T10,A,f10.4)') &
                 "Occupation of the lowest virtual orbital ",&
                 xas_control%occ_homo
              END IF
            END IF
          END IF

         ! DO SCF if required
          NULLIFY(scf_env)
          CALL get_qs_env(qs_env,scf_env=scf_env,error=error)
          ! OT cannot be used with different occupation numbers in the core
          ! Therefore in case of XAS the general_diag_method_nr is imposed
          ch_method_flags = .FALSE.
          IF( xas_control%occ_estate .LT. 1.0_dp .AND. scf_env%method == ot_method_nr) THEN
        CPPostcondition( xas_env%scf_method==xas_scf_general,cp_failure_level,routineP,error,failure)
            method0 = scf_env%method
            scf_env%method = general_diag_method_nr
            mixing0 = scf_env%mixing_method
            scf_env%mixing_method = ao_mixing_nr
            ch_method_flags = .TRUE.
          END IF

          CALL init_scf_run(scf_env=scf_env,qs_env=qs_env,&
                  scf_section=scf_section, error=error)
          ! this is not standing optimally here, but for the time being retains functionality
          CALL init_scf_loop(scf_env=scf_env,qs_env=qs_env,&
                  scf_section=scf_section, error=error)

          CALL xas_do_tp_scf(xas_control,xas_env,iatom,scf_env,qs_env,globenv,&
               converged,should_stop,error=error)

          CALL external_control(should_stop,"CLS",globenv,error)
          IF(should_stop)THEN
             CALL scf_env_cleanup(scf_env,qs_env=qs_env,error=error)
             GO TO 1000
          END IF
          IF(iat == xas_control%nexc_atoms) THEN
             CALL scf_env_cleanup(scf_env,qs_env=qs_env,error=error)
          END IF
          ! Set back the original method for the optimize
          IF(ch_method_flags) THEN
            scf_env%method = method0
            scf_env%mixing_method = mixing0
          END IF

        END IF
       ! SCF DONE

!   *** Write last wavefunction to screen ***
        DO ispin=1,dft_control%nspins
           CALL write_mo_set(mos(ispin)%mo_set,atomic_kind_set,particle_set,&
           4,6,dft_section,error=error)
        ENDDO

      ELSE
        ! Core level spectroscopy by TDDFT is not yet implemented
        ! the states defined by the rotation are the ground state orbitals
        ! the initial state from which I excite should be localized
        ! I take the excitations from lumo to nmo
      END IF

      !update iteration counter
      iter = xas_iter_count!*xas_control%each_step

      IF(converged) THEN
        CALL cls_calculate_spectrum(xas_control,xas_env,qs_env,xas_section,&
             iatom,iter,error=error)
      ELSE
        IF (output_unit>0) WRITE(UNIT=output_unit,FMT='(/,/,T10,A,I6)') &
              "SCF with core hole NOT converged for ATOM ", iatom
      END IF

      IF(.NOT.skip_scf) THEN
        ! Reset the initial core orbitals.
        ! The valence orbitals are taken from the last SCF,
        ! it should be a better initial guess
         DO ispin = 1,nspins
            CALL get_mo_set(mos(ispin)%mo_set, mo_coeff=mo_coeff,&
                 nao=nao, nmo=nmo)
            CALL cp_fm_to_fm(groundstate_coeff(ispin)%matrix,mo_coeff,nmo,1,1)
         END DO
      END IF

    END DO

  ! Release what has to be released
    DEALLOCATE(vecbuffer,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    DEALLOCATE(op_sm,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

1000  CONTINUE  ! END of Calculation

    DO ispin = 1,dft_control%nspins
       CALL set_mo_set(mos(ispin)%mo_set, homo=my_homo(ispin),&
            uniform_occupation=my_uocc(ispin), error=error)
    END DO

    dft_control % xas_estate    = -1

    IF (output_unit>0) THEN
       WRITE (UNIT=output_unit,FMT="(/,T3,A,/,T25,A,/,T3,A,/)")&
            REPEAT("=",77),&
            "END CORE LEVEL SPECTROSCOPY CALCULATION",&
            REPEAT("=",77)
    END IF

    CALL cp_print_key_finished_output(output_unit,logger,xas_section,&
         "PRINT%PROGRAM_RUN_INFO",error=error)
    CALL timestop(0.0_dp,handle)

  END SUBROUTINE  xas

! *****************************************************************************
!> \brief allocate and initialize the structure needed for the xas calculation
!> \param xas_env the environment for XAS  calculations
!> \param xas_control parameters for the xas calculation
!> \param qs_env the qs_env, the xas_env lives in
!> \param error variable to control error logging, stopping,...
!>        see module cp_error_handling
!> \par History
!>      05.2005 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE xas_env_init(xas_env, xas_control, qs_env, xas_section, logger, error)

    TYPE(xas_environment_type), POINTER      :: xas_env
    TYPE(xas_control_type)                   :: xas_control
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(section_vals_type), POINTER         :: xas_section
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'xas_env_init', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_string_length)     :: name_sto
    INTEGER :: homo, i, iat, iatom, ik, ikind, ispin, istat, j, l, n_mo(2), &
      n_rep, nao, ncubes, nelectron, nexc_atoms, nexc_search, nj, nk, nkind, &
      nmo, nmoloc(2), norb(0:3), nsgf_gto, nsgf_sto, nspins, nwork
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: kind_type_tmp, kind_z_tmp
    INTEGER, DIMENSION(4, 7)                 :: ne
    INTEGER, DIMENSION(:), POINTER           :: bounds, list, lq, nq
    LOGICAL                                  :: failure, ihavethis
    REAL(dp)                                 :: zatom
    REAL(dp), DIMENSION(:), POINTER          :: sto_zet
    REAL(dp), DIMENSION(:, :), POINTER       :: sto_alpha
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_fm_struct_type), POINTER         :: tmp_fm_struct
    TYPE(cp_fm_type), POINTER                :: mo_coeff
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(gto_basis_set_type), POINTER        :: orb_basis_set
    TYPE(localized_wfn_control_type), &
      POINTER                                :: my_localized_wfn_control
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(qs_matrix_pools_type), POINTER      :: mpools
    TYPE(real_matrix_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s
    TYPE(scf_control_type), POINTER          :: scf_control
    TYPE(sto_basis_set_type), POINTER        :: sto_basis_set

!------------------------------------------------------------------------------

    failure=.FALSE.

    n_mo(1:2) = 0

    CPPrecondition(ASSOCIATED(xas_env),cp_failure_level,routineP,error,failure)

    IF(.NOT. failure) THEN

      NULLIFY( atomic_kind_set, dft_control, scf_control, matrix_s, mos, mpools )
      NULLIFY( para_env, particle_set)
      CALL get_qs_env(qs_env=qs_env, &
              atomic_kind_set=atomic_kind_set, &
              dft_control = dft_control, &
              scf_control = scf_control, &
              mpools=mpools,&
              matrix_s=matrix_s, mos=mos, &
              para_env=para_env, particle_set=particle_set,error=error)
      nexc_search = xas_control%nexc_search
      nexc_atoms = xas_control%nexc_atoms

      xas_env%eps_diis = xas_control%eps_diis
      IF(xas_env%eps_diis .LT. 0.0_dp) xas_env%eps_diis = scf_control%eps_diis
      xas_env%p_mix = xas_control%p_mix
      IF(xas_env%p_mix .LT. 0.0_dp) xas_env%p_mix = scf_control%p_mix
      xas_env%scf_method = xas_control%scf_method

      CALL mpools_get(mpools, ao_mo_fm_pools= xas_env%ao_mo_fm_pools,error=error)

      NULLIFY(mo_coeff)
      CALL get_mo_set(mos(1)%mo_set,nao=nao,homo=homo,nmo=nmo,mo_coeff=mo_coeff)
      IF(nexc_search < 0) nexc_search = homo

      IF(xas_control%emission) THEN
         xas_env%nvirtual1 = nmo
      ELSE
         xas_env%nvirtual1 = nmo - homo
      END IF
      IF(xas_control%added_mos .GT. 0) THEN
         xas_env%nvirtual2 = MIN(xas_control%added_mos,nao-nmo)
         xas_env%unoccupied_eps = xas_control%eps_added
         xas_env%unoccupied_max_iter = xas_control%max_iter_added
      END IF
      xas_env%nvirtual = xas_env%nvirtual1 +  xas_env%nvirtual2

      n_mo(1:2) = nmo

      ALLOCATE(xas_env%centers_wfn(3,nexc_search),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      ALLOCATE(xas_env%atom_of_state(nexc_search),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      ALLOCATE(xas_env%type_of_state(nexc_search),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      ALLOCATE(xas_env%state_of_atom(nexc_atoms),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      ALLOCATE(xas_env%mykind_of_atom(nexc_atoms),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      nkind = SIZE(atomic_kind_set,1)
      ALLOCATE(xas_env%mykind_of_kind(nkind),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      xas_env%mykind_of_kind = 0
      ALLOCATE(xas_env%spectrum(5,xas_env%nvirtual),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

      ! create a new matrix structure nao x 1
      NULLIFY(tmp_fm_struct)
      CALL cp_fm_struct_create(tmp_fm_struct,nrow_global=nao,&
           ncol_global=1,para_env=para_env,context=mo_coeff%matrix_struct%context,error=error)
      CALL cp_fm_create (xas_env%excvec_coeff, tmp_fm_struct ,error=error)
      CALL cp_fm_struct_release ( tmp_fm_struct ,error=error)

      NULLIFY(tmp_fm_struct)
      CALL cp_fm_struct_create(tmp_fm_struct,nrow_global=1,&
           ncol_global=nexc_search,para_env=para_env,&
           context=mo_coeff%matrix_struct%context,error=error)
      CALL cp_fm_create (xas_env%excvec_overlap, tmp_fm_struct ,error=error)
      CALL cp_fm_struct_release ( tmp_fm_struct ,error=error)

      nspins = SIZE(mos,1)

   ! initialize operators for the calculation of the oscillator strengts
      IF (xas_control%xas_method==xas_tp_hh) THEN
        xas_control%occ_estate = 0.5_dp
        xas_control%occ_homo = 1.0_dp
      ELSEIF(xas_control%xas_method==xas_tp_xhh) THEN
        xas_control%occ_estate = 0.5_dp
        xas_control%occ_homo = 0.5_dp
      ELSEIF(xas_control%xas_method==xas_tp_fh) THEN
        xas_control%occ_estate = 0.0_dp
        xas_control%occ_homo = 1.0_dp
      ELSEIF(xas_control%xas_method==xas_tp_xfh) THEN
        xas_control%occ_estate = 0.0_dp
        xas_control%occ_homo = 1.0_dp
      ELSEIF(xas_control%xas_method==xes_tp_val) THEN
        xas_control%occ_estate = xas_control%xes_core_occupation
        xas_control%occ_homo = 1.0_dp-xas_control%xes_core_occupation
        xas_control%emission = .TRUE.
      ELSEIF(xas_control%xas_method==xas_dscf) THEN
        xas_control%occ_estate = 0.0_dp
        xas_control%occ_homo = 1.0_dp
      ENDIF

     ! Initialize the list of orbitals for cube files printing
     IF (BTEST(cp_print_key_should_output(logger%iter_info,xas_section,&
                    "PRINT%CLS_FUNCTION_CUBES",error=error),cp_p_file)) THEN
        NULLIFY(bounds,list)
        CALL section_vals_val_get(xas_section,&
             "PRINT%CLS_FUNCTION_CUBES%CUBES_LU_BOUNDS",&
             i_vals=bounds,error=error) 
        ncubes = bounds(2) - bounds(1)  + 1
        IF(ncubes > 0 ) THEN
          ALLOCATE( xas_control%list_cubes(ncubes),STAT=istat)
          CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

          DO ik = 1,ncubes
            xas_control%list_cubes(ik) = bounds(1) + (ik-1)
          END DO
        END IF

        IF(.NOT. ASSOCIATED(xas_control%list_cubes)) THEN
          CALL section_vals_val_get(xas_section, &
               "PRINT%CLS_FUNCTION_CUBES%CUBES_LIST",&
               n_rep_val=n_rep,error=error)
          ncubes = 0
          DO ik = 1,n_rep
            NULLIFY(list)
            CALL section_vals_val_get(xas_section,&
                 "PRINT%CLS_FUNCTION_CUBES%CUBES_LIST",&
                 i_rep_val=ik,i_vals=list,error=error)
            IF(ASSOCIATED(list)) THEN
              CALL reallocate(xas_control%list_cubes,1,ncubes+ SIZE(list))
              DO i = 1, SIZE(list)
                xas_control%list_cubes(i+ncubes) = list(i)
              END DO
              ncubes = ncubes + SIZE(list)
            END IF
          END DO  ! ik
        END IF

        IF(.NOT. ASSOCIATED(xas_control%list_cubes)) THEN
          ncubes = MAX(10,xas_control%added_mos/10)
          ncubes = MIN(ncubes,xas_control%added_mos)
          ALLOCATE( xas_control%list_cubes(ncubes),STAT=istat)
          CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
          DO ik = 1,ncubes
            xas_control%list_cubes(ik) = homo + ik
          END DO
        END IF
      ELSE
        NULLIFY(xas_control%list_cubes)
      ENDIF

      NULLIFY(tmp_fm_struct)
      nwork = MAX(xas_env%nvirtual,nmo)
      CALL cp_fm_struct_create(tmp_fm_struct,nrow_global=nao,ncol_global=nwork,&
           para_env=para_env,context=mo_coeff%matrix_struct%context,error=error)
      CALL cp_fm_create (xas_env%fm_work,tmp_fm_struct,error=error)
      CALL cp_fm_struct_release ( tmp_fm_struct ,error=error)
  
      ALLOCATE (xas_env%groundstate_coeff(nspins), STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      DO ispin = 1,nspins
        NULLIFY(xas_env%groundstate_coeff(ispin)%matrix)
        CALL get_mo_set(mos(ispin)%mo_set,nao=nao,nmo=nmo)
        CALL fm_pool_create_fm(xas_env%ao_mo_fm_pools(ispin)%pool,&
             xas_env%groundstate_coeff(ispin)%matrix,&
           name="xas_env%mo0"//TRIM(ADJUSTL(cp_to_string(ispin))),error=error)
      END DO  ! ispin
  
      NULLIFY(tmp_fm_struct)
      CALL cp_fm_struct_create(tmp_fm_struct,nrow_global=1,&
           ncol_global=xas_env%nvirtual,para_env=para_env,&
           context=mo_coeff%matrix_struct%context,error=error)
      ALLOCATE (xas_env%dip_fm_set(2,3),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      DO i = 1,3
        DO j = 1,2
           NULLIFY(xas_env%dip_fm_set(j,i)%matrix)
           CALL cp_fm_create (xas_env%dip_fm_set(j,i)%matrix, tmp_fm_struct ,error=error)
        END DO
      END DO
      CALL cp_fm_struct_release ( tmp_fm_struct ,error=error)
  
      !Array to store all the eigenstates: occupied and the required not occupied
      IF(xas_env%nvirtual2 .GT. 0) THEN
        ALLOCATE(xas_env%unoccupied_evals(xas_env%nvirtual2), STAT=istat)
        CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
        NULLIFY(tmp_fm_struct)
        CALL cp_fm_struct_create(tmp_fm_struct,nrow_global=nao,&
             ncol_global=xas_env%nvirtual2,&
             para_env=para_env,context=mo_coeff%matrix_struct%context,error=error)
        NULLIFY(xas_env%unoccupied_orbs)
        CALL cp_fm_create (xas_env%unoccupied_orbs,tmp_fm_struct,error=error)
        CALL cp_fm_struct_release ( tmp_fm_struct ,error=error)
  
      END IF
  
      NULLIFY(tmp_fm_struct)
      CALL cp_fm_struct_create(tmp_fm_struct,nrow_global=nao, &
           ncol_global=xas_env%nvirtual,&
           para_env=para_env,context=mo_coeff%matrix_struct%context,error=error)
      NULLIFY(xas_env%all_vectors)
      CALL cp_fm_create (xas_env%all_vectors,tmp_fm_struct,error=error)
      CALL cp_fm_struct_release ( tmp_fm_struct ,error=error)
  
      ! Array to store all the energies needed  for the spectrum
      ALLOCATE(xas_env%all_evals(xas_env%nvirtual), STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
  
      IF(xas_control%dipole_form==xas_dip_len2) THEN
        CALL allocate_matrix_set(xas_env%ostrength_sm,3,error=error)
        DO i = 1,3
           NULLIFY(xas_env%ostrength_sm(i)%matrix)
           CALL replicate_matrix_structure(matrix_s(1)%matrix, &
                xas_env%ostrength_sm(i)%matrix,"xas_env%ostrength_sm"//&
                "-"//TRIM(ADJUSTL(cp_to_string(i))),target_symmetry="symmetric",error=error)
           CALL set_matrix(xas_env%ostrength_sm(i)%matrix,0.0_dp)
        END DO
      ELSEIF(xas_control%dipole_form==xas_dip_vel) THEN
        CALL allocate_matrix_set(xas_env%ostrength_sm,3,error=error)
        NULLIFY(xas_env%ostrength_sm(1)%matrix)
        CALL set_up_op_sm(xas_env%ostrength_sm(1)%matrix,qs_env,symmetry="antisymmetric",&
        name="xas_env%ostrength_sm",error=error)
        CALL set_matrix(xas_env%ostrength_sm(1)%matrix,0.0_dp)
        DO i = 2,3
           NULLIFY(xas_env%ostrength_sm(i)%matrix)
           CALL replicate_matrix_structure(xas_env%ostrength_sm(1)%matrix, &
                xas_env%ostrength_sm(i)%matrix,"xas_env%ostrength_sm"//&
                "-"//TRIM(ADJUSTL(cp_to_string(i))),target_symmetry="antisymmetric",error=error)
           CALL set_matrix(xas_env%ostrength_sm(i)%matrix,0.0_dp)
        END DO
      END IF

   !Define the qs_loc_env : to find centers, spread and possibly localize them
      my_localized_wfn_control =>  xas_control%localized_wfn_control
      CALL localized_wfn_control_retain(my_localized_wfn_control,error=error)
      CPPrecondition(ASSOCIATED(my_localized_wfn_control),cp_failure_level,routineP,error,failure)
      IF(.NOT. xas_control%localized_wfn) THEN
        my_localized_wfn_control%localization_method = do_loc_none
        nmoloc = 0
      ELSE
        CALL get_mo_set(mos(1)%mo_set,nelectron=nelectron,mo_coeff=mo_coeff)
        nmoloc = 0
        IF(my_localized_wfn_control%set_of_states == state_loc_all) THEN
          nmoloc(1) = nelectron
          my_localized_wfn_control%nloc_states(1)=nelectron
          nmoloc(2) = 0
          my_localized_wfn_control%nloc_states(2)=0
!        ELSEIF(my_localized_wfn_control%set_of_states == state_loc_range) THEN
!          nmoloc(1) = nexc_search
!          my_localized_wfn_control%nloc_states(1)=nexc_search
!          nmoloc(2) = 0
!          my_localized_wfn_control%nloc_states(2)=0
        ELSE
          nmoloc(1) = MIN(my_localized_wfn_control%nloc_states(1) ,nelectron)
          nmoloc(2) = 0
        END IF
      END IF

      CALL set_loc_wfn_lists(xas_control%localized_wfn_control,nmoloc,n_mo,nspins,error=error)
      CALL set_loc_centers(xas_control%localized_wfn_control,nmoloc,nspins,error=error)

      CALL localized_wfn_control_release(my_localized_wfn_control,error=error)

      !Type of state
      norb = 0
      ALLOCATE(nq(1),lq(1),sto_zet(1),STAT=istat)
      IF( xas_control%state_type == xas_1s_type) THEN
        norb(0) = 1
        ALLOCATE(sto_alpha(1,0:1),STAT=istat)
        CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
        nq(1) = 1
        lq(1) = 0
      ELSEIF( xas_control%state_type == xas_2s_type ) THEN
        norb(0) = 2
        ALLOCATE(sto_alpha(2,0:1),STAT=istat)
        CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
        nq(1) = 2
        lq(1) = 0
      ELSEIF( xas_control%state_type == xas_2p_type ) THEN
        norb(0) = 2
        norb(1) = 1
        ALLOCATE(sto_alpha(2,0:1),STAT=istat)
        CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
        nq(1) = 2
        lq(1) = 1
      ELSE
        CALL stop_program(routineP,"xas type of state not implemented")
      END IF

      ALLOCATE(kind_type_tmp(nkind),STAT=istat)
      ALLOCATE(kind_z_tmp(nkind),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      kind_type_tmp = 0
      kind_z_tmp = 0
      nk=0
      DO iat = 1,xas_control%nexc_atoms
        iatom = xas_control%exc_atoms(iat)
        NULLIFY(atomic_kind)
        atomic_kind =>  particle_set(iatom)%atomic_kind
        CALL get_atomic_kind(atomic_kind=atomic_kind,&
             kind_number=ikind,zeff=zatom)
        ihavethis = .FALSE.
        DO ik = 1,nk
          IF(ikind==kind_type_tmp(ik)) THEN
            ihavethis = .TRUE.
            xas_env%mykind_of_atom(iat) = ik
            EXIT
          END IF
        END DO
        IF(.NOT. ihavethis) THEN
          nk = nk +1
          kind_type_tmp(nk) = ikind
          kind_z_tmp(nk) = INT(zatom)
          xas_env%mykind_of_atom(iat) = nk
          xas_env%mykind_of_kind(ikind) = nk
        END IF
      END DO  ! iat

      ALLOCATE(xas_env%my_gto_basis(nk),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      ALLOCATE(xas_env%stogto_overlap(nk),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      DO ik = 1,nk
        NULLIFY(xas_env%my_gto_basis(ik)%gto_basis_set,sto_basis_set)
        sto_alpha = 0.0_dp
        ne = 0
        DO l=1,4 !lq(1)+1
          nj = 2*(l-1)+1
          DO i=l, 7! nq(1)
            ne(l,i) = ptable(kind_z_tmp(ik))%e_conv(l-1) - 2*nj*(i-l)
            ne(l,i) = MAX(ne(l,i),0)
            ne(l,i) = MIN(ne(l,i),2*nj)
          END DO
        END DO

         sto_alpha(nq(1),lq(1))=srules(kind_z_tmp(ik),ne,nq(1),lq(1))
        sto_zet(1) = sto_alpha(nq(1),lq(1))
        CALL allocate_sto_basis_set(sto_basis_set,error)
        name_sto='xas_tmp_sto'
        CALL set_sto_basis_set(sto_basis_set,nshell=1,nq=nq,&
             lq=lq,zet=sto_zet,name=name_sto)
        CALL create_gto_from_sto_basis(sto_basis_set,&
             xas_env%my_gto_basis(ik)%gto_basis_set,xas_control%ngauss,error=error)
        CALL deallocate_sto_basis_set(sto_basis_set,error)
        xas_env%my_gto_basis(ik)%gto_basis_set%norm_type = 2
        CALL init_orb_basis_set(xas_env%my_gto_basis(ik)%gto_basis_set,error)

        atomic_kind => atomic_kind_set(kind_type_tmp(ik))
        CALL get_atomic_kind(atomic_kind=atomic_kind,&
             orb_basis_set=orb_basis_set)

        CALL get_gto_basis_set(gto_basis_set=orb_basis_set,nsgf=nsgf_gto)
        CALL get_gto_basis_set(gto_basis_set=xas_env%my_gto_basis(ik)%gto_basis_set,nsgf=nsgf_sto)
        ALLOCATE(xas_env%stogto_overlap(ik)%array(nsgf_sto,nsgf_gto),STAT=istat)
        CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

        CALL calc_stogto_overlap(xas_env%my_gto_basis(ik)%gto_basis_set,orb_basis_set,&
             xas_env%stogto_overlap(ik)%array,error=error)
      END DO

      DEALLOCATE(nq,lq,sto_zet,STAT=istat)
      DEALLOCATE(sto_alpha,STAT=istat)
      DEALLOCATE(kind_type_tmp,kind_z_tmp,STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    END IF  ! failure

  END SUBROUTINE xas_env_init

! *****************************************************************************
!> \brief Calculate and write the spectrum relative to the core level excitation
!>      of a specific atom. It works for TP approach, because of the definition
!>      of the oscillator strengths as  matrix elements of the dipole operator
!> \param iatom index of the excited atom
!> \param iter iteration of the xas calculation
!> \param error variable to control error logging, stopping,...
!>        see module cp_error_handling
!> \note
!>      for the tddft calculation should be re-thought
!> \par History
!>      03.2006 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE cls_calculate_spectrum(xas_control,xas_env,qs_env,xas_section,&
             iatom,iter,error)

    TYPE(xas_control_type)                   :: xas_control
    TYPE(xas_environment_type), POINTER      :: xas_env
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(section_vals_type), POINTER         :: xas_section
    INTEGER, INTENT(IN)                      :: iatom, iter
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'cls_calculate_spectrum', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: homo, i, istat, output_unit
    LOGICAL                                  :: failure, ionode, length
    REAL(dp)                                 :: rc(3)
    REAL(dp), DIMENSION(:), POINTER          :: all_evals
    REAL(dp), DIMENSION(:, :), POINTER       :: spectrum
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_fm_p_type), DIMENSION(:, :), &
      POINTER                                :: dip_fm_set
    TYPE(cp_fm_type), POINTER                :: all_vectors, excvec_coeff, &
                                                fm_work
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(real_matrix_p_type), DIMENSION(:), &
      POINTER                                :: matrix_s, op_sm, ostrength_sm

    failure =.FALSE.
    NULLIFY(logger)
    logger => cp_error_get_logger(error)
    ionode = logger%para_env%mepos==logger%para_env%source
    IF (ionode) THEN
     output_unit= cp_logger_get_default_unit_nr(logger)
    ELSE
     output_unit = -1
    END IF

    NULLIFY(fm_work,ostrength_sm,op_sm, dip_fm_set)
    NULLIFY(all_evals,all_vectors,excvec_coeff, spectrum)
    NULLIFY(cell,dft_control,mos,particle_set,matrix_s)
    ALLOCATE (op_sm(3),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

    CALL get_qs_env(qs_env=qs_env,cell = cell, dft_control=dft_control,&
         mos=mos,particle_set=particle_set,matrix_s=matrix_s,error=error)

    CALL get_xas_env(xas_env=xas_env,all_vectors=all_vectors,&
         all_evals=all_evals,dip_fm_set=dip_fm_set,excvec_coeff=excvec_coeff,&
         fm_work=fm_work, ostrength_sm=ostrength_sm,spectrum=spectrum,error=error)

    CPPrecondition(ASSOCIATED(excvec_coeff),cp_failure_level,routineP,error,failure)

    IF(.NOT. failure) THEN

      IF(.NOT. xas_control%xas_method == xas_dscf) THEN
      ! Calculate the spectrum
        IF(xas_control%dipole_form==xas_dip_len2) THEN
           rc(1:3) = particle_set(iatom)%r(1:3)
           DO i = 1,3
             NULLIFY(op_sm(i)%matrix)
             op_sm(i)%matrix => ostrength_sm(i)%matrix
           END DO
           CALL rRc_xyz_ao(op_sm,qs_env,rc,order=1,minimum_image=.TRUE.,error=error)
           CALL spectrum_dip_vel(dip_fm_set,op_sm,mos,excvec_coeff,&
                all_vectors,all_evals,fm_work,&
                spectrum,dft_control%xas_estate,error=error)
           DO i = 1,SIZE(ostrength_sm,1)
             CALL set_matrix(ostrength_sm(i)%matrix,0.0_dp)
           END DO
        ELSE
           DO i = 1,3
             NULLIFY(op_sm(i)%matrix)
             op_sm(i)%matrix => ostrength_sm(i)%matrix
           END DO
           CALL spectrum_dip_vel(dip_fm_set,op_sm,mos,excvec_coeff,&
                all_vectors,all_evals,fm_work,&
                spectrum,dft_control%xas_estate,error=error)
        END IF
      END IF

      CALL get_mo_set(mos(1)%mo_set, homo=homo)
    ! append the spectrum of this iteration to the right output file
      IF( .NOT. xas_control%xas_method == xas_dscf) THEN
        length = (.NOT. xas_control%dipole_form==xas_dip_vel)
        CALL xas_write(xas_control,spectrum, dft_control%xas_estate, &
             xas_section, homo, iatom, iter, length=length, error=error)
      END IF

      IF(BTEST(cp_print_key_should_output(logger%iter_info,xas_section,&
        "PRINT%CLS_FUNCTION_CUBES",error=error),cp_p_file)) THEN
        CALL xas_print_cubes(xas_control,qs_env,xas_section,mos,all_vectors,iter,&
             iatom,error=error)
      END IF

    END IF  ! failure

    DEALLOCATE (op_sm,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

  END SUBROUTINE cls_calculate_spectrum

! *****************************************************************************
!> \brief write the spectrum for each atom in a different output file
!> \param spectrum temporary variable contaning the spectrum for the actual atom
!> \param xas_rootfname root of the filename where the spectrum is written
!> \param iatom index of the excited atom
!> \param iter iteration of the xas calculation
!> \param ionode logical assigning the i/o node
!> \param error variable to control error logging, stopping,...
!>        see module cp_error_handling
!> \note
!>      the iteration counter is not finilized yet
!> \par History
!>      05.2005 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE xas_write(xas_control, spectrum, estate, xas_section, homo, iatom, iter,&
             length, error)

    TYPE(xas_control_type)                   :: xas_control
    REAL(dp), DIMENSION(:, :), POINTER       :: spectrum
    INTEGER, INTENT(IN)                      :: estate
    TYPE(section_vals_type), POINTER         :: xas_section
    INTEGER, INTENT(IN)                      :: homo, iatom, iter
    LOGICAL, INTENT(IN)                      :: length
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'xas_write', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_string_length)     :: my_act, my_mittle, my_pos
    INTEGER                                  :: istate, istate0, out_sp
    LOGICAL                                  :: failure
    REAL(dp)                                 :: ene2
    TYPE(cp_logger_type), POINTER            :: logger

    NULLIFY(logger)
    logger => cp_error_get_logger(error)
   
    failure = .FALSE.

    my_pos = "APPEND"
    my_act = "WRITE"

    my_mittle = "at"//TRIM(ADJUSTL(cp_to_string(iatom)))
    out_sp = cp_print_key_unit_nr(logger,xas_section,"PRINT%SPECTRUM",&
               extension=".spectrum", file_position=my_pos, file_action=my_act,&
               file_form="FORMATTED", middle_name=TRIM(my_mittle), &
               error=error)

    IF(out_sp>0) THEN
      WRITE(out_sp,'(A,I10)') " Iteration Step ", iter

      IF(length) THEN
        IF(xas_control%emission) THEN
           istate0 = estate
           DO istate = estate,SIZE(spectrum,2)
              ene2 = spectrum(1,istate)*spectrum(1,istate)
              WRITE(out_sp,'(I6,5F16.8)') istate, spectrum(1,istate)*evolt, &
                    spectrum(2,istate)*ene2, spectrum(3,istate)*ene2,&
                    spectrum(4,istate)*ene2, spectrum(5,istate)*ene2
           END DO
        ELSE
           istate0 = homo
           DO istate = 1,SIZE(spectrum,2)
              ene2 = spectrum(1,istate)*spectrum(1,istate)
              WRITE(out_sp,'(I6,5F16.8)') homo+istate, spectrum(1,istate)*evolt, &
                    spectrum(2,istate)*ene2, spectrum(3,istate)*ene2,&
                    spectrum(4,istate)*ene2, spectrum(5,istate)*ene2
           END DO
        END IF
      ELSE
        IF(xas_control%emission) THEN
           istate0 = estate
           DO istate = estate,SIZE(spectrum,2)
              WRITE(out_sp,'(I6,5F16.8)') istate, spectrum(1,istate)*evolt, &
                    spectrum(2,istate), spectrum(3,istate),&
                    spectrum(4,istate), spectrum(5,istate)
           END DO
        ELSE
           istate0 = homo
           DO istate = 1,SIZE(spectrum,2)
              WRITE(out_sp,'(I6,5F16.8)') homo+istate, spectrum(1,istate)*evolt, &
                    spectrum(2,istate), spectrum(3,istate),&
                    spectrum(4,istate), spectrum(5,istate)
           END DO
        END IF
      END IF
    END IF
    CALL cp_print_key_finished_output(out_sp,logger,xas_section,&
                "PRINT%SPECTRUM", error=error)

  END SUBROUTINE xas_write

! *****************************************************************************
!> \brief write the cube files for a set of selected states
!> \param xas_control provide number ant indexes of the states to be printed
!> \param qs_en v
!> \param mos mos from which the states to be printed are extracted
!> \param iter iteration step (e.g. along an md)
!> \param iatom index of the atom that has been excited
!> \param ionod e
!> \par History
!>      08.2005 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE  xas_print_cubes(xas_control,qs_env,xas_section,&
              mos,all_vectors,iter,iatom,error)

    TYPE(xas_control_type)                   :: xas_control
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(section_vals_type), POINTER         :: xas_section
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(cp_fm_type), POINTER                :: all_vectors
    INTEGER, INTENT(IN)                      :: iter, iatom
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'xas_print_cubes', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_string_length)     :: my_mittle
    INTEGER                                  :: homo, istat, istate0, nspins, &
                                                nstates
    LOGICAL                                  :: failure
    REAL(dp), DIMENSION(:, :), POINTER       :: centers
    TYPE(section_vals_type), POINTER         :: print_key

    failure = .FALSE.
    nspins = SIZE(mos)

    print_key => section_vals_get_subs_vals(xas_section,"PRINT%CLS_FUNCTION_CUBES",error=error)
    my_mittle = 'at'//TRIM(ADJUSTL(cp_to_string(iatom)))
    nstates = SIZE(xas_control%list_cubes,1)

    IF(xas_control%do_centers) THEN
    ! one might like to calculate the centers of the xas orbital (without localizing them)
    ELSE
      ALLOCATE(centers(6,nstates),STAT=istat)
      CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
      centers = 0.0_dp
    END IF

    CALL get_mo_set(mos(1)%mo_set, homo=homo)
    istate0 = homo
    IF(xas_control%emission) istate0 = 0

    CALL qs_print_cubes(qs_env,all_vectors,nstates,xas_control%list_cubes,&
         centers,print_key,my_mittle,state0=istate0,error=error)

    DEALLOCATE(centers,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

  END SUBROUTINE xas_print_cubes

! *****************************************************************************
!> \brief Calculation of the spectrum when the dipole approximation
!>      in the length form is used. The position operator is calculated
!>      by the berry phase approach
!> \param fm_set components of the position operator in a full matrix form
!>                already multiplied by the coefficiets
!>                only the terms <C_i Op C_f> are calculated where
!>                C_i are the coefficients of the excited state
!> \param op_sm components of the position operator for the dipole
!>               in a sparse matrix form (cos and sin)
!>               calculated for the basis functions
!> \param mos wavefunctions coefficients
!> \param excvec coefficients of the excited orbital
!> \param fm_work work space
!> \param cell parameters for the simulation cell
!> \param spectrum temporary variable contaning the spectrum for the actual atom
!> \param estate index of the excited state
!> \param error variable to control error logging, stopping,...
!>        see module cp_error_handling
!> \par History
!>      06.2005 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE spectrum_dip_len(fm_set,op_sm,mos,excvec,&
             all_vectors,all_evals,fm_work,cell,spectrum,estate,error)

    TYPE(cp_fm_p_type), DIMENSION(:, :), &
      POINTER                                :: fm_set
    TYPE(real_matrix_p_type), &
      DIMENSION(:, :), POINTER               :: op_sm
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(cp_fm_type), POINTER                :: excvec, all_vectors
    REAL(dp), DIMENSION(:), POINTER          :: all_evals
    TYPE(cp_fm_type), POINTER                :: fm_work
    TYPE(cell_type), POINTER                 :: cell
    REAL(dp), DIMENSION(:, :), POINTER       :: spectrum
    INTEGER, INTENT(IN)                      :: estate
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'spectrum_dip_len', &
      routineP = moduleN//':'//routineN

    COMPLEX(KIND=dp)                         :: z
    INTEGER                                  :: homo, i, istate, j, nao, nmo, &
                                                nvirtual
    LOGICAL                                  :: failure
    REAL(dp)                                 :: ene_f, ene_i, imagpart, &
                                                ra(3), realpart
    REAL(dp), DIMENSION(:), POINTER          :: eigenvalues

    failure = .FALSE.

    CPPrecondition(ASSOCIATED(fm_set),cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(mos),cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(spectrum),cp_failure_level,routineP,error,failure)
    nvirtual = SIZE(spectrum,2)
    NULLIFY(eigenvalues)
    IF(.NOT. failure) THEN
      CALL get_mo_set(mos(1)%mo_set, eigenvalues=eigenvalues,nao=nao, nmo=nmo, homo =homo)
      DO i=1,SIZE(fm_set,2)
        DO j = 1,SIZE(fm_set,1)
           CPPrecondition(ASSOCIATED(fm_set(j,i)%matrix),cp_failure_level,routineP,error,failure)
           CALL cp_fm_set_all(fm_set(j,i)%matrix, 0.0_dp, error=error)
           CALL cp_fm_set_all(fm_work, 0.0_dp, error=error)
           CALL cp_sm_fm_multiply(op_sm(j,i)%matrix,all_vectors,fm_work,ncol=nvirtual,error=error)
           CALL cp_fm_gemm("T","N",1,nvirtual,nao,1.0_dp,excvec,&
                  fm_work,0.0_dp, fm_set(j,i)%matrix,b_first_col=1,error=error)
        END DO
      END DO

      ene_i = eigenvalues(estate)
      DO istate = 1,nvirtual
         ene_f = all_evals(istate)
         DO i = 1,3
           CALL cp_fm_get_element(fm_set(1,i)%matrix,1,istate,realpart)
           CALL cp_fm_get_element(fm_set(2,i)%matrix,1,istate,imagpart)
           z = CMPLX(realpart,imagpart,dp)
           ra(i) = ( cell % hmat ( i, i ) / twopi ) * AIMAG ( LOG ( z ) )
         END DO
         spectrum(1,istate) = ene_f - ene_i
         spectrum(2,istate) = ra(1)*ra(1)
         spectrum(3,istate) = ra(2)*ra(2)
         spectrum(4,istate) = ra(3)*ra(3)
         spectrum(5,istate) = ra(1)*ra(1)+ra(2)*ra(2)+ra(3)*ra(3)
      END DO
    END IF

  END SUBROUTINE spectrum_dip_len

! *****************************************************************************
!> \brief Calculation of the spectrum when the dipole approximation
!>      in the velocity form is used.
!> \param fm_set components of the position operator in a full matrix form
!>                already multiplied by the coefficiets
!>                only the terms <C_i Op C_f> are calculated where
!>                C_i are the coefficients of the excited state
!> \param op_sm components of the position operator for the dipole
!>               in a sparse matrix form (cos and sin)
!>               calculated for the basis functions
!> \param mos wavefunctions coefficients
!> \param excvec coefficients of the excited orbital
!> \param fm_work work space
!> \param spectrum temporary variable contaning the spectrum for the actual atom
!> \param estate index of the excited state
!> \param error variable to control error logging, stopping,...
!>        see module cp_error_handling
!> \par History
!>      06.2005 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE spectrum_dip_vel(fm_set,op_sm,mos,excvec, &
             all_vectors,all_evals,fm_work,spectrum,estate,error)

    TYPE(cp_fm_p_type), DIMENSION(:, :), &
      POINTER                                :: fm_set
    TYPE(real_matrix_p_type), DIMENSION(:), &
      POINTER                                :: op_sm
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(cp_fm_type), POINTER                :: excvec, all_vectors
    REAL(dp), DIMENSION(:), POINTER          :: all_evals
    TYPE(cp_fm_type), POINTER                :: fm_work
    REAL(dp), DIMENSION(:, :), POINTER       :: spectrum
    INTEGER, INTENT(IN)                      :: estate
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'spectrum_dip_vel', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: homo, i, istate, nao, nmo, &
                                                nvirtual
    LOGICAL                                  :: failure
    REAL(dp)                                 :: dip(3), ene_f, ene_i
    REAL(dp), DIMENSION(:), POINTER          :: eigenvalues

    failure = .FALSE.

    CPPrecondition(ASSOCIATED(fm_set),cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(mos),cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(spectrum),cp_failure_level,routineP,error,failure)
    nvirtual = SIZE(spectrum,2)
    NULLIFY(eigenvalues)

    IF(.NOT. failure) THEN
      CALL get_mo_set(mos(1)%mo_set, eigenvalues=eigenvalues,nao=nao, nmo=nmo, homo =homo)

      DO i=1,SIZE(fm_set,2)
         CPPrecondition(ASSOCIATED(fm_set(1,i)%matrix),cp_failure_level,routineP,error,failure)
         CALL cp_fm_set_all(fm_set(1,i)%matrix, 0.0_dp, error=error)
         CALL cp_fm_set_all(fm_work, 0.0_dp, error=error)
         CALL cp_sm_fm_multiply(op_sm(i)%matrix,all_vectors,fm_work,ncol=nvirtual,error=error)
         CALL cp_fm_gemm("T","N",1,nvirtual,nao,1.0_dp,excvec,&
              fm_work,0.0_dp, fm_set(1,i)%matrix,b_first_col=1,error=error)
      END DO

      ene_i = eigenvalues(estate)

      DO istate = 1,nvirtual
         ene_f = all_evals(istate)

         DO i = 1,3
           CALL cp_fm_get_element(fm_set(1,i)%matrix,1,istate,dip(i))
         END DO
         spectrum(1,istate) = ene_f - ene_i
         spectrum(2,istate) = dip(1)*dip(1)
         spectrum(3,istate) = dip(2)*dip(2)
         spectrum(4,istate) = dip(3)*dip(3)
         spectrum(5,istate) = dip(1)*dip(1)+dip(2)*dip(2)+dip(3)*dip(3)

      END DO
    END IF

  END SUBROUTINE spectrum_dip_vel

! *****************************************************************************
  SUBROUTINE calc_stogto_overlap(base_a, base_b, matrix,error)

    TYPE(gto_basis_set_type), POINTER        :: base_a, base_b
    REAL(dp), DIMENSION(:, :), POINTER       :: matrix
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'calc_stogto_overlap', &
      routineP = moduleN//':'//routineN

    INTEGER :: iset, istat, jset, ldai, ldsab, maxcoa, maxcob, maxl, maxla, &
      maxlb, ncoa, ncob, nseta, nsetb, nsgfa, nsgfb, sgfa, sgfb
    INTEGER, DIMENSION(:), POINTER           :: la_max, la_min, lb_max, &
                                                lb_min, npgfa, npgfb, &
                                                nsgfa_set, nsgfb_set
    INTEGER, DIMENSION(:, :), POINTER        :: first_sgfa, first_sgfb
    LOGICAL                                  :: failure
    REAL(dp)                                 :: rab(3)
    REAL(dp), ALLOCATABLE, DIMENSION(:, :)   :: sab, work
    REAL(dp), ALLOCATABLE, &
      DIMENSION(:, :, :)                     :: ai_work
    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: rpgfa, rpgfb, sphi_a, sphi_b, &
                                                zeta, zetb

    failure = .FALSE.

    NULLIFY(la_max,la_min,lb_max,lb_min)
    NULLIFY(npgfa,npgfb,nsgfa_set,nsgfb_set)
    NULLIFY(first_sgfa,first_sgfb)
    NULLIFY(rpgfa, rpgfb, sphi_a, sphi_b, zeta, zetb)

    CALL get_gto_basis_set(gto_basis_set=base_a,nsgf=nsgfa,nsgf_set=nsgfa_set,lmax=la_max,&
                          lmin=la_min,npgf=npgfa,pgf_radius=rpgfa, &
                          sphi=sphi_a,zet=zeta,first_sgf=first_sgfa, &
                          maxco=maxcoa,nset=nseta, maxl=maxla)

    CALL get_gto_basis_set(gto_basis_set=base_b,nsgf=nsgfb,nsgf_set=nsgfb_set, lmax=lb_max,&
                          lmin=lb_min,npgf=npgfb,pgf_radius=rpgfb, &
                          sphi=sphi_b,zet=zetb,first_sgf=first_sgfb, &
                          maxco=maxcob,nset=nsetb,maxl=maxlb)
    rab = 0.0_dp
    ! Initialize and allocate
    matrix = 0.0_dp

    ldsab = MAX(maxcoa,maxcob,nsgfa,nsgfb)
    maxl = MAX(maxla,maxlb)
    ldai = ncoset(maxl)

    ALLOCATE(sab(ldsab,ldsab),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    ALLOCATE(work(ldsab,ldsab),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    ALLOCATE(ai_work(ldai,ldai,1),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

    DO iset=1,nseta

       ncoa = npgfa(iset)*ncoset(la_max(iset))
       sgfa = first_sgfa(1,iset)

       DO jset=1,nsetb

          ncob = npgfb(jset)*ncoset(lb_max(jset))
          sgfb = first_sgfb(1,jset)

          ai_work = 0.0_dp

          CALL overlap(la_max(iset),la_min(iset),npgfa(iset),&
               rpgfa(:,iset),zeta(:,iset),&
               lb_max(jset),lb_min(jset),npgfb(jset),&
               rpgfb(:,jset),zetb(:,jset),rab,0.0_dp,sab,0,.FALSE.,ai_work,ldai)
          CALL dgemm("N","N",ncoa,nsgfb_set(jset),ncob,&
               1.0_dp,sab(1,1),SIZE(sab,1),&
               sphi_b(1,sgfb),SIZE(sphi_b,1),&
               0.0_dp,work(1,1),SIZE(work,1))
          CALL dgemm("T","N",nsgfa_set(iset),nsgfb_set(jset),ncoa,&
               1.0_dp,sphi_a(1,sgfa),SIZE(sphi_a,1),&
               work(1,1),SIZE(work,1),&
               1.0_dp,matrix(sgfa,sgfb), SIZE(matrix,1))

       END DO  ! jset
    END DO  ! iset

    DEALLOCATE(sab,work,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

  END SUBROUTINE calc_stogto_overlap

! *****************************************************************************
!> \brief Starting from a set of mos, determine on which atom are centered
!>      and if they are of the right type (1s,2s ...)
!>      to be used in the specific core level spectrum calculation
!>      The set of states need to be from the core, otherwise the
!>      characterization of the type is not valid, since it assumes that
!>      the orbital is localizad on a specific atom
!>      It is probably reccomandable to run a localization cycle before
!>      proceeding to the assignment of the type
!>      The type is determined by computing the overalp with a
!>      type specific, minimal, STO bais set
!> \par History
!>      03.2006 created [MI]
!> \author MI
! *****************************************************************************
  SUBROUTINE cls_assign_core_states(xas_control,xas_env,localized_wfn_control,qs_env,error)

    TYPE(xas_control_type)                   :: xas_control
    TYPE(xas_environment_type), POINTER      :: xas_env
    TYPE(localized_wfn_control_type), &
      POINTER                                :: localized_wfn_control
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'cls_assign_core_states', &
      routineP = moduleN//':'//routineN

    INTEGER :: homo, i, iat, iatom, ikind, isgf, istat, istate, j, my_kind, &
      nao, natom, nexc_atoms, nexc_search, output_unit
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: first_sgf
    INTEGER, DIMENSION(3)                    :: perd0
    INTEGER, DIMENSION(:), POINTER           :: atom_of_state, &
                                                mykind_of_kind, &
                                                state_of_atom, &
                                                state_of_mytype, type_of_state
    LOGICAL                                  :: failure, ionode
    REAL(dp)                                 :: component, dist, distmin, &
                                                maxocc, ra(3), rac(3), rc(3)
    REAL(dp), DIMENSION(:), POINTER          :: max_overlap, sto_state_overlap
    REAL(dp), DIMENSION(:, :), POINTER       :: centers_wfn
    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: vecbuffer
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_2d_r_p_type), DIMENSION(:), &
      POINTER                                :: stogto_overlap
    TYPE(cp_fm_type), POINTER                :: mo_coeff
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set

    failure = .FALSE.
    NULLIFY(cell,mos,particle_set)
    NULLIFY(atom_of_state,centers_wfn,mykind_of_kind,state_of_atom)
    NULLIFY(stogto_overlap,type_of_state,max_overlap)
    NULLIFY(state_of_mytype,type_of_state,sto_state_overlap)

    NULLIFY(logger)
    logger => cp_error_get_logger(error)
    ionode = logger%para_env%mepos==logger%para_env%source
    IF (ionode) THEN
       output_unit= cp_logger_get_default_unit_nr(logger)
    ELSE
       output_unit = -1
    END IF

    CALL get_qs_env(qs_env=qs_env, cell=cell, mos=mos, particle_set=particle_set,error=error)

    ! The Berry operator can be used only for periodic systems
    ! If an isolated system is used the periodicity is overimposed
    perd0(1:3) = cell%perd(1:3)
    cell%perd(1:3) = 1

    CALL get_mo_set(mos(1)%mo_set, mo_coeff=mo_coeff, maxocc=maxocc, nao=nao, homo=homo)
    nexc_search = xas_control%nexc_search
    nexc_atoms  = xas_control%nexc_atoms

    CALL get_xas_env(xas_env=xas_env,&
         centers_wfn=centers_wfn,atom_of_state=atom_of_state,&
         mykind_of_kind=mykind_of_kind,&
         type_of_state=type_of_state, state_of_atom=state_of_atom,&
         stogto_overlap=stogto_overlap,error=error)

    ! scratch array for the state
    ALLOCATE(vecbuffer(1,nao),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    natom = SIZE(particle_set)

    ALLOCATE (first_sgf(natom),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    CALL get_particle_set(particle_set=particle_set, first_sgf=first_sgf)
    ALLOCATE (sto_state_overlap(nexc_search),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    ALLOCATE (max_overlap(natom),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    max_overlap = 0.0_dp
    ALLOCATE (state_of_mytype(natom),STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    state_of_mytype = 0
    atom_of_state = 0

    DO istate = 1,nexc_search
      centers_wfn(1,istate) =  localized_wfn_control%centers_set(1)%array(1,istate)
      centers_wfn(2,istate) =  localized_wfn_control%centers_set(1)%array(2,istate)
      centers_wfn(3,istate) =  localized_wfn_control%centers_set(1)%array(3,istate)

      ! Assign the state to the closest atom
      distmin = 100.0_dp

      DO iat = 1,nexc_atoms
        iatom = xas_control%exc_atoms(iat)
        ra(1:3) = particle_set(iatom)%r(1:3)
        rc(1:3) = centers_wfn(1:3,istate)
        rac = pbc(ra,rc,cell)
        dist = rac(1)*rac(1) + rac(2)*rac(2) + rac(3)*rac(3)

        IF(dist < distmin) THEN
           atom_of_state(istate) = iatom
           distmin = dist
        END IF
      END DO
      IF(atom_of_state(istate) /= 0) THEN
      !Character of the state
         CALL cp_fm_get_submatrix(mo_coeff,vecbuffer,1,istate,&
              nao,1,transpose=.TRUE.,error=error)

         iatom = atom_of_state(istate)

         NULLIFY(atomic_kind)
         atomic_kind =>  particle_set(iatom)%atomic_kind
         CALL get_atomic_kind(atomic_kind=atomic_kind,&
                kind_number=ikind)

         my_kind = mykind_of_kind(ikind)

         sto_state_overlap(istate) = 0.0_dp
         DO i = 1,SIZE(stogto_overlap(my_kind)%array,1)
           component = 0.0_dp
           DO j = 1,SIZE(stogto_overlap(my_kind)%array,2)
             isgf = first_sgf(iatom) + j - 1
             component = component + stogto_overlap(my_kind)%array(i,j)*vecbuffer(1,isgf)
           END DO
           sto_state_overlap(istate) = sto_state_overlap(istate) + &
                   component * component
         END DO
         IF(sto_state_overlap(istate)>max_overlap(iatom)) THEN
           state_of_mytype(iatom) = istate
           max_overlap(iatom) = sto_state_overlap(istate)
         END IF
      END IF
    END DO  ! istate

  ! In the set of states, assign the index of the state to be excited for iatom
    IF (output_unit>0) THEN
          WRITE (UNIT=output_unit,FMT="(/,T10,A,/)")&
           "List the atoms to be excited and the relative of MOs index "
    END IF
    DO iat = 1,xas_control%nexc_atoms
      iatom = xas_control%exc_atoms(iat)
      state_of_atom(iat) = state_of_mytype(iatom)
      IF (output_unit>0) THEN
         WRITE(UNIT=output_unit,FMT="(T10,A,I6,T32,A,I6)") 'Atom: ',iatom ,&
         "MO index", state_of_atom(iat)
      END IF
      IF(state_of_atom(iat)==0 .OR. state_of_atom(iat) .GT. homo) THEN
        CALL stop_program(routineP,&
        "A wrong state has been selected for excitation, check the Wannier centers")
      END IF
    END DO

    ! Set back the correct periodicity
    cell%perd(1:3) =  perd0(1:3)

    DEALLOCATE(vecbuffer,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    DEALLOCATE (first_sgf,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    DEALLOCATE (sto_state_overlap,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    DEALLOCATE (max_overlap,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
    DEALLOCATE (state_of_mytype,STAT=istat)
    CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

  END SUBROUTINE cls_assign_core_states

END MODULE xas_methods
