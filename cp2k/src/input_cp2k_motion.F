!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2007  CP2K developers group                          !
!-----------------------------------------------------------------------------!

!!****h* cp2k/input_cp2k_motion *
!!
!!   NAME
!!     input_cp2k_motion
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   AUTHOR
!!     teo & fawzi
!!
!!   MODIFICATION HISTORY
!!     10.2005 split input_cp2k into smaller modules [fawzi]
!!
!!   SOURCE
!****************************************************************************
MODULE input_cp2k_motion
  USE cp_output_handling,              ONLY: cp_print_key_section_create
  USE cp_units,                        ONLY: cp_unit_to_cp2k
  USE input_constants
  USE input_cp2k_subsys,               ONLY: create_structure_data
  USE input_keyword_types,             ONLY: keyword_create,&
                                             keyword_release,&
                                             keyword_type
  USE input_section_types,             ONLY: section_add_keyword,&
                                             section_add_subsection,&
                                             section_create,&
                                             section_release,&
                                             section_type
  USE input_val_types,                 ONLY: char_t,&
                                             integer_t,&
                                             real_t
  USE kinds,                           ONLY: dp
  USE string_utilities,                ONLY: s2a
  USE timings,                         ONLY: timeset,&
                                             timestop
#include "cp_common_uses.h"

  IMPLICIT NONE
  PRIVATE

  LOGICAL, PRIVATE, PARAMETER :: debug_this_module=.TRUE.
  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'input_cp2k_motion'

PUBLIC :: create_motion_section,&
          create_band_section

!***
!****************************************************************************
CONTAINS

!!****f* input_cp2k/create_motion_section *
!!
!!   NAME
!!     create_motion_section
!!
!!   FUNCTION
!!     creates the motion section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_motion_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_motion_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection

    failure=.FALSE.
    
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="motion",&
            description="This section defines a set of tool connected with the motion of the nuclei.",&
            n_keywords=1, n_subsections=1, repeats=.FALSE., required=.TRUE.,&
            error=error)

       NULLIFY(subsection, print_key)

       CALL create_geoopt_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_md_section(subsection,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_fe_section(subsection,error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_constraint_section(subsection,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_fp_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)
       
       CALL create_mc_section(subsection, error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)
       
       CALL create_pint_section(subsection, error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_band_section(subsection, error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="print",&
            description="Controls the printing properties during an MD run",&
            n_keywords=0, n_subsections=1, repeats=.TRUE., required=.FALSE.,&
            error=error)
       NULLIFY(keyword)
       CALL cp_print_key_section_create(print_key,"trajectory",&
            description="controls the output of the trajectory",&
            print_level=low_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the trajectory.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)    
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"shell_trajectory",&
            description="controls the output of the trajectory of shells when the shell-model is used ",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the trajectory of shells.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"core_trajectory",&
            description="controls the output of the trajectory of cores when the shell-model is used ",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the trajectory of cores.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"cell",&
            description="controls the output of the simulatin cell",&
            print_level=low_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"velocities",&
            description="controls the output of the velocities",&
            print_level=low_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the velocities.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)    
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"shell_velocities",&
            description="controls the output of the velocities of shells when the shell model is used",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the velocities of shells.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"core_velocities",&
            description="controls the output of the velocities of cores when the shell model is used",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the velocities of cores.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL create_structure_data(print_key, error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)           

       CALL cp_print_key_section_create(print_key,"forces",&
            description="controls the output of the forces",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the forces.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)    
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"shell_forces",&
            description="controls the output of the forces on shells when shell-model is used",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the forces on shells.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)
       CALL cp_print_key_section_create(print_key,"core_forces",&
            description="controls the output of the forces on cores when shell-model is used",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the forces on cores.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)



       CALL cp_print_key_section_create(print_key,"MIXED_ENERGIES",&
            description="controls the output of the energies of the two"//&
                        "regular FORCE_EVALS in the MIXED method"//&
                        "printed is step,time,Etot,E_F1,E_F2,CONS_QNT",&
            print_level=low_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)
  

       CALL cp_print_key_section_create(print_key,"stress",&
            description="controls the output of the stress tensor",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"RESTART",&
            description="Controls the dumping of the restart file during runs."//&
                        "By default keeps a short history of three restarts."//&
                        "See also RESTART_HISTORY", &
            print_level=silent_print_level, common_iter_levels=1, each=(/1/), &
            filename="",error=error)

       CALL keyword_create(keyword, name="BACKUP_COPIES",&
             description="Specifies the maximum index of backup copies.",&
             usage="BACKUP_COPIES {int}",&
             default_i_val=3, error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"RESTART_HISTORY",&
            description="Dumps unique restart files during the run keeping all of them."//&
                        "Most useful if recovery is needed at a later point.",&
            print_level=silent_print_level, common_iter_levels=0, each=(/500/), &
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"TRANSLATION_VECTOR",&
            description="Dumps the traslation vector applied along an MD (if any). Useful"//&
            " for postprocessing of QMMM trajectories in which the QM fragment is continuously"//&
            " centered in the QM box",&
            print_level=high_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)
    END IF

  END SUBROUTINE create_motion_section

!!****f* input_cp2k/create_fe_section *
!!
!!   NAME
!!     create_fe_section
!!
!!   FUNCTION
!!     creates the free energy section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_fe_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_fe_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection

    failure=.FALSE.
    NULLIFY (subsection,keyword,print_key)
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="free_energy",&
            description="Controls the calculation of free energy and free energy derivatives"//&
            " with different possible methods",&
            n_keywords=0, n_subsections=1, repeats=.FALSE., required=.TRUE.,&
            error=error)
       
       CALL keyword_create(keyword, name="METHOD",&
            description="Defines the method to use to compute free energy.",&
            usage="METHOD (METADYN|UI)",&
            enum_c_vals=s2a( "METADYN","UI","AC"),&
            enum_i_vals=(/do_fe_meta,do_fe_ui,do_fe_ac/),&
            enum_desc=s2a("Metadynamics",&
                          "Umbrella Integration",&
                          "Alchemical Change"),&
            default_i_val=do_fe_meta,repeats=.FALSE.,required=.FALSE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL create_metadyn_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_ui_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_ac_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)       

       CALL cp_print_key_section_create(print_key,"free_energy_info",&
            description="Controls the printing of basic and summary information during the"//&
            " Free Energy calculation", &
            print_level=low_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)        

    END IF
  END SUBROUTINE create_fe_section

!!****f* input_cp2k/create_ac_section *
!!
!!   NAME
!!     create_ac_section
!!
!!   FUNCTION
!!     creates the alchemical section for free energy evaluation
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teodoro laino [tlaino] 04.2007
!!
!!*** **********************************************************************
  SUBROUTINE create_ac_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_ac_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    IF (.NOT.failure) THEN
       NULLIFY(keyword)
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="ALCHEMICAL_CHANGE",&
            description="Controls the calculation of delta free energies"//&
            " with the alchemical change method.",&
            n_keywords=0, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       
       CALL keyword_create(keyword, name="PARAMETER",&
            description="Defines the perturbing parameter of the alchemical change tranformation",&
            usage="PARAMETERS k", required=.TRUE., type_of_var=char_t,&
            n_var=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="WEIGHTING_FUNCTION",&
            description="Specifies the weighting function (umbrella potential, part of the mixing function)",&
            usage="WEIGHTING_FUNCTION (E1+E2-LOG(E1/E2))", type_of_var=char_t,&
            n_var=-1, default_c_vals=(/"0"/),error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EPS_CONV",&
            description="Set the relative tolerance for the convergence of the free energy derivative",&
            usage="EPS_CONV <REAL>",&
            default_r_val=1.0E-2_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="NEQUIL_STEPS",&
            description="Set the number of equilibration steps, skipped to compute averages",&
            usage="NEQUIL_STEPS <INTEGER>",&
            default_i_val=0,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF
  END SUBROUTINE create_ac_section

!!****f* input_cp2k/create_ui_section *
!!
!!   NAME
!!     create_ui_section
!!
!!   FUNCTION
!!     creates the umbrella integration section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teodoro laino [tlaino] 01.2007
!!
!!*** **********************************************************************
  SUBROUTINE create_ui_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_ui_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: subsection

    failure=.FALSE.
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="umbrella_integration",&
            description="Controls the calculation of free energy derivatives"//&
            " with the umbrella integration method.",&
            n_keywords=0, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       
       NULLIFY(keyword, subsection)
       CALL keyword_create(keyword, name="EPS_CONV",&
            description="Set the relative tolerance for the convergence of the covariance matrix"//&
            " used to compute the free energy.",&
            usage="EPS_CONV <REAL>",&
            default_r_val=1.0E-2_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL create_uvar_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)       

    END IF
  END SUBROUTINE create_ui_section

!!****f* input_cp2k_subsys/create_constraint_section [1.0] *
!!
!!   NAME
!!     create_constraint_section
!!
!!   FUNCTION
!!     Create the constraint section. This section is useful to impose
!!     constraints
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_constraint_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_constraint_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection

    failure=.FALSE.
    
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="constraint",&
            description="Section specifying information regarding how to impose constraints"// &
            " on the system.",&
            n_keywords=0, n_subsections=2, repeats=.FALSE., required=.TRUE.,&
            error=error)

       NULLIFY(subsection, keyword, print_key)
       !
       ! subsections
       !
       CALL keyword_create(keyword, name="SHAKE",&
            description="Set the tolerance for the shake constraint algorithm.",&
            usage="SHAKE <REAL>",&
            default_r_val=1.0E-6_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="CONSTRAIN_INIT",&
            description="Apply constraints to the initial position and velocities."//&
            " Default is to apply constraints only after the first MD steps.",&
            usage="CONSTRAIN_INIT <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL create_hbonds_section(subsection, error=error)
       CALL restraint_info_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_g3x3_section(subsection, error=error)
       CALL restraint_info_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_g4x6_section(subsection, error=error)
       CALL restraint_info_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_collective_section(subsection, error=error)
       CALL restraint_info_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_fixed_atom_section(subsection, error=error)
       CALL restraint_info_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_f_a_rest_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_clv_rest_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL cp_print_key_section_create(print_key,"constraint_info",&
            description="Prints information about iterative constraints solutions",&
            print_level=high_print_level, filename="__STD_OUT__",error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"lagrange_multipliers",&
            description="Prints out the lagrange multipliers of the specified constraints during an MD.",&
            print_level=high_print_level, filename="",error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)

    END IF

  END SUBROUTINE create_constraint_section
!***************************************************************************

!!****f* input_cp2k_subsys/create_clv_rest_section [1.0] *
!!
!!   NAME
!!     create_clv_rest_section
!!
!!   FUNCTION
!!     Create the restart section for colvar restraints
!!     This section will be only used for restraint restarts. 
!!     Constraints are handled automatically
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Teodoro Laino 08.2006
!!
!!*** **********************************************************************
  SUBROUTINE create_clv_rest_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_clv_rest_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       NULLIFY( keyword)
       CALL section_create(section,name="COLVAR_RESTART",&
            description="Specify restart position only for COLVAR restraints.",&
            n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="The restarting values for COLVAR restraints."//&
            " The order is an internal order. So if you decide to modify these values by hand"//&
            " first think what you're doing!",repeats=.TRUE.,&
            usage="<REAL>", type_of_var=real_t, n_var=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
    END IF

  END SUBROUTINE create_clv_rest_section

!!****f* input_cp2k_subsys/create_f_a_rest_section [1.0] *
!!
!!   NAME
!!     create_f_a_rest_section
!!
!!   FUNCTION
!!     Create the restart section for fixed atoms restraints
!!     This section will be only used for restraint restarts. 
!!     Constraints are handled automatically
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Teodoro Laino 08.2006
!!
!!*** **********************************************************************
  SUBROUTINE create_f_a_rest_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_f_a_rest_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       NULLIFY( keyword)
       CALL section_create(section,name="FIX_ATOM_RESTART",&
            description="Specify restart position only for FIXED_ATOMS restraints.",&
            n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="The restarting position of fixed atoms for restraints."//&
            " The order is an internal order. So if you decide to modify these values by hand"//&
            " first think what you're doing!",repeats=.TRUE.,&
            usage="<REAL> <REAL> <REAL>", type_of_var=real_t, n_var=3, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
    END IF

  END SUBROUTINE create_f_a_rest_section

!!****f* input_cp2k_subsys/restraint_info_section [1.0] *
!!
!!   NAME
!!     restraint_info_section
!!
!!   FUNCTION
!!     Create the restraint info section in the constraint section
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Teodoro Laino 08.2006
!!
!!*** **********************************************************************
  SUBROUTINE restraint_info_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'restraint_info_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: subsection

    failure=.FALSE.
    
    CPPrecondition(ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       NULLIFY(subsection, keyword)
       CALL section_create(subsection,name="RESTRAINT",&
            description="Activate and specify information on restraint instead of constraint",&
            n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)

       CALL keyword_create(keyword, name="K",&
            description="Specifies the force constant for the harmonic restraint",&
            usage="K {real}",&
            type_of_var=real_t, default_r_val=0.0_dp, unit_str="internal_cp2k",error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)       
    END IF

  END SUBROUTINE restraint_info_section

!!****f* input_cp2k_subsys/create_collective_section [1.0] *
!!
!!   NAME
!!     create_collecive_section
!!
!!   FUNCTION
!!     Create the constraint section for collective constraints
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Joost VandeVondele [01.2006]
!!
!!*** **********************************************************************
  SUBROUTINE create_collective_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_collective_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="COLLECTIVE",&
            description="Used to constraint collective (general) degrees of freedom, "//&
            "writing langrangian multipliers to file.",&
            n_subsections=0, repeats=.TRUE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="COLVAR",&
             description="Specifies the index (in input file order) of the type of colvar to constrain.",&
             usage="COLVAR {int}",&
             type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLECULE",&
            description="Specifies the index of the molecule kind (in input file order)"//&
            "on which the constraint will be applied."//&
            " MOLECULE and MOLNAME keyword exclude themself mutually.",&
            usage="MOLECULE {integer}", required=.TRUE., n_var=1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLNAME",&
            description="Specifies the name of the molecule on which the constraint will be applied.",&
            usage="MOLNAME {character}", required=.TRUE., n_var=1, type_of_var=char_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="INTERMOLECULAR",&
            description="Specify if the constraint/restraint is intermolecular.",&
            usage="INTERMOLECULAR <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="TARGET",&
            description="Specifies the target value of the constrained collective"//&
            " variable (units depend on the colvar).",&
            usage="TARGET {real}",&
            type_of_var=real_t, unit_str="internal_cp2k",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_QM",&
            description="Does not apply the constraint to the QM region within a QM/MM calculation",&
            usage="EXCLUDE_QM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_MM",&
            description="Does not apply the constraint to the MM region within a QM/MM calculation",&
            usage="EXCLUDE_MM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF

  END SUBROUTINE create_collective_section

!***************************************************************************
!!****f* input_cp2k_subsys/create_fixed_atom_section [1.0] *
!!
!!   NAME
!!     create_fixed_atom_section
!!
!!   FUNCTION
!!     Create the constraint section that fixes atoms
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_fixed_atom_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_fixed_atom_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="fixed_atoms",&
            description="This section is used to constraint the overall atomic position (X,Y,Z).",&
            n_keywords=3, n_subsections=0, repeats=.TRUE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword)

       ! Integer
       CALL keyword_create(keyword, name="LIST",&
            description="Specifies a list of atoms to freeze.",&
            usage="LIST {integer} {integer} .. {integer}", required=.TRUE.,repeats=.TRUE.,&
            n_var=-1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RANGE",&
            description="Specifies the starting and the ending index of atoms range you wish to freeze.",&
            usage="RANGE {integer} {integer}", required=.TRUE.,repeats=.TRUE.,&
            n_var=2, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLNAME",&
            description="Specifies the name of the molecule to fix",&
            usage="MOLNAME WAT MEOH", required=.TRUE., repeats=.TRUE.,&
            n_var=-1,type_of_var=char_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MM_SUBSYS",&
            variants=(/"PROTEIN"/),&
            description="In a QM/MM run all  MM atoms are fixed according to the argument.",&
            usage="MM_SUBSYS (NONE|ATOMIC|MOLECULAR)",&
            enum_c_vals=s2a( "NONE","ATOMIC","MOLECULAR"),&
            enum_i_vals=(/do_constr_none,do_constr_atomic,do_constr_molec/),&
            enum_desc=s2a("fix nothing",&
                          "only the MM atoms itself",&
                          "the full molecule/residue that contains a MM atom (i.e. some QM atoms might move)"),&
            default_i_val=do_constr_none,repeats=.FALSE.,required=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="QM_SUBSYS",&
            description="In a QM/MM run all QM atoms are fixed according to the argument.",&
            usage="QM_SUBSYS (NONE|ATOMIC|MOLECULAR)",&
            enum_c_vals=s2a( "NONE","ATOMIC","MOLECULAR"),&
            enum_desc=s2a("fix nothing",&
                          "only the QM atoms itself",&
                          "the full molecule/residue that contains a QM atom (i.e. some MM atoms might move)"),&
            enum_i_vals=(/do_constr_none,do_constr_atomic,do_constr_molec/),&
            default_i_val=do_constr_none,repeats=.FALSE.,required=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_QM",&
            description="Does not apply the constraint to the QM region within a QM/MM calculation."//&
            " This keyword is active only together with MOLNAME",&
            usage="EXCLUDE_QM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_MM",&
            description="Does not apply the constraint to the MM region within a QM/MM calculation."//&
            " This keyword is active only together with MOLNAME",&
            usage="EXCLUDE_MM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF

  END SUBROUTINE create_fixed_atom_section

!***************************************************************************
!!****f* input_cp2k_subsys/create_g3x3_section [1.0] *
!!
!!   NAME
!!     create_g3x3_section
!!
!!   FUNCTION
!!     Create the constraint section specialized on g3x3 constraints
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_g3x3_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_g3x3_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="g3x3",&
            description="This section is used to set 3x3 (3 atoms and 3 distances) constraints.",&
            n_keywords=3, n_subsections=0, repeats=.TRUE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword)
       
       ! Integer
       CALL keyword_create(keyword, name="MOLECULE",&
            variants=(/"MOL"/),&
            description="Specifies the molecule kind number on which constraint will be applied."//&
            " MOLECULE and MOLNAME keyword exclude themself mutually.",&
            usage="MOL {integer}", required=.TRUE., n_var=1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLNAME",&
            description="Specifies the name of the molecule on which the constraint will be applied.",&
            usage="MOLNAME {character}", required=.TRUE., n_var=1, type_of_var=char_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="INTERMOLECULAR",&
            description="Specify if the constraint/restraint is intermolecular.",&
            usage="INTERMOLECULAR <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="ATOMS",&
            description="Atoms' index on which apply the constraint", usage="ATOMS 1 3 6",&
            n_var=-1,type_of_var=integer_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       ! Real
       CALL keyword_create(keyword, name="DISTANCES",&
            description="The constrained distances' values.",&
            usage="DISTANCES {real} {real} {real}", type_of_var=real_t,&
            unit_str="internal_cp2k",n_var=-1,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)              

       ! Logical
       CALL keyword_create(keyword, name="EXCLUDE_QM",&
            description="Does not apply the constraint to the QM region within a QM/MM calculation",&
            usage="EXCLUDE_QM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_MM",&
            description="Does not apply the constraint to the MM region within a QM/MM calculation",&
            usage="EXCLUDE_MM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
    END IF

  END SUBROUTINE create_g3x3_section

!***************************************************************************
!!****f* input_cp2k_subsys/create_hbonds_section [1.0] *
!!
!!   NAME
!!     create_hbonds_section
!!
!!   FUNCTION
!!     Create the constraint section specialized on H BONDS constraints
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_hbonds_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_hbonds_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="HBONDS",&
            description="This section is used to set bonds constraints involving Hydrogen atoms",&
            n_keywords=3, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword)
       ! Character
       CALL keyword_create(keyword, name="ATOM_TYPE",&
            description="Defines the atoms' type forming a bond with an hydrogen. If not specified "//&
            " the default bond value of the first molecule is used as constraint target",&
            usage="ATOMS <CHARACTER>",&
            n_var=-1,type_of_var=char_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLECULE",&
            description="Specifies the indexes of the molecule kind (in input file order)"//&
            "on which the constraint will be applied."//&
            " MOLECULE and MOLNAME keyword exclude themself mutually.",&
            usage="MOLECULE {integer} .. {integer} ", required=.TRUE., n_var=-1,&
            type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLNAME",&
            description="Specifies the names of the molecule on which the constraint will be applied.",&
            usage="MOLNAME {character} .. {character} ", required=.TRUE., n_var=-1,&
            type_of_var=char_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_QM",&
            description="Does not shake HBONDS in the QM region within a QM/MM calculation",&
            usage="EXCLUDE_QM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_MM",&
            description="Does not shake HBONDS in the MM region within a QM/MM calculation",&
            usage="EXCLUDE_MM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       ! Real
       CALL keyword_create(keyword, name="TARGETS",&
            description="The constrained distances' values  for the types defines in ATOM_TYPE.",&
            usage="TARGETS {real} {real} {real}", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)              

    END IF

  END SUBROUTINE create_hbonds_section


!***************************************************************************
!!****f* input_cp2k_subsys/create_g4x6_section [1.0] *
!!
!!   NAME
!!     create_g4x6_section
!!
!!   FUNCTION
!!     Create the constraint section specialized on g4x6 constraints
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_g4x6_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_g4x6_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="g4x6",&
            description="This section is used to set 4x6 (4 atoms and 6 distances) constraints.",&
            n_keywords=3, n_subsections=0, repeats=.TRUE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword)
       
       ! Integer
       CALL keyword_create(keyword, name="MOLECULE",&
            variants=(/"MOL"/),&
            description="Specifies the molecule number on which constraint will be applied."//&
            " MOLECULE and MOLNAME keyword exclude themself mutually.",&
            usage="MOL {integer}", required=.TRUE., n_var=1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLNAME",&
            description="Specifies the name of the molecule on which the constraint will be applied.",&
            usage="MOLNAME {character}", required=.TRUE., n_var=1, type_of_var=char_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="INTERMOLECULAR",&
            description="Specify if the constraint/restraint is intermolecular.",&
            usage="INTERMOLECULAR <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="ATOMS",&
            description="Atoms' index on which apply the constraint", usage="ATOMS 1 3 6 4",&
            n_var=4,type_of_var=integer_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       ! Real
       CALL keyword_create(keyword, name="DISTANCES",&
            description="The constrained distances' values.",&
            usage="DISTANCES {real} {real} {real} {real} {real} {real}",&
            type_of_var=real_t, n_var=6,unit_str="internal_cp2k",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)              

       ! Logical
       CALL keyword_create(keyword, name="EXCLUDE_QM",&
            description="Does not apply the constraint to the QM region within a QM/MM calculation",&
            usage="EXCLUDE_QM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="EXCLUDE_MM",&
            description="Does not apply the constraint to the MM region within a QM/MM calculation",&
            usage="EXCLUDE_MM <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
    END IF

  END SUBROUTINE create_g4x6_section

!!****f* input_cp2k/create_mc_section *
!!
!!   NAME
!!     create_mc_section
!!
!!   FUNCTION
!!     creates the Monte Carlo section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_mc_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_mc_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="mc",&
            description="This section sets parameters to set up a MonteCarlo calculation.",&
            n_keywords=1, n_subsections=1, repeats=.FALSE., required=.TRUE.,&
            error=error)
        
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="NSTEP",&
            description="Specifies the number of MC cycles.",&
            usage="NSTEP {integer}",&
            default_i_val=100,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="IPRINT",&
            description="Prints coordinate/cell/etc information every IPRINT steps.",&
            usage="IPRINT {integer}",&
            default_i_val=1,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="NMOVES",&
            description="Specifies the number of classical moves between energy evaluations. ",&
            usage="NMOVES {integer}",&
            default_i_val=4,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="NSWAPMOVES",&
            description="How many insertions to try per swap move.",&
            usage="NSWAPMOVES {integer}",&
            default_i_val=16,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)      

       CALL keyword_create(keyword, name="LBIAS",&
            description="Dictates if we presample moves with a different potential.",&
            usage="LBIAS {logical}",&
            default_l_val=.FALSE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="LSTOP",&
            description="Makes nstep in terms of steps, instead of cycles.",&
            usage="LSTOP {logical}",&
            default_l_val=.FALSE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="LDISCRETE",&
            description="Changes the volume of the box in discrete steps, one side at a time.",&
            usage="LDISCRETE {logical}",&
            default_l_val=.FALSE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RESTART",&
            description="Read initial configuration from restart file.",&
            usage="RESTART {logical}",&
            default_l_val=.FALSE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="IUPVOLUME",&
            description="Every iupvolume steps update maximum volume displacement.",&
            usage="IUPVOLUME {integer}",&
            default_i_val=10000,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="IUPTRANS",&
            description="Every iuptrans steps update maximum translation.",&
            usage="IUPTRANS {integer}",&
            default_i_val=10000,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="NVIRIAL",&
            description="Use this many random orientations to compute the second virial coefficient (ENSEMBLE=VIRIAL)",&
            usage="NVIRIAL {integer}",&
            default_i_val=1000,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="ENSEMBLE",&
            description="Specify the type of simulation",&
            usage="PROGRAM (TRADITIONAL|GEMC_NVT|GEMC_NPT|VIRIAL)",&
            enum_c_vals=s2a( "TRADITIONAL","GEMC_NVT","GEMC_NPT","VIRIAL"),&
            enum_i_vals=(/do_mc_traditional,do_mc_gemc_nvt,do_mc_gemc_npt,do_mc_virial/),&
            default_i_val=do_mc_traditional,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       
       
       CALL keyword_create(keyword, name="RESTART_FILE_NAME",&
            description="Name of the restart file for MC information.",&
            usage="RESTART_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOVES_FILE_NAME",&
            description="The file to print the move statistics to.",&
            usage="MOVES_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MOLECULES_FILE_NAME",&
            description="The file to print the number of molecules to.",&
            usage="MOLECULES_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="COORDINATE_FILE_NAME",&
            description="The file to print the current coordinates to.",&
            usage="COORDINATE_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="ENERGY_FILE_NAME",&
            description="The file to print current energies to.",&
            usage="ENERGY_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="DATA_FILE_NAME",&
            description="The file to print current configurational info to.",&
            usage="DATA_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="CELL_FILE_NAME",&
            description="The file to print current cell length info to.",&
            usage="CELL_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_DISP_FILE_NAME",&
            description="The file to print current maximum displacement info to.",&
            usage="MAX_DISP_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="BOX2_FILE_NAME",&
            description="For GEMC, the name of the input file for the other box.",&
            usage="BOX2_FILE_NAME {filename}",&
            default_lc_val="XXXXXXXX",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PRESSURE",&
            description="The pressure for NpT simulations, in bar.",&
            usage="PRESSURE {real}",&
            type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="TEMPERATURE",&
            description="The temperature of the simulation, in Kelvin.",&
            usage="TEMPERATURE {real}",&
            type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMSWAP",&
            description="The probability of attempting a swap move.",&
            usage="PMSWAP {real}",&
            type_of_var=real_t, default_r_val=0.0E0_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMSWAP_MOL",&
            description="The probability of attempting a molecule swap of a given molecule type.",&
            usage="PMSWAP_MOL {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMVOLUME",&
            description="The probability of attempting a volume move.",&
            usage="PMVOLUME {real}",&
            type_of_var=real_t, default_r_val=0.0E0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMVOL_BOX",&
            description="The probability of attempting a volume move on this box (GEMC_NpT).",&
            usage="PMVOL_BOX {real}",&
            type_of_var=real_t, default_r_val=1.0E0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMROT_MOL",&
            description="The probability of attempting a molecule rotation of a given molecule type.",&
            usage="PMROT_MOL {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMTRAION",&
            description="The probability of attempting a conformational change.",&
            usage="PMTRAION {real}",&
            type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMTRAION_MOL",&
            description="The probability of attempting a conformational change of a given molecule type.",&
            usage="PMTRAION_MOL {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMTRANS",&
            description="The probability of attempting a molecule translation.",&
            usage="PMTRANS {real}",&
            type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMTRANS_MOL",&
            description="The probability of attempting a molecule translation of a given molecule type.",&
            usage="PMTRANS_MOL {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMVOLUME",&
            description="Maximum volume displacement, in angstrom**3.",&
            usage="RMVOLUME {real}",&
            type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="AVBMC_ATOM",&
            description="The target atom for an AVBMC swap move for each molecule type.",&
            usage="AVBMC_ATOM {integer} {integer} ... ",&
            n_var=-1,type_of_var=integer_t,required=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMBOND",&
            description="Maximum bond length displacement, in angstroms, for each molecule type.",&
            usage="RMBOND {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMANGLE",&
            description="Maximum bond angle displacement, in degrees, for each molecule type.",&
            usage="RMANGLE {real} {real} ...",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMDIHEDRAL",&
            description="Maximum dihedral angle distplacement, in degrees, for each molecule type.",&
            usage="RMDIHEDRAL {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMROT",&
            description="Maximum rotational displacement, in degrees, for each molecule type.",&
            usage="RMROT {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMTRANS",&
            description="Maximum translational displacement, in angstroms, for each molecule type.",&
            usage="RMTRANS {real} {real} ...",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="VIRIAL_TEMPS",&
            description="The temperatures you wish to compute the virial coefficient for.  Only used if ensemble=VIRIAL.",&
            usage="VIRIAL_TEMPS {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="AVBMC_RMIN",&
            description="The inner radius for an AVBMC swap move, in angstroms for every molecule type.",&
            usage="AVBMC_RMIN {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="AVBMC_RMAX",&
            description="The outer radius for an AVBMC swap move, in angstroms, for every molecule type.",&
            usage="AVBMC_RMAX {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMAVBMC",&
            description="The probability of attempting an AVBMC swap move.",&
            usage="PMAVBMC {real}",&
            default_r_val=0.0E0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PMAVBMC_MOL",&
            description="The probability of attempting an AVBMC swap move on each molecule type.",&
            usage="PMAVBMC_MOL {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="PBIAS",&
            description="The probability of swapping to an inner region in an AVBMC swap move for each molecule type.",&
            usage="PBIAS {real} {real} ... ",&
            n_var=-1,type_of_var=real_t, required=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="DISCRETE_STEP",&
            description="The size of the discrete volume move step, in angstroms.",&
            usage="DISCRETE_STEP {real}",&
            default_r_val=1.0E0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF

  END SUBROUTINE create_mc_section

!!****f* input_cp2k/create_geoopt_section *
!!
!!   NAME
!!     create_geoopt_section
!!
!!   FUNCTION
!!     creates the geometry optimization section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_geoopt_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_geoopt_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection

    failure=.FALSE.

    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="geoopt",&
            description="This section sets the environment of the geometry optimizer.",&
            n_keywords=1, n_subsections=1, repeats=.FALSE., required=.FALSE.,&
            error=error)

       NULLIFY(keyword)

       CALL keyword_create(keyword, name="OPTIMIZER",&
            variants=(/"MINIMIZER"/),&
            description="Specify which method to use to perform a geometry optimization.",&
            usage="OPTIMIZER {BFGS|LBFGS|CG}",&
            enum_c_vals=s2a( "BFGS","LBFGS","CG"),&
            enum_desc=s2a("Most efficient minimizer, but only for 'small' systems, "//&
                          "as it relies on diagonalization of a full Hessian matrix",&
                          "Limit memory variant of the above, can also be applied to large systems, not as well fine-tuned",&
                          "conjugate gradients, robust minimizer (depending on the line search) also OK for large systems"),&
            enum_i_vals=(/default_bfgs_method_id,default_lbfgs_method_id,default_cg_method_id/),&
            default_i_val=default_bfgs_method_id,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_ITER",&
            description="Specifies the maximum number of geometry optimization steps. "//&
                        "One step might imply several force evaluations.",&
            usage="MAX_ITER {integer}",&
            default_i_val=200,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="MAX_H_RANK",&
            description="Maximum rank (and consequently size) of the "//&
            "approximate hessian matrix used by the LBFGS optimizer",&
            usage="MAX_H_RANK {integer}",&
            default_i_val=5,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_F_PER_ITER",&
            description="Maximum number of force evaluations per iteration"// &
            "(used for the line search)",&
            usage="MAX_F_PER_ITER {integer}",&
            default_i_val=3,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="WANTED_PROJ_GRADIENT",&
            description="Requested norm thresold of the gradient multiplied "// &
            "by the approximate hessian",&
            usage="WANTED_PROJ_GRADIENT {real}",&
            default_r_val=1.0E-3_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="WANTED_REL_F_ERROR",&
            description="Requested relative error on the objective function"//&
            "of the optimizer (the energy)",&
            usage="WANTED_REL_F_ERROR {real}",&
            default_r_val=1.0E-5_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_DR",&
            description="Tolerance on the maximum value of the displacement.",&
            usage="MAX_DR {real}",&
            default_r_val=0.0030_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_FORCE",&
            description="Tolerance on the maximum value of Forces.",&
            usage="MAX_FORCE {real}",&
            default_r_val=0.00045_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMS_DR",&
            description="Tolerance on RMS displacements.",&
            usage="RMS_DR {real}",&
            default_r_val=0.0015_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMS_FORCE",&
            description="Tolerance on RMS Forces.",&
            usage="RMS_FORCE {real}",&
            default_r_val=0.00030_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error) 

       CALL keyword_create(keyword, name="BRENT_TOL",&
            description="Tolerance requested during Brent line search in Conjugate Gradients Optimization.",&
            usage="BRENT_TOL {real}",&
            default_r_val=0.01_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="INITIAL_STEP",&
            description="Initial step size used, e.g. for bracketing or minimizers. "//&
                        "Might need to be reduced for systems with close contacts",&
            usage="INITIAL_STEP {real}",&
            default_r_val=0.2_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="BRACK_LIMIT",&
            description="Limit in 1D bracketing during line search in Conjugate Gradients Optimization.",&
            usage="BRACK_LIMIT {real}",&
            default_r_val=100.0_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="BRENT_MAX_ITER",&
            description="Maximum number of iterations in brent algorithm "// &
            "(used for the line search in Conjugated Gradients Optimization)",&
            usage="BRENT_MAX_ITER {integer}",&
            default_i_val=100,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="MAX_STEEP_STEPS",&
            description="Maximum number of steepest descent steps before starting the"//&
            " conjugate gradients optimization.",&
            usage="MAX_STEEP_STEPS {integer}",&
            default_i_val=0,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="CG_RESTART_LIMIT",&
            description="Cosine of the angle between two consecutive searching directions."//&
            " If the angle during a CG optimization is less than the one corresponding to "//&
            " to the CG_RESTART_LIMIT the CG is reset and one step of steepest descent is "//&
            " performed.",&
            usage="CG_RESTART_LIMIT {real}",&
            default_r_val=0.1_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="USE_FIT_LINE_SEARCH",&
            description="Use instead of bracketing the minima and than applying the Brent"//&
            " algorithm, a least mean square to interpolate the minima in the line search.",&
            usage="USE_FIT_LINE_SEARCH",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RESTART",&
            description="The guess starting HESSIAN is restarted from the file HESSIAN (only for BFGS)",&
            usage="RESTART",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="FLETCHER_REEVES",&
            description="Uses FLETCHER-REEVES instead of POLAK-RIBIERE when using Conjugate Gradients",&
            usage="FLETCHER-REEVES",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       NULLIFY(subsection)
       CALL section_create(subsection,name="print",&
            description="Controls the printing properties during a geometry optimization run",&
            n_keywords=0, n_subsections=1, repeats=.TRUE., required=.FALSE.,&
            error=error)
       NULLIFY(print_key)
       CALL cp_print_key_section_create(print_key,"program_run_info",&
            description="Controls the printing of basic information during the Geometry Optimization", &
            print_level=low_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)        
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)    

    END IF

  END SUBROUTINE create_geoopt_section

!!****f* input_cp2k/create_metadyn_section *
!!
!!   NAME
!!     create_metadyn_section
!!
!!   FUNCTION
!!     creates the metadynamics section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_metadyn_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_metadyn_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection

    failure=.FALSE.
    
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="metadyn",&
            description="This section sets parameters to set up a calculation of metadynamics.",&
            n_keywords=1, n_subsections=1, repeats=.FALSE., required=.TRUE.,&
            error=error)
        
       NULLIFY(subsection,keyword,print_key)

       CALL keyword_create(keyword, name="NT_HILLS",&
            description="Specify the number the interval of time step to spawn the hills.",&
            usage="NT_HILLS {integer}",&
            default_i_val=30,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="TEMPERATURE",&
            description="If a Lagrangian scheme is used the temperature for the collective "//&
            "variables is specified. ",&
            usage="TEMPERATURE {real}",&
            default_r_val=0.0_dp,unit_str='K',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="TEMP_TOL",&
            description="If a Lagrangian scheme is used the temperature tolerance for the collective "//&
            "variables is specified. ",&
            usage="TEMP_TOL {real}",&
            type_of_var=real_t,unit_str='K',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="WW",&
            description="Specifies the height of the gaussian to spawn. Default 0.1 .",&
            usage="WW {real}",&
            default_r_val=0.1_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="DO_HILLS",&
            description="This keyword enables the spawning of the hills. Default .FALSE.",&
            usage="DO_HILLS",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="LAGRANGE",&
            description="Specifies whether an extended-lagrangian should be used. Default .FALSE.",&
            usage="LAGRANGE",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword=keyword,name="step_start_val",&
             description="The starting step value for metadynamics",&
             usage="step_start_val <integer>",&
             default_i_val=0,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword=keyword,name="nhills_start_val",&
             description="The starting value od previously spawned hills",&
             usage="nhills_start_val <integer>",&
             default_i_val=0,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL create_metavar_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="print",&
            description="Controls the printing properties during an metadynamics run",&
            n_keywords=0, n_subsections=1, repeats=.TRUE., required=.FALSE.,&
            error=error)
       NULLIFY(print_key)
       CALL cp_print_key_section_create(print_key,"program_run_info",&
            description="Controls the printing of basic and summary information during"//&
            " metadynamics.", &
            print_level=low_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"COLVAR",&
            description="Controls the printing of COLVAR summary information during"//&
            " metadynamics. The files contains: colvar value of the extended lagrangian, "//&
            " instantaneous colvar value, force due to the armonic term of the extended "//&
            " lagrangian and the force due to the previously spawned hills.", &
            print_level=high_print_level,each=(/1/),add_last=(/1/),filename="COLVAR",&
            error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"HILLS",&
            description="Controls the printing of HILLS summary information during"//&
            " metadynamics. The file contains: instantaneous colvar value, width of "//&
            " the spawned gaussian and height of the gaussian. According the value of "//&
            " the EACH keyword this file may not be synchronized with the COLVAR file.", &
            print_level=high_print_level,each=(/1/),add_last=(/1/),filename="HILLS",&
            error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_metadyn_history(subsection, section, error)

    END IF
  END SUBROUTINE create_metadyn_section

!!****f* input_cp2k/create_fp_section *
!!
!!   NAME
!!     create_fp_section
!!
!!   FUNCTION
!!     creates the flexible_partitioning section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Joost VandeVondele [04.2006]
!!
!!*** **********************************************************************
  SUBROUTINE create_fp_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_fp_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key

    failure=.FALSE.
    
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="FLEXIBLE_PARTITIONING",&
            description="This section sets up flexible_partitioning",&
            n_keywords=1, n_subsections=1, repeats=.FALSE., required=.TRUE.,&
            error=error)
        
       NULLIFY(keyword,print_key)

       CALL keyword_create(keyword, name="CENTRAL_ATOM",&
            description="Specifies the central atom.",&
            usage="CENTRAL_ATOM {integer}", required=.TRUE.,&
            n_var=1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="INNER_ATOMS",&
            description="Specifies the list of atoms that should remain close to the central atom.",&
            usage="INNER_ATOMS {integer} {integer} .. {integer}", required=.TRUE.,&
            n_var=-1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="OUTER_ATOMS",&
            description="Specifies the list of atoms that should remain far from the central atom.",&
            usage="OUTER_ATOMS {integer} {integer} .. {integer}", required=.TRUE.,&
            n_var=-1, type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="INNER_RADIUS",&
            description="radius of the inner wall",&
            usage="INNER_RADIUS {real} ", required=.TRUE., type_of_var=real_t, &
            n_var=1, unit_str="angstrom", error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="OUTER_RADIUS",&
            description="radius of the outer wall",&
            usage="OUTER_RADIUS {real} ", required=.TRUE., type_of_var=real_t, &
            n_var=1, unit_str="angstrom", error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="STRENGTH",&
            description="Sets the force constant of the repulsive harmonic potential",&
            usage="STRENGTH 1.0", default_r_val=1.0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="BIAS",&
            description="If a bias potential counter-acting the weight term should be applied (recommended).",&
            usage="BIAS F", default_l_val=.TRUE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="TEMPERATURE",&
            description="Sets the temperature parameter that is used in the baising potential."//&
                        "It is recommended to use the actual simulation temperature",&
            usage="TEMPERATURE 300", default_r_val=300.0_dp, unit_str='K', error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="SMOOTH_WIDTH",&
            description="Sets the width of the smooth counting function.",&
            usage="SMOOTH_WIDTH 0.2", default_r_val=0.02_dp, unit_str='angstrom', error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL cp_print_key_section_create(print_key,"WEIGHTS",&
            description="Controls the printing of FP info during flexible partitioning simulations.", &
            print_level=silent_print_level,each=(/1/),common_iter_levels=1,&
            filename="FLEXIBLE_PARTIONING", error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"CONTROL",&
            description="Controls the printing of FP info at startup", &
            print_level=silent_print_level,each=(/1/),common_iter_levels=1, &
            filename="__STD_OUT__", error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)

    END IF

  END SUBROUTINE create_fp_section


!***************************************************************************
!!****f* input_cp2k_motion/create_metadyn_history [1.0] *
!!
!!   NAME
!!     create_metadyn_history
!!
!!   FUNCTION
!!     Creates the velocity section
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_metadyn_history(section, metadyn_section, error)
    TYPE(section_type), POINTER              :: section, metadyn_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_metadyn_history', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.

    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="SPAWNED_HILLS_POS",&
            description="The position of the spawned hills during metadynamics."//&
            "Used for RESTART.",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)
       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify the spawned hills",repeats=.TRUE.,&
            usage="<REAL> <REAL> .. <REAL>", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(metadyn_section, section, error=error)
       CALL section_release(section,error=error)

       CALL section_create(section,name="SPAWNED_HILLS_AMPL",&
            description="The amplitude of the spawned hills during metadynamics."//&
            "Used for RESTART.",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)
       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify the spawned hills",repeats=.TRUE.,&
            usage="<REAL> <REAL> .. <REAL>", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(metadyn_section, section, error=error)
       CALL section_release(section,error=error)

       CALL section_create(section,name="SPAWNED_HILLS_HEIGHT",&
            description="The height of the spawned hills during metadynamics."//&
            "Used for RESTART.",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)
       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify the spawned hills",repeats=.TRUE.,&
            usage="<REAL>", type_of_var=real_t, n_var=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(metadyn_section, section, error=error)
       CALL section_release(section,error=error)
       !
       ! Extended Lagrangian
       !
       CALL section_create(section,name="EXT_LAGRANGE_SS0",&
            description="Colvar position within an extended Lagrangian formalism."//&
            "Used for RESTART.",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)
       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specified the positions",repeats=.TRUE.,&
            usage="<REAL>", type_of_var=real_t, n_var=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(metadyn_section, section, error=error)
       CALL section_release(section,error=error)

       CALL section_create(section,name="EXT_LAGRANGE_VVP",&
            description="Colvar velocities within an extended Lagrangian formalism."//&
            "Used for RESTART.",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)
       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specified the velocities",repeats=.TRUE.,&
            usage="<REAL>", type_of_var=real_t, n_var=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(metadyn_section, section, error=error)
       CALL section_release(section,error=error)

    END IF
  END SUBROUTINE create_metadyn_history

!!****f* input_cp2k/create_metavar_section *
!!
!!   NAME
!!     create_metavar_section
!!
!!   FUNCTION
!!     creates the metavar section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_metavar_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_metavar_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="METAVAR",&
            description="This section specify the nature of the collective variables.",&
            n_keywords=1, n_subsections=1, repeats=.TRUE., required=.TRUE.,&
            error=error)
        
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="LAMBDA",&
            description="Specifies the lambda parameter of the collective variable in the"//&
            " extended lagrangian scheme.",&
            usage="LAMBDA {real}",type_of_var=real_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MASS",&
            description="Specifies the mass parameter of the collective variable in the"//&
            " extended lagrangian scheme.",&
            usage="MASS {real}",unit_str='amu',&
            type_of_var=real_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="SCALE",&
            description="Specifies the scale factor for the following collective variable.",&
            usage="SCALE {real}",&
            default_r_val=1.0_dp,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="WALL_PLUS",&
            variants=(/"WALLP"/),&
            description="Activates the reflective wall on the upper limit of the collective variable.",&
            usage="WALL_PLUS {real}",type_of_var=real_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="WALL_MINUS",&
            variants=(/"WALLM"/),&
            description="Activates the reflective wall on the lower limit of the collective variable.",&
            usage="WALL_MINUS {real}",type_of_var=real_t,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="COLVAR",&
            description="Specifies the colvar on which to apply metadynamics.",&
            usage="COLVAR {integer}", type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="SUBSYS",&
            description="Specifies the subsystem to which the colvar belongs. Default 1.",&
            usage="SUBSYS {integer}",&
            default_i_val=1,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       
    
    END IF

  END SUBROUTINE create_metavar_section

!!****f* input_cp2k/create_uvar_section *
!!
!!   NAME
!!     create_uvar_section
!!
!!   FUNCTION
!!     creates the uvar section
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: the section to be created
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_uvar_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_uvar_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.
    
    IF (.NOT.failure) THEN
       CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
       CALL section_create(section,name="UVAR",&
            description="This section specify the nature of the collective variables"//&
            " used in computing the free energy.",&
            n_keywords=1, n_subsections=1, repeats=.TRUE., required=.TRUE.,&
            error=error)
        
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="COLVAR",&
            description="Specifies the colvar used to compute free energy",&
            usage="COLVAR {integer}", type_of_var=integer_t, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="SUBSYS",&
            description="Specifies the subsystem to which the colvar belongs. Default 1.",&
            usage="SUBSYS {integer}",&
            default_i_val=1,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)       
    END IF

  END SUBROUTINE create_uvar_section

!!****f* input_cp2k/create_md_section *
!!
!!   NAME
!!     create_md_section
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the md section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     fawzi
!!
!!*** **********************************************************************
  SUBROUTINE create_md_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_md_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER :: baro_section, coeff_section, nose_section, &
      print_key, shell_section, subsection, uni_section

    failure=.FALSE.

    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="md",&
            description="parameters needed perform an md run",&
            n_keywords=13, n_subsections=6, repeats=.FALSE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword, coeff_section, nose_section, uni_section, baro_section, shell_section, subsection)
       CALL keyword_create(keyword, name="ensemble",&
            description="The ensemble/integrator that you want to use for MD propagation",&
            usage="ensemble nve",&
            default_i_val=nve_ensemble,&
            enum_c_vals=ensemble_name_types,&
            enum_desc=ensemble_name_desc,&
            enum_i_vals=ensemble_name_index,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="steps",&
            description="The number of steps to be performed",&
            usage="steps 100", default_i_val=3,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(&
             keyword=keyword,&
             name="timestep",&
             description="The length of an integration step (in case RESPA the large TIMESTEP)",&
             usage="timestep 1.0",&
             default_r_val=cp_unit_to_cp2k(value=0.5_dp,&
                                           unit_str="fs",&
                                           error=error),&
             unit_str="fs",&
             error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(&
             keyword=keyword,&
             name="step_start_val",&
             description="The starting step value for the MD",&
             usage="step_start_val <integer>",&
             default_i_val=0,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(&
             keyword=keyword,&
             name="time_start_val",&
             description="The starting timer value for the MD",&
             usage="time_start_val <real>",&
             default_r_val=cp_unit_to_cp2k(value=0.0_dp,&
                                           unit_str="fs",&
                                           error=error),&
             unit_str="fs",&
             error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(&
             keyword=keyword,&
             name="temperature",&
             description="The temperature in K used to initialize "//&
                         "the velocities with init and pos restart, "//&
                         "and in the NPT/NVT simulations",&
             usage="temperature 325.0",&
             default_r_val=cp_unit_to_cp2k(value=300.0_dp,&
                                           unit_str="K",&
                                           error=error),&
             unit_str="K",&
             error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="temp_tol",&
            variants=(/"temp_to              ", "temperature_tolerance"/),&
            description="The maximum accepted oscillations of the temperature"//&
            "from the wanted temperature before rescaling the velocites."//&
            "If it is 0 no rescaling is performed", &
            usage="temp_tol 0.0", default_r_val=0.0_dp, unit_str='K', error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="comvel_tol",&
            description="The maximum accepted velocity of the center of mass"//&
            "If it is 0 no subtraction is performed. "//&
            "With Shell-Model, comvel may drift if SUBSYS%TOPOLOGY%NHCOPT /= GLOBAL ", &
            usage="comvel_tol 0.0", default_r_val=0.0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="annealing",&
            description="Specifies the rescaling factor for velocities after the integration"//&
            "scheme used. Automatically enables the annealing procedure.", &
            usage="annealing 0.0", default_r_val=1.0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="gamma",&
            description="Gamma parameter for the Langevin dynamics",&
            usage="gamma 0.001",&
            default_r_val=0.0_dp, unit_str='fs^-1',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="Noisy_Gamma",&
            variants=(/"NoisyGamma"/), &
            description="Imaginary Langevin Friction term for LD with noisy forces.", &
            usage="Noisy_Gamma 0.01", default_r_val=0.0_dp, unit_str='fs^-1', error=error)
       CALL section_add_keyword(section, keyword, error=error)
       CALL keyword_release(keyword, error=error)

       CALL keyword_create(keyword, name="Shadow_Gamma",&
            variants=(/"ShadowGamma"/), &
            description="Shadow Langevin Friction term for LD with noisy forces in order to adjust Noisy_Gamma.", &
            usage="Shadow_Gamma 0.01", default_r_val=0.0_dp, unit_str='fs^-1', error=error)
       CALL section_add_keyword(section, keyword, error=error)
       CALL keyword_release(keyword, error=error)

       CALL keyword_create(keyword, name="pv_ava",&         
            description="Virial availability for force environment",&         
            usage="pv_ava LOGICAL",&         
            default_l_val=.FALSE., lone_keyword_l_val=.TRUE., error=error)         
       CALL section_add_keyword(section,keyword,error=error)         
       CALL keyword_release(keyword,error=error)         
          
       CALL keyword_create(keyword, name="pv_num",&
            description="Indicates that a finite difference scheme is used to compute virial",&
            usage="pv_num LOGICAL",&
            default_l_val=.FALSE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="pv_dia",&
            description="Only calculate diagonal part of numerical virial",&
            usage="pv_dia LOGICAL",&
            default_l_val=.TRUE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)


       CALL create_msst_section(uni_section, error=error)
       CALL section_add_subsection(section, uni_section, error=error)
       CALL section_release(uni_section,error=error)       

       CALL create_barostat_section(baro_section, error=error)
       CALL section_add_subsection(section, baro_section, error=error)
       CALL section_release(baro_section,error=error)

       CALL create_coeff_section(coeff_section, error=error)
       CALL section_add_subsection(section, coeff_section, error=error)
       CALL section_release(coeff_section,error=error)

       CALL create_nose_section(nose_section, error=error)
       CALL section_add_subsection(section, nose_section, error=error)
       CALL section_release(nose_section,error=error)

       CALL create_respa_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_SHELL_section(shell_section, error=error)
       CALL section_add_subsection(section, shell_section, error=error)
       CALL section_release(shell_section,error=error)       
       
       CALL create_reftraj_section(subsection, error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="print",&
            description="Controls the printing properties during an MD run",&
            n_keywords=0, n_subsections=1, repeats=.TRUE., required=.FALSE.,&
            error=error)
       NULLIFY(print_key)
       CALL cp_print_key_section_create(print_key,"energy",&
            description="controls the output the ener file",&
            print_level=low_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)
              
       CALL cp_print_key_section_create(print_key,"SHELL_ENERGY",&
            description="controls the output the shell ener file (only if shell-model)",&
            print_level=medium_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"COEFFICIENTS",&
            description="Controls the printing of coefficients during an MD run.", &
            print_level=medium_print_level,common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"program_run_info",&
            description="Controls the printing of basic and summary information during the"//&
            " Molecular Dynamics", &
            print_level=low_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)        


       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection, error=error)

    END IF
END SUBROUTINE create_md_section

!***************************************************************************
!!****f* input_cp2k/create_respa_section *
!!
!!   NAME
!!     create_respa_section
!!
!!   FUNCTION
!!     Defines parameters for RESPA integration scheme
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the coeff section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************

SUBROUTINE create_respa_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_respa_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  

     CALL section_create(section,name="RESPA",&
          description="Multiple timestep integration based on RESPA (implemented for NVE only)."//&
          " RESPA exploits multiple force_eval."//&
          " In this case the order of the force_eval maps "//&
          " the order of the respa shells from the slowest to the fastest force evaluation."//&
          " If force_evals share the same subsys, it's enough then to specify the "//&
          " subsys in the force_eval corresponding at the first index in the multiple_force_eval list",&
          n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
          error=error)
       
     NULLIFY(keyword)

     CALL keyword_create(keyword, name="FREQUENCY",&
          description="The number of reference MD steps between two RESPA corrections.",&
          usage="FREQUENCY <INTEGER>", default_i_val=5,error=error)
     CALL section_add_keyword(section,keyword,error=error)
     CALL keyword_release(keyword,error=error)    

  END IF
END SUBROUTINE create_respa_section

!***************************************************************************
!!****f* input_cp2k/create_reftraj_section *
!!
!!   NAME
!!     create_reftraj_section
!!
!!   FUNCTION
!!     Defines parameters for REFTRAJ analysis
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the coeff section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************

SUBROUTINE create_reftraj_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_reftraj_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  

     CALL section_create(section,name="REFTRAJ",&
          description="Loads an external trajectory file and performs analysis on the"//&
          " loaded snapshots.",&
          n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
          error=error)
       
     NULLIFY(keyword)

     CALL keyword_create(keyword, name="FILENAME",&
          description="Specify the filename where the trajectory is stored.",repeats=.FALSE.,&
          usage="FILENAME <CHARACTER>", default_lc_val="reftraj.xyz", &
          error=error)
     CALL section_add_keyword(section,keyword,error=error)
     CALL keyword_release(keyword,error=error)

     CALL keyword_create(keyword, name="eval_energy_forces",&
          description="Eval energy and forces during a REFTRAJ run",&
          repeats=.FALSE., default_l_val=.TRUE.,lone_keyword_l_val=.TRUE.,&
          error=error)
     CALL section_add_keyword(section,keyword,error=error)
     CALL keyword_release(keyword,error=error)
     
  END IF
END SUBROUTINE create_reftraj_section

!***************************************************************************
!!****f* input_cp2k/create_msst_section *
!!
!!   NAME
!!     create_msst_section
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the coeff section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************

SUBROUTINE create_msst_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_msst_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  

       CALL section_create(section,name="msst",&
            description="Parameters for Multi-Scale Shock Technique (MSST) "//&
                        "which simulate the effect of a steady planar shock on a unit cell. "//&
                        "Reed et. al. Physical Review Letters 90, 235503 (2003).",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword )
       CALL keyword_create(keyword, name="PRESSURE",&
            description="Initial pressure",&
            usage="PRESSURE real",&
            default_r_val=0._dp, n_var=1, unit_str='bar', error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)            

       CALL keyword_create(keyword, name="ENERGY",&
            description="Initial energy",&
            usage="ENERGY real",&
            default_r_val=0._dp, n_var=1, unit_str='hartree',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)         

       CALL keyword_create(keyword, name="VOLUME",&
            description="Initial volume",&
            usage="VOLUME real",&
            default_r_val=0._dp, n_var=1, unit_str='angstrom^3',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)             

       CALL keyword_create(keyword, name="CMASS",&
            description="Effective cell mass",&
            usage="CMASS real",&
            default_r_val=0._dp, n_var=1,unit_str='au_m',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)             

       CALL keyword_create(keyword, name="VSHOCK",variants=(/"V_SHOCK"/),&
            description="Velocity shock",&
            usage="VSHOCK real",&
            default_r_val=0._dp, n_var=1,unit_str='m/s',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)             

       CALL keyword_create(keyword, name="GAMMA",&
            description="Damping coefficient for cell volume",&
            usage="GAMMA real",&
            unit_str='fs^-1', &
            default_r_val=0.0_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)             

    END IF
  END SUBROUTINE create_msst_section

!***************************************************************************
!!****f* input_cp2k/create_barostat_section *
!!
!!   NAME
!!     create_barostat_section
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the coeff section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************

SUBROUTINE create_barostat_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_barostat_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: sub2section, subsection

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  

       CALL section_create(section,name="barostat",&
            description="Parameters of barostat.",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)

       NULLIFY(keyword,subsection,sub2section)
       CALL keyword_create(keyword, name="PRESSURE",&
            description="Initial pressure",&
            usage="PRESSURE real",&
            default_r_val=0._dp,unit_str='bar',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)      

       CALL keyword_create(keyword, name="TIMECON",&
            description="Barostat time constant",&
            usage="TIMECON real",&
            default_r_val=cp_unit_to_cp2k(1000.0_dp,"fs",error=error),&
            unit_str='fs',error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)        
       
       CALL create_velocity_section(subsection,"BAROSTAT",error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_mass_section(subsection,"BAROSTAT",error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(sub2section,name="NOSE",&
            description="Parameters for restarting of the barostat thermostat",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.FALSE.,&
            error=error)
 
       CALL create_coord_section(subsection,"THERMOSTAT BAROSTAT",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)
       
       CALL create_velocity_section(subsection,"THERMOSTAT BAROSTAT",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_mass_section(subsection,"THERMOSTAT BAROSTAT",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_force_section(subsection,"THERMOSTAT BAROSTAT",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_add_subsection(section,sub2section,error=error)
       CALL section_release(sub2section,error=error)

    END IF
  END SUBROUTINE create_barostat_section

!***************************************************************************
!!****f* input_cp2k/create_coeff_section *
!!
!!   NAME
!!     create_coeff_section
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the coeff section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************

SUBROUTINE create_coeff_section(coeff_section, error)
    TYPE(section_type), POINTER              :: coeff_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_coeff_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: nose_section, subsection

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(coeff_section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  

       CALL section_create(coeff_section,name="kg_coeff",&
            description="coefficent parameters needed to perform a kg-pol md run",&
            n_keywords=5, n_subsections=0, repeats=.FALSE., required=.FALSE.,&
            error=error)
       
       NULLIFY(nose_section, keyword, subsection)
       CALL keyword_create(keyword, name="ensemble",&
            description="md ensemble for KG-POL coefficients", usage="ENSEMBLE NVT", &
            default_i_val=nvt_ensemble,&
            enum_c_vals=(/"nve  ","nvt  "/),&
            enum_i_vals=(/nve_ensemble,nvt_ensemble/),&
            error=error)
       CALL section_add_keyword(coeff_section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="nhcopt",&
            description="global or massive thermostats for KG-POL coefficients", &
            usage="NHCOPT GLOBAL", &
            default_i_val=nhc_global,&
            enum_c_vals=s2a("global","massive"),&
            enum_desc=s2a("just one thermostat for all the coefficents",&
            "each coefficient has its own thermostat"),&
            enum_i_vals=(/nhc_global,nhc_massive/),&
            error=error)
       CALL section_add_keyword(coeff_section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

      CALL section_create(subsection,name="storage",&
            description="Specify information on the setup of the effective masses in KG-POL",&
            n_keywords=2, n_subsections=0, repeats=.FALSE., required=.FALSE.,&
            error=error)       

       CALL keyword_create(keyword, name="type",&
            description="method to store the effective masses for"//&
            "KG-POL coefficients", usage="storage global", &
            default_i_val=dyn_coeff_mass_global,&
            enum_c_vals=s2a("global","kind","atom","coeff"),&
            enum_desc=s2a("just one mass for all the coefficents",&
            "each atomic kind has its own effective mass",&
            "coefficients of each atom have their own effective mass",&
            "each coefficient has its own effective mass"),&
            enum_i_vals=(/dyn_coeff_mass_global,dyn_coeff_mass_kind,&
                          dyn_coeff_mass_atom,dyn_coeff_mass_coeff/),&
            error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="FILENAME",&
            description="Specify the filename where the masses are stored",repeats=.FALSE.,&
            usage="FILENAME <CHARACTER>", default_lc_val="CMASSES", &
            error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL section_add_subsection(coeff_section,subsection,error=error)
       CALL section_release(subsection,error=error)


       CALL keyword_create(&
             keyword=keyword,&
             name="temperature",&
             description="Target temperature for the KG-POL coeffs",&
             default_r_val=cp_unit_to_cp2k(value=1.0_dp,&
                                           unit_str="K",&
                                           error=error),&
             usage="temperature 1.0",&
             unit_str="K",&
             error=error)
       CALL section_add_keyword(coeff_section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="mass",&
            description="mass of the KG-POL coeffs if storage is global",&
            default_r_val=1.0_dp, usage="mass 1.0",unit_str='au_m',&
            error=error)
       CALL section_add_keyword(coeff_section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL section_create(subsection,name="RESTART_INDEX",&
            description="Specify information to restart parameters for KG_COEFF",&
            n_keywords=2, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error) 

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify indexes used to restart calculation",repeats=.TRUE.,&
            usage="<INTEGER> <INTEGER> .. <INTEGER>", type_of_var=integer_t, n_var=-1, error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(coeff_section, subsection, error=error)
       CALL section_release(subsection,error=error)

       CALL create_nose_section(nose_section, error=error)
       CALL section_add_subsection(coeff_section, nose_section, error=error)
       CALL section_release(nose_section,error=error)
       
       CALL create_coord_section(subsection,"KG_COEFF",error=error)
       CALL section_add_subsection(coeff_section,subsection,error=error)
       CALL section_release(subsection,error=error)
       
       CALL create_velocity_section(subsection,"KG_COEFF",error=error)
       CALL section_add_subsection(coeff_section,subsection,error=error)
       CALL section_release(subsection,error=error)

    END IF
  END SUBROUTINE create_coeff_section
!***************************************************************************
!!****f* input_cp2k/create_nose_section *
!!
!!   NAME
!!     create_nose_section
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the ewald section 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     gloria
!!
!!*** **********************************************************************

SUBROUTINE create_nose_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_nose_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: subsection

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  
       CALL section_create(section,name="nose",&
            description="paramameters of the Nose Hoover thermostat chain",&
            required=.TRUE.,error=error)

       NULLIFY(keyword,subsection)
       CALL keyword_create(keyword, name="length",&
            description="length of the NoseHoover chain", usage="length integer", &
            default_i_val=3,&
            error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="Yoshida",&
            description="order of the yoshida integretor usef for the thermostat",&
            usage="Yoshida integer", &
            default_i_val=3,&
            error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="timecon",&
            description="timeconstant of the thermostat chain",&
            usage="timeconstant real", &
            default_r_val=cp_unit_to_cp2k(1000.0_dp,"fs",error=error),&
            unit_str="fs",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="mts", &
            variants=s2a("multiple_time_steps","mult_t_steps"),&
            description="number of multiple timesteps to be used for the NoseHoover chain",&
            usage="mts integer", &
            default_i_val=2,&
            error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
      
       CALL create_coord_section(subsection,"NOSE HOOVER",error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)
       
       CALL create_velocity_section(subsection,"NOSE HOOVER",error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_mass_section(subsection,"NOSE HOOVER",error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_force_section(subsection,"NOSE HOOVER",error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

  END IF

END SUBROUTINE create_nose_section

!***************************************************************************

!***************************************************************************
!!****f* input_cp2k_motion/create_force_section [1.0] *
!!
!!   NAME
!!     create_force_section
!!
!!   FUNCTION
!!     Creates the mass section
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_force_section(section,name,error)
    TYPE(section_type), POINTER              :: section
    CHARACTER(LEN=*), INTENT(IN)             :: name
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_force_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.

    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="force",&
            description="The forces for "//TRIM(name)//" used for restart",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify masses of the system",repeats=.FALSE.,&
            usage="<REAL> <REAL> .. <REAL>", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF
  END SUBROUTINE create_force_section



!***************************************************************************
!!****f* input_cp2k_motion/create_mass_section [1.0] *
!!
!!   NAME
!!     create_mass_section
!!
!!   FUNCTION
!!     Creates the mass section
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_mass_section(section,name,error)
    TYPE(section_type), POINTER              :: section
    CHARACTER(LEN=*), INTENT(IN)             :: name
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_mass_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.

    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="mass",&
            description="The masses for "//TRIM(name)//" used for restart",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify masses of the system",repeats=.FALSE.,&
            usage="<REAL> <REAL> .. <REAL>", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF
  END SUBROUTINE create_mass_section


!***************************************************************************
!!****f* input_cp2k_motion/create_velocity_section [1.0] *
!!
!!   NAME
!!     create_velocity_section
!!
!!   FUNCTION
!!     Creates the velocity section
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_velocity_section(section,name,error)
    TYPE(section_type), POINTER              :: section
    CHARACTER(LEN=*), INTENT(IN)             :: name
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_velocity_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.

    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="velocity",&
            description="The velocities for "//TRIM(name)//" used for restart",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify velocities of the system",repeats=.TRUE.,&
            usage="<REAL> <REAL> .. <REAL>", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF
  END SUBROUTINE create_velocity_section

!***************************************************************************
!!****f* input_cp2k_motion/create_coord_section [1.0] *
!!
!!   NAME
!!     create_coord_section
!!
!!   FUNCTION
!!     Creates the coord section
!!
!!   NOTES
!!     -
!!
!!   ARGUMENTS
!!     - section: the section to create
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************
  SUBROUTINE create_coord_section(section,name,error)
    TYPE(section_type), POINTER              :: section
    CHARACTER(LEN=*), INTENT(IN)             :: name
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_coord_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword

    failure=.FALSE.

    CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL section_create(section,name="coord",&
            description="The positions for "//TRIM(name)//" used for restart",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="_DEFAULT_KEYWORD_",&
            description="Specify positions of the system",repeats=.TRUE.,&
            usage="<REAL> <REAL> .. <REAL>", type_of_var=real_t, n_var=-1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

    END IF
  END SUBROUTINE create_coord_section

!!****f* input_cp2k_motion/create_pint_section *
!!
!!   NAME
!!     create_pint_section
!!
!!   FUNCTION
!!     creates the section for a path integral run
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the pint section
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     fawzi
!!
!!*** **********************************************************************
SUBROUTINE create_pint_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_pint_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection, &
                                                subsubsection

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
       CALL section_create(section,name="pint",&
            description="The section that controls a path integral run",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword)

       CALL keyword_create(keyword, name="p",&
            description="Specify number beads to use",repeats=.FALSE.,&
            default_i_val=3, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="proc_per_replica",&
            description="Specify number of processors to use for each replica",&
            repeats=.FALSE., default_i_val=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="num_steps",&
            description="Specify number of steps to perform",repeats=.FALSE.,&
            default_i_val=3, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="iteration",&
            description="Specify the iteration number from which it should be "//&
            "counted", default_i_val=0, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="Temp",&
            description="The temperature you want to simulate",&
            default_r_val=cp_unit_to_cp2k(300._dp,"K",error=error),&
            unit_str="K", error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="T_tol",variants=(/"temp_to"/),&
            description="threshold for the oscillations of the temperature "//&
            "excedeed which the temperature is rescaled. 0 means no rescaling.",&
            default_r_val=0._dp,unit_str="K", error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="dt",&
            description="timestep (might be subdivised in nrespa subtimesteps",&
            repeats=.FALSE.,&
            default_r_val=cp_unit_to_cp2k(1.0_dp,"fs",error=error),&
            usage="dt 1.0",unit_str="fs",error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="nrespa",&
            description="number of respa steps for the bead for each md step",&
            repeats=.FALSE., default_i_val=5,error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="transformation",&
            description="Specifies the coordinate transformation to use",&
            usage="TRANSFORMATION (NORMAL|STAGE)",&
            default_i_val=transformation_normal,&
            enum_c_vals=transformation_name_types,&
            enum_i_vals=transformation_name_index,&
            error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       NULLIFY(subsection,subsubsection)
       CALL section_create(subsection,name="normalmode",&
            description="The section that controls the normal mode transformation",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       CALL keyword_create(keyword, name="Q_CENTROID",&
            description="Value of the thermostat mass of centroid degree of freedom",&
            repeats=.FALSE., default_r_val=-1.0_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="Q_BEAD",&
            description="Value of the thermostat mass of non-centroid degrees of freedom",&
            repeats=.FALSE., default_r_val=-1.0_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="MODEFACTOR",&
            description="mass scale factor for non-centroid degrees of freedom",&
            repeats=.FALSE., default_r_val=1.0_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="staging",&
            description="The section that controls the staging transformation",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       CALL keyword_create(keyword, name="j",&
            description="Value of the j parameter for the staging transformation",&
            repeats=.FALSE., default_i_val=2,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="Q_END",&
            description="Value of the nose-hoover mass for the endbead (Q_end)",&
            repeats=.FALSE., default_i_val=2,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="nose",&
            description="The section that controls the nose-hoover thermostats",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       CALL keyword_create(keyword, name="nnos",&
            description="length of nose-hoover chain. 0 means no thermostat",&
            repeats=.FALSE., default_i_val=2,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL create_coord_section(subsubsection,"NOSE",error=error)
       CALL section_add_subsection(subsection,subsubsection,error=error)
       CALL section_release(subsubsection,error=error)
       CALL create_velocity_section(subsubsection,"NOSE",error=error)
       CALL section_add_subsection(subsection,subsubsection,error=error)
       CALL section_release(subsubsection,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="beads",&
            description="positions, velocities of the beads",&
            repeats=.FALSE., required=.TRUE., error=error)
       CALL create_coord_section(subsubsection,"BEADS",error=error)
       CALL section_add_subsection(subsection,subsubsection,error=error)
       CALL section_release(subsubsection,error=error)
       CALL create_velocity_section(subsubsection,"BEADS",error=error)
       CALL section_add_subsection(subsection,subsubsection,error=error)
       CALL section_release(subsubsection,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="init",&
            description="initialization if no beads are present",&
            repeats=.FALSE., required=.TRUE., error=error)
       CALL keyword_create(keyword, name="randomize_pos",&
            description="add gaussian noise to the positions of the beads",&
            repeats=.FALSE., default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,&
            error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="centroid_speed",&
            description="adds a speed to the centroid "//&
            "(useful to correct for the averaging out of the speed ov various beads)",&
            repeats=.FALSE., default_l_val=.FALSE., lone_keyword_l_val=.TRUE.,&
            error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_create(subsection,name="print",&
            description="The section that controls the output of a path integral run",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.FALSE.,&
            error=error)

       NULLIFY(print_key)
       CALL cp_print_key_section_create(print_key,"restart",&
            description="Controls how often a restart is written", &
            print_level=low_print_level,each=(/20/),add_last=(/1/),&
            error=error)
       CALL keyword_create(keyword, name="BACKUP_COPIES",&
             description="Specifies the maximum index of backup copies.",&
             usage="BACKUP_COPIES {int}",&
             default_i_val=3, error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)        

       CALL cp_print_key_section_create(print_key,"ener_info",&
            description="Controls how often energy info is written", &
            print_level=low_print_level,each=(/20/),add_last=(/1/),&
            error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)        

       CALL cp_print_key_section_create(print_key,"centroids",&
            description="Controls how often the centroids are written", &
            print_level=low_print_level,each=(/1/),add_last=(/1/),&
            error=error)
       CALL keyword_create(keyword, name="format",&
            description="Specifies the format of the output file for the trajectory.",&
            usage="FORMAT (ATOMIC|XMOL|DCD)",&
            default_i_val=dump_xmol,&
            enum_c_vals=output_name_types,&
            enum_i_vals=output_name_index,&
            error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection,print_key,error=error)
       CALL section_release(print_key,error=error)        
       CALL section_add_subsection(section,subsection,error=error)
       CALL section_release(subsection,error=error)        

    END IF
  END SUBROUTINE create_pint_section
!***************************************************************************

!!****f* input_cp2k_motion/create_band_section *
!!
!!   NAME
!!     create_band_section
!!
!!   FUNCTION
!!     creates the section for a BAND run
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the pint section
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Teodoro Laino 09.2006 [tlaino]
!!
!!*** **********************************************************************
SUBROUTINE create_band_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_band_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: print_key, subsection, &
                                                subsubsection

  failure=.FALSE.  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
       CALL section_create(section,name="band",&
            description="The section that controls a BAND run",&
            n_keywords=1, n_subsections=0, repeats=.FALSE., required=.TRUE.,&
            error=error)
       NULLIFY(keyword, print_key, subsection, subsubsection)

       CALL keyword_create(keyword, name="NPROC_REP",&
            description="Specify the number of processors to be used per replica "//&
            "environment (for parallel runs)",&
            default_i_val=1, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="BAND_TYPE",&
            description="Specifies the type of BAND calculation",&
            usage="BAND_TYPE (B-NEB|IT-NEB|CI-NEB|D-NEB|SM|EB)",&
            default_i_val=do_it_neb,&
            enum_c_vals=(/"B-NEB ",&
                          "IT-NEB",&
                          "CI-NEB",&
                          "D-NEB ",&
                          "SM    ",&
                          "EB    "/),&
            enum_desc=s2a( "Bisection NEB",&
                           "Improved tangent NEB",&
                           "Climbing Image NEB",&
                           "Doubly NEB",&
                           "String Method",&
                           "Elastic Band (Hamiltonian formulation)"),&
            enum_i_vals=(/do_b_neb,do_it_neb,do_ci_neb,do_d_neb,do_sm,do_eb/),&
            error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="NUMBER_OF_REPLICA",&
            description="Specify the number of Replica to use in the BAND",&
            default_i_val=10, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="ROTATE_FRAMES",&
            description="Compute at each BAND step the RMSD and rotate the frames in order"//&
            " to minimize it.",&
            default_l_val=.TRUE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="K_SPRING",&
            variants=(/"K"/),&
            description="Specify the value of the spring constant",&
            default_r_val=0.02_dp, error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       ! Convergence_control
       CALL section_create(subsection,name="CONVERGENCE_CONTROL",&
            description="Setup parameters to control the convergence criteria for BAND",&
            repeats=.FALSE., required=.FALSE., error=error)
       CALL keyword_create(keyword, name="MAX_DR",&
            description="Tolerance on the maximum value of the displacement on the BAND.",&
            usage="MAX_DR {real}",&
            default_r_val=0.0002_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_FORCE",&
            description="Tolerance on the maximum value of Forces on the BAND.",&
            usage="MAX_FORCE {real}",&
            default_r_val=0.00045_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMS_DR",&
            description="Tolerance on RMS displacements on the BAND.",&
            usage="RMS_DR {real}",&
            default_r_val=0.0001_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="RMS_FORCE",&
            description="Tolerance on RMS Forces on the BAND.",&
            usage="RMS_FORCE {real}",&
            default_r_val=0.00030_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       NULLIFY(subsection, subsubsection)
       ! CI-NEB section
       CALL section_create(subsection,name="CI_NEB",&
            description="Controls parameters for CI-NEB type calculation only.",&
            repeats=.FALSE., required=.FALSE., error=error)
       CALL keyword_create(keyword, name="NSTEPS_IT",&
            description="Specify the number of steps of IT-NEB to perform before "//&
            "switching on the CI algorithm",&
            default_i_val=5, error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error) 
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       ! Optimization section
       CALL section_create(subsection,name="optimize_band",&
            description="Specify the optimization method for the band",&
            repeats=.TRUE., required=.TRUE., error=error)
       CALL create_opt_band_section(subsection,error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)     

       ! replica section: to specify coordinates and velocities (possibly) of the
       ! different replica used in the BAND
       CALL section_create(subsection,name="replica",&
            description="Specify coordinates and velocities (possibly) of the replica",&
            repeats=.TRUE., required=.TRUE., error=error)
       CALL keyword_create(keyword, name="COORD_FILE_NAME",&
            description="Name of the xyz file with coordinates (alternative to &COORD section)",&
            usage="COORD_FILE_NAME <CHAR>",&
            default_lc_val="",error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       ! Coordinates and velocities
       CALL create_coord_section(subsubsection,"BAND",error=error)
       CALL section_add_subsection(subsection,subsubsection,error=error)
       CALL section_release(subsubsection,error=error)
       CALL create_velocity_section(subsubsection,"BAND",error=error)
       CALL section_add_subsection(subsection,subsubsection,error=error)
       CALL section_release(subsubsection,error=error)

       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)       

       ! Print key section
       CALL cp_print_key_section_create(print_key,"program_run_info",&
            description="Controls the printing basic info about the BAND run", &
            print_level=medium_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)

       CALL keyword_create(keyword, name="INITIAL_CONFIGURATION_INFO",&
            description="Print information for the setup of the initial configuration.",&
            usage="INITIAL_CONFIGURATION_INFO <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(print_key,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"convergence_info",&
            description="Controls the printing of the convergence criteria during a BAND run", &
            print_level=medium_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)

       CALL cp_print_key_section_create(print_key,"replica_info",&
            description="Controls the printing of each replica info during a BAND run", &
            print_level=medium_print_level,each=(/1/),add_last=(/1/),filename="__STD_OUT__",&
            error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)       

       CALL cp_print_key_section_create(print_key,"ENERGY",&
            description="Controls the printing of the ENER file in a BAND run", &
            print_level=low_print_level, common_iter_levels=1,&
            filename="",error=error)
       CALL section_add_subsection(section,print_key,error=error)
       CALL section_release(print_key,error=error)       

    END IF
  END SUBROUTINE create_band_section
!***************************************************************************
!!****f* input_cp2k_motion/create_opt_band_section *
!!
!!   NAME
!!     create_opt_band_section
!!
!!   FUNCTION
!!     creates the optimization section for a BAND run
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain the pint section
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Teodoro Laino 02.2007 [tlaino]
!!
!!*** **********************************************************************
  SUBROUTINE create_opt_band_section(section,error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_opt_band_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: subsection, subsubsection

    failure=.FALSE.  
    CPPrecondition(ASSOCIATED(section),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       NULLIFY(keyword, subsection, subsubsection)

       CALL keyword_create(keyword, name="OPT_TYPE",&
            description="Specifies the type optimizer used for the band",&
            usage="OPT_TYPE (MD|DIIS)",&
            default_i_val=band_diis_opt,&
            enum_c_vals=(/"MD  ",&
                          "DIIS"/),&
            enum_desc=s2a( "Molecular Dynamics based Optimizer",&
                           "Coupled Steepest Descent / DIIS "),&
            enum_i_vals=(/band_md_opt,band_diis_opt/),&
            error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="OPTIMIZE_END_POINTS",&
            description="Performs also an optimization of the end points of the band.",&
            default_l_val=.FALSE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       ! MD optimization section
       CALL section_create(subsection,name="MD",&
            description="Activate the MD based optimization procedure for BAND",&
            repeats=.FALSE., required=.TRUE., error=error)

       CALL keyword_create(keyword, name="MAX_STEPS",&
            description="Specify the maximum number of MD steps",&
            default_i_val=100, error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(&
            keyword=keyword,&
            name="timestep",&
            description="The length of an integration step",&
            usage="timestep 1.0",&
            default_r_val=cp_unit_to_cp2k(value=0.5_dp,&
            unit_str="fs",&
            error=error),&
            unit_str="fs",&
            error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="TEMPERATURE",&
            description="Specify the initial temperature",&
            default_r_val=cp_unit_to_cp2k(value=0.0_dp,&
            unit_str="K",&
            error=error),&
            unit_str="K",&
            error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       ! Temp_control
       CALL section_create(subsubsection,name="TEMP_CONTROL",&
            description="Setup parameters to control the temperature during a BAND MD run.",&
            repeats=.FALSE., required=.TRUE., error=error)
       CALL keyword_create(keyword, name="TEMPERATURE",&
            description="Specify the target temperature",&
            type_of_var=real_t,unit_str="K",error=error)
       CALL section_add_keyword(subsubsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)     

       CALL keyword_create(keyword, name="TEMP_TOL",&
            description="Specify the tolerance on the temperature for rescaling",&
            default_r_val=cp_unit_to_cp2k(value=0.0_dp,&
            unit_str="K",&
            error=error),&
            unit_str="K",&
            error=error)
       CALL section_add_keyword(subsubsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="TEMP_TOL_STEPS",&
            description="Specify the number of steps to apply a temperature control",&
            default_i_val=0, error=error)
       CALL section_add_keyword(subsubsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection, subsubsection, error=error)
       CALL section_release(subsubsection,error=error)

       ! Vel_control
       CALL section_create(subsubsection,name="VEL_CONTROL",&
            description="Setup parameters to control the velocity during a BAND MD run.",&
            repeats=.FALSE., required=.TRUE., error=error)
       CALL keyword_create(keyword, name="ANNEALING",&
            description="Specify the annealing coefficient",&
            default_r_val=1.0_dp, error=error)
       CALL section_add_keyword(subsubsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="PROJ_VELOCITY_VERLET",&
            description="Uses a Projected Velocity Verlet instead of a normal Velocity Verlet."//&
            " Every time the cosine between velocities and forces is < 0 velocities are"//&
            " zeroed.",&
            usage="PROJ_VELOCITY_VERLET <LOGICAL>",&
            default_l_val=.TRUE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(subsubsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL keyword_create(keyword, name="SD_LIKE",&
            description="Zeros velocity at each MD step emulating a steepest descent like"//&
            "(SD_LIKE) approach",&
            usage="SD_LIKE <LOGICAL>",&
            default_l_val=.FALSE.,lone_keyword_l_val=.TRUE.,error=error)
       CALL section_add_keyword(subsubsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(subsection, subsubsection, error=error)
       CALL section_release(subsubsection,error=error)
       ! End of MD
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)

       ! DIIS optimization section
       CALL section_create(subsection,name="DIIS",&
            description="Activate the DIIS based optimization procedure for BAND",&
            repeats=.FALSE., required=.TRUE., error=error)

       CALL keyword_create(keyword, name="MAX_SD_STEPS",&
            description="Specify the maximum number of SD steps to perform"//&
            " before switching on DIIS (the minimum number will always be equal to N_DIIS).",&
            default_i_val=1, error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_STEPS",&
            description="Specify the maximum number of optimization steps",&
            default_i_val=100, error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="N_DIIS",&
            variants=(/"NDIIS"/),&
            description="Number of history vectors to be used with DIIS",&
            usage="N_DIIS 4",&
            default_i_val=7,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="STEPSIZE",&
            description="Initial stepsize used for the line search, sometimes this parameter"//&
            "can be reduced to stablize DIIS",&
            usage="STEPSIZE <REAL>",&
            default_r_val=1.0_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="MAX_STEPSIZE",&
            description="Maximum stepsize used for the line search, sometimes this parameter"//&
            "can be reduced to stablize the LS for particularly difficult initial geometries",&
            usage="MAX_STEPSIZE <REAL>",&
            default_r_val=2.0_dp,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="NP_LS",&
            description="Number of points used in the line search SD.",&
            usage="NP_LS <INTEGER>",&
            default_i_val=2,error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)       

       CALL keyword_create(keyword, name="NO_LS",&
            description="Does not perform LS during SD. Useful in combination with a proper STEPSIZE"//&
            " for particularly out of equilibrium starting geometries.",&
            default_l_val=.FALSE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="CHECK_DIIS",&
            description="Performes a series of checks on the DIIS solution in order to accept the DIIS step."//&
            " If set to .FALSE. the only check performed is that the angle between the DIIS solution and the"//&
            " reference vector is less than Pi/2. Can be useful if many DIIS steps are rejected.",&
            default_l_val=.TRUE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(subsection,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       CALL section_add_subsection(section, subsection, error=error)
       CALL section_release(subsection,error=error)
    END IF
  END SUBROUTINE create_opt_band_section
  
!***************************************************************************
!!****f* input_cp2k/create_shell_section *
!!
!!   NAME
!!     create_shell_section
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - section: will contain some parameters for the shells dynamics
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     teo
!!
!!*** **********************************************************************

SUBROUTINE create_shell_section(section, error)
    TYPE(section_type), POINTER              :: section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'create_shell_section', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure
    TYPE(keyword_type), POINTER              :: keyword
    TYPE(section_type), POINTER              :: sub2section, subsection

  failure=.FALSE.
  
  CPPrecondition(.NOT.ASSOCIATED(section),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN  

       CALL section_create(section,name="shell",&
            description="Parameters of shell model in adiabatic dynamics.",&
            n_keywords=2, n_subsections=1, repeats=.FALSE., required=.FALSE.,&
            error=error)

       NULLIFY(keyword,subsection,sub2section)

       CALL keyword_create(&
             keyword=keyword,&
             name="temperature",&
             description="The temperature in K used to control "//&
                         "the internal velocities of the core-shell motion ",&
             usage="temperature 5.0",&
             default_r_val=cp_unit_to_cp2k(value=0.0_dp,unit_str="K",error=error),&
             unit_str="K", error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="temp_tol",&
            description="The maximum accepted oscillations of the temperature"//&
            " of the internal core-hell motion from the wanted temperature."//&
            "If it is 0 no rescaling is performed", &
            usage="temp_tol 0.0", default_r_val=0.0_dp, unit_str='K', error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="nose_particle",&   
            description="If nvt or npt, the core and shell velocities are controlled "//&
            "by the same thermostat used for the particle. This might favour heat exchange "//&
            "and additional rescaling of the internal core-shell velocity is needed (TEMP_TOL)",&
            usage="nose_particle LOGICAL",&
            default_l_val=.FALSE., lone_keyword_l_val=.TRUE., error=error)
       CALL section_add_keyword(section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL section_create(sub2section,name="NOSE",&
            description="Parameters for restarting of the core-shell thermostat",&
            n_keywords=3, n_subsections=4, repeats=.FALSE., required=.FALSE.,&
            error=error)

       NULLIFY(keyword,subsection)

       CALL keyword_create(keyword, name="_SECTION_PARAMETERS_",&
            description="controls the activation of core-shell thermostat",&
            usage="&NOSE T",&
            default_l_val=.FALSE.,&
            lone_keyword_l_val=.TRUE.,&
            error=error)
       CALL section_add_keyword(sub2section,keyword,error=error)
       CALL keyword_release(keyword,error=error)
       
       CALL keyword_create(keyword, name="nhcopt",&
            description="global or massive thermostats", usage="NHCOPT GLOBAL", &
            default_i_val=nhc_global,enum_c_vals=s2a("global","massive"),&
            enum_desc=s2a("just one thermostat for all the core-shell pairs",&
            "each core-shell pair has its own thermostat"),&
            enum_i_vals=(/nhc_global,nhc_massive/),error=error)
            
       CALL section_add_keyword(sub2section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="length",&
            description="length of the NoseHoover chain", usage="length integer", &
            default_i_val=3,&
            error=error)
       CALL section_add_keyword(sub2section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="Yoshida",&
            description="order of the yoshida integretor usef for the thermostat",&
            usage="Yoshida integer", &
            default_i_val=3,&
            error=error)
       CALL section_add_keyword(sub2section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="timecon",&
            description="timeconstant of the thermostat chain",&
            usage="timeconstant real", &
            default_r_val=cp_unit_to_cp2k(1000.0_dp,"fs",error=error),&
            unit_str="fs",error=error)
       CALL section_add_keyword(sub2section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

       CALL keyword_create(keyword, name="mts", &
            variants=s2a("multiple_time_steps","mult_t_steps"),&
            description="number of multiple timesteps to be used for the NoseHoover chain",&
            usage="mts integer", &
            default_i_val=2,&
            error=error)
       CALL section_add_keyword(sub2section,keyword,error=error)
       CALL keyword_release(keyword,error=error)

 
       CALL create_coord_section(subsection,"THERMOSTAT SHELL",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)
       
       CALL create_velocity_section(subsection,"THERMOSTAT SHELL",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_mass_section(subsection,"THERMOSTAT SHELL",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL create_force_section(subsection,"THERMOSTAT SHELL",error=error)
       CALL section_add_subsection(sub2section,subsection,error=error)
       CALL section_release(subsection,error=error)

       CALL section_add_subsection(section,sub2section,error=error)
       CALL section_release(sub2section,error=error)

    END IF
  END SUBROUTINE create_shell_section



END MODULE input_cp2k_motion
