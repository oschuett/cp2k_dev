!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2002,2006  CP2K developers group                            !
!-----------------------------------------------------------------------------!
!!****h* cp2k/colvar_methods [1.0] *
!!
!!   NAME
!!     colvar_methods
!!
!!   FUNCTION
!!     defines collective variables s({R}) and the derivative of this variable wrt R
!!     these can then be used in constraints, restraints and metadynamics ...
!!
!!   NOTES
!!     -
!!
!!   AUTHOR
!!     Alessandro Laio,Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     04.2004 created
!!     01.2006 Refactored [Joost VandeVondele]
!!
!!   SOURCE
!****************************************************************************
MODULE colvar_methods
  USE cell_types,                      ONLY: cell_type
  USE colvar_types,                    ONLY: &
       angle_colvar_id, colvar_create, colvar_setup, colvar_type, &
       coord_colvar_id, dist_colvar_id, plane_distance_colvar_id, &
       rotation_colvar_id, torsion_colvar_id
  USE cp_output_handling,              ONLY: cp_print_key_finished_output,&
                                             cp_print_key_unit_nr
  USE cp_subsystem_types,              ONLY: cp_subsys_get,&
                                             cp_subsystem_p_type,&
                                             cp_subsystem_type
  USE force_env_types,                 ONLY: force_env_get,&
                                             force_env_type
  USE global_types,                    ONLY: global_environment_type
  USE input_section_types,             ONLY: section_vals_get,&
                                             section_vals_get_subs_vals,&
                                             section_vals_type,&
                                             section_vals_val_get
  USE kinds,                           ONLY: dp
  USE mathconstants,                   ONLY: pi
  USE particle_list_types,             ONLY: particle_list_type
  USE particle_types,                  ONLY: particle_type
  USE timings,                         ONLY: timeset,&
                                             timestop
#include "cp_common_uses.h"

  IMPLICIT NONE
  PRIVATE

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'colvar_methods'

  PUBLIC :: colvar_read,&
            colvar_eval_glob_f,&
            colvar_eval_mol_f

  !***
  !****************************************************************************
CONTAINS
  !!****f* colvar_methods/colvar_read *
  !!
  !!   NAME
  !!     colvar_read
  !!
  !!   FUNCTION
  !!     reads a colvar from the input
  !!
  !!   NOTES
  !!     -
  !!
  !!   INPUTS
  !!     - colvar: the place where to store what will be read
  !!     - extended_lagrange: if the extended lagrangian formalismus should 
  !!       be used
  !!     - icol: number of the current colvar (repetition in colvar_section)
  !!     - colvar_section: the colvar section
  !!     - error: variable to control error logging, stopping,... 
  !!       see module cp_error_handling 
  !!
  !!   AUTHOR
  !!     teo
  !!
  !!   MODIFICATION HISTORY
  !!     04.2004 created [alessandro laio and fawzi mohamed]
  !!
  !!*** **********************************************************************
  SUBROUTINE colvar_read(colvar, icol, colvar_section, globenv, error)
    TYPE(colvar_type), POINTER               :: colvar
    INTEGER, INTENT(IN)                      :: icol
    TYPE(section_vals_type), POINTER         :: colvar_section
    TYPE(global_environment_type), POINTER   :: globenv
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'colvar_read', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, iatm, iw, kk, stat
    INTEGER, DIMENSION(:), POINTER           :: iatms
    LOGICAL                                  :: failure
    LOGICAL, DIMENSION(6)                    :: my_subsection
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(section_vals_type), POINTER :: angle_section, coordination_section, &
      distance_section, plane_dist_section, rotation_section, torsion_section

    NULLIFY(logger)
    logger => cp_error_get_logger(error)
    CALL timeset(routineN,"I","",handle)

    NULLIFY(iatms)
    failure=.FALSE.

    distance_section     => section_vals_get_subs_vals(colvar_section,"DISTANCE",i_rep_section=icol,error=error)
    angle_section        => section_vals_get_subs_vals(colvar_section,"ANGLE",i_rep_section=icol,error=error)
    torsion_section      => section_vals_get_subs_vals(colvar_section,"TORSION",i_rep_section=icol,error=error)
    coordination_section => section_vals_get_subs_vals(colvar_section,"COORDINATION",i_rep_section=icol,error=error)
    plane_dist_section   => section_vals_get_subs_vals(colvar_section,"DISTANCE_POINT_PLANE",i_rep_section=icol,&
                            error=error)
    rotation_section     => section_vals_get_subs_vals(colvar_section,"BOND_ROTATION",i_rep_section=icol,error=error)

    CALL section_vals_get(distance_section,explicit=my_subsection(1),error=error)
    CALL section_vals_get(angle_section,explicit=my_subsection(2),error=error)
    CALL section_vals_get(torsion_section,explicit=my_subsection(3),error=error)
    CALL section_vals_get(coordination_section,explicit=my_subsection(4),error=error)
    CALL section_vals_get(plane_dist_section,explicit=my_subsection(5),error=error)
    CALL section_vals_get(rotation_section,explicit=my_subsection(6),error=error)
    ! Only one colvar can be present
    CPPostcondition(COUNT(my_subsection) == 1,cp_failure_level,routinep,error,failure)
    CPPostcondition(.NOT.ASSOCIATED(colvar),cp_failure_level,routinep,error,failure)

    IF      (my_subsection(1)) THEN
       ! Distance
       CALL colvar_create(colvar, dist_colvar_id, error)
       CALL section_vals_val_get(distance_section,"ATOMS",i_vals=iatms,error=error)
       colvar%dist_param%i_at = iatms(1)
       colvar%dist_param%j_at = iatms(2)
    ELSE IF (my_subsection(2)) THEN
       ! Angle
       CALL colvar_create(colvar, angle_colvar_id, error)
       CALL section_vals_val_get(angle_section,"ATOMS",i_vals=iatms,error=error)
       colvar%angle_param%i_at_angle = iatms
    ELSE IF (my_subsection(3)) THEN
       ! Torsion
       CALL colvar_create(colvar, torsion_colvar_id, error)
       CALL section_vals_val_get(torsion_section,"ATOMS",i_vals=iatms,error=error)
       colvar%torsion_param%i_at_tors = iatms
       colvar%torsion_param%o0        = 0.0_dp
    ELSE IF (my_subsection(4)) THEN
       ! Coordination
       CALL colvar_create(colvar, coord_colvar_id, error)
       CALL section_vals_val_get(coordination_section,"ATOMS_FROM",i_vals=iatms,error=error)
       colvar%coord_param%n_atoms_from = SIZE(iatms)
       ALLOCATE(colvar%coord_param%i_at_from(SIZE(iatms)),stat=stat)
       CPPostcondition(stat == 0,cp_failure_level,routinep,error,failure)
       colvar%coord_param%i_at_from = iatms
       CALL section_vals_val_get(coordination_section,"ATOMS_TO",i_vals=iatms,error=error)
       colvar%coord_param%n_atoms_to = SIZE(iatms)
       ALLOCATE(colvar%coord_param%i_at_to(SIZE(iatms)),stat=stat)
       CPPostcondition(stat == 0,cp_failure_level,routinep,error,failure)
       colvar%coord_param%i_at_to = iatms       
       CALL section_vals_val_get(coordination_section,"R0",r_val=colvar%coord_param%r_0,error=error)
       CALL section_vals_val_get(coordination_section,"NN",i_val=colvar%coord_param%nncrd,error=error)
       CALL section_vals_val_get(coordination_section,"ND",i_val=colvar%coord_param%ndcrd,error=error)
    ELSE IF (my_subsection(5)) THEN
       ! Distance point from plane
       CALL colvar_create(colvar, plane_distance_colvar_id, error)
       CALL section_vals_val_get(plane_dist_section,"ATOMS_PLANE",i_vals=iatms,error=error)
       CPPostcondition(SIZE(iatms) == 3,cp_failure_level,routinep,error,failure)
       colvar%plane_distance_param%plane = iatms
       CALL section_vals_val_get(plane_dist_section,"ATOM_POINT",i_val=iatm,error=error)
       colvar%plane_distance_param%point = iatm
    ELSE IF (my_subsection(6)) THEN
       ! Rotation colvar of a segment w.r.t. another segment
       CALL colvar_create(colvar, rotation_colvar_id, error)
       CALL section_vals_val_get(rotation_section,"P1_BOND1",i_vals=iatms,error=error)
       ALLOCATE(colvar%rotation_param%i_at1_bond1(SIZE(iatms)),stat=stat)
       CPPostcondition(stat == 0,cp_failure_level,routinep,error,failure)
       colvar%rotation_param%i_at1_bond1 = iatms
       CALL section_vals_val_get(rotation_section,"P2_BOND1",i_vals=iatms,error=error)
       ALLOCATE(colvar%rotation_param%i_at2_bond1(SIZE(iatms)),stat=stat)
       CPPostcondition(stat == 0,cp_failure_level,routinep,error,failure)
       colvar%rotation_param%i_at2_bond1 = iatms
       CALL section_vals_val_get(rotation_section,"P1_BOND2",i_vals=iatms,error=error)
       ALLOCATE(colvar%rotation_param%i_at1_bond2(SIZE(iatms)),stat=stat)
       CPPostcondition(stat == 0,cp_failure_level,routinep,error,failure)
       colvar%rotation_param%i_at1_bond2 = iatms
       CALL section_vals_val_get(rotation_section,"P2_BOND2",i_vals=iatms,error=error)
       ALLOCATE(colvar%rotation_param%i_at2_bond2(SIZE(iatms)),stat=stat)
       CPPostcondition(stat == 0,cp_failure_level,routinep,error,failure)
       colvar%rotation_param%i_at2_bond2 = iatms
    END IF

    CALL colvar_setup(colvar, error)

    iw = cp_print_key_unit_nr(logger,colvar_section,&
         "PRINT%PROGRAM_RUN_INFO",extension=".colvarLog",error=error)
    IF (iw>0) THEN    
       WRITE ( iw, '( A )')'          ----------------------------------------------------------------------'
       SELECT CASE(colvar%type_id)
       CASE(angle_colvar_id)
          WRITE ( iw, '( A,T71,3I5)' )   ' COLVARS| ANGLE          >>> ATOMS:',&
               colvar%angle_param%i_at_angle
       CASE(plane_distance_colvar_id)
          WRITE ( iw, '( A,T61,3I5)' )   ' COLVARS| PLANE DISTANCE    - PLANE  >>> ATOMS:',&
               colvar%plane_distance_param%plane
          WRITE ( iw, '( A,T61,1I5)' )   ' COLVARS| PLANE DISTANCE    - POINT  >>>  ATOM:',&
               colvar%plane_distance_param%point
       CASE(torsion_colvar_id)
          WRITE ( iw, '( A,T61,4I5)' )   ' COLVARS| TORSION       >>> ATOMS:',&
               colvar%torsion_param%i_at_tors
       CASE(dist_colvar_id)
          WRITE ( iw, '( A,T71,2I5)' )   ' COLVARS| BOND          >>> ATOMS:',&
               colvar%dist_param%i_at,colvar%dist_param%j_at
       CASE(coord_colvar_id)
          WRITE ( iw, '( A,T71,I10)' )  (' COLVARS| COORDINATION  >>> FROM ATOM:',&
               colvar%coord_param%i_at_from(kk),&
               kk=1,SIZE(colvar%coord_param%i_at_from))
          WRITE ( iw, '( A,T71,I10)' )  (' COLVARS| COORDINATION  >>>   TO ATOM:',&
               colvar%coord_param%i_at_to(kk),&
               kk=1,SIZE(colvar%coord_param%i_at_to))
          WRITE ( iw, '( A,T71,F10.5)' ) ' COLVARS| R0',colvar%coord_param%r_0
          WRITE ( iw, '( A,T71,I10)' )   ' COLVARS| NN',colvar%coord_param%nncrd
          WRITE ( iw, '( A,T71,I10)' )   ' COLVARS| ND',colvar%coord_param%ndcrd
       CASE(rotation_colvar_id)
           WRITE ( iw, '( A,T71,I10)' )  (' COLVARS| BOND_ROTATION   - POINT 1 LINE 1  >>> ATOMS:',&
               colvar%rotation_param%i_at1_bond1(kk),&
               kk=1,SIZE(colvar%rotation_param%i_at1_bond1))         
           WRITE ( iw, '( A,T71,I10)' )  (' COLVARS| BOND_ROTATION   - POINT 2 LINE 1  >>> ATOMS:',&
               colvar%rotation_param%i_at2_bond1(kk),&
               kk=1,SIZE(colvar%rotation_param%i_at2_bond1))         
           WRITE ( iw, '( A,T71,I10)' )  (' COLVARS| BOND_ROTATION   - POINT 1 LINE 2  >>> ATOMS:',&
               colvar%rotation_param%i_at1_bond2(kk),&
               kk=1,SIZE(colvar%rotation_param%i_at1_bond2))         
           WRITE ( iw, '( A,T71,I10)' )  (' COLVARS| BOND_ROTATION   - POINT 2 LINE 2  >>> ATOMS:',&
               colvar%rotation_param%i_at2_bond2(kk),&
               kk=1,SIZE(colvar%rotation_param%i_at2_bond2))         
       END SELECT
       WRITE ( iw, '( A )')'          ----------------------------------------------------------------------'
    END IF
    CALL cp_print_key_finished_output(iw,logger,colvar_section,&
         "PRINT%PROGRAM_RUN_INFO", error=error)    

    CALL timestop(0.0_dp,handle)
  END SUBROUTINE colvar_read

  !!****f* colvar/colvar_eval_mol_f [1.0] *
  !!
  !!   NAME
  !!     colvar_eval_mol_f
  !!
  !!   FUNCTION
  !!     evaluates the force (dsdr) given and due to the given colvar
  !!     variables in a molecular environment
  !!
  !!   NOTES
  !!     -
  !!
  !!   ARGUMENTS
  !!     - colvar: the collective variable to evaluate
  !!     - error: variable to control error logging, stopping,... 
  !!       see module cp_error_handling 
  !!
  !!   AUTHOR
  !!     Teodoro Laino
  !!
  !!*** **********************************************************************
  SUBROUTINE colvar_eval_mol_f(colvar, cell, particles, pos, error)
    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particles
    REAL(kind=dp), DIMENSION(:, :), &
      INTENT(IN), OPTIONAL                   :: pos
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'colvar_eval_mol_f', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, j
    LOGICAL                                  :: colvar_ok, failure

    failure=.FALSE.

    colvar_ok=ASSOCIATED(colvar)
    CPAssert(colvar_ok,cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       IF (PRESENT(pos)) THEN
          DO i = 1, SIZE(colvar%i_atom)
             j = colvar%i_atom(i)
             particles(j)%r=pos(:,j)
          END DO
       END IF
       SELECT CASE(colvar%type_id)
       CASE (dist_colvar_id)
          CALL dist_colvar(colvar,cell,particles=particles,error=error)
       CASE (coord_colvar_id)
          CALL coord_colvar(colvar,cell,particles=particles, error=error)
       CASE (torsion_colvar_id)
          CALL torsion_colvar(colvar, cell, particles=particles, error=error)
       CASE (angle_colvar_id)
          CALL angle_colvar(colvar, cell, particles=particles, error=error)
       CASE (plane_distance_colvar_id)
          CALL plane_distance_colvar(colvar,cell, particles=particles, error=error)
       CASE (rotation_colvar_id)
          CALL rotation_colvar(colvar,cell, particles=particles, error=error)
       CASE default
          CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
       END SELECT
    END IF

  END SUBROUTINE colvar_eval_mol_f
  !***************************************************************************

  !!****f* colvar/colvar_eval_glob_f [1.0] *
  !!
  !!   NAME
  !!     colvar_eval_glob_f
  !!
  !!   FUNCTION
  !!     evaluates the force (dsdr) given and due to the given colvar
  !!
  !!   NOTES
  !!     -
  !!
  !!   ARGUMENTS
  !!     - colvar: the collective variable to evaluate
  !!     - error: variable to control error logging, stopping,... 
  !!       see module cp_error_handling 
  !!
  !!   AUTHOR
  !!     Alessandro Laio and fawzi
  !!
  !!*** **********************************************************************
  SUBROUTINE colvar_eval_glob_f(isubsys,icolvar,force_env,error)
    INTEGER                                  :: isubsys, icolvar
    TYPE(force_env_type), POINTER            :: force_env
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'colvar_eval_glob_f', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: colvar_ok, failure
    TYPE(cell_type), POINTER                 :: cell
    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cp_subsystem_p_type), &
      DIMENSION(:), POINTER                  :: subsys

    failure=.FALSE.
    NULLIFY(subsys,cell,colvar)
    CALL force_env_get(force_env,subsys=subsys,cell=cell,error=error)
    colvar_ok=ASSOCIATED(subsys(isubsys)%subsys%colvar_p)
    CPAssert(colvar_ok,cp_failure_level,routineP,error,failure)

    IF (.NOT. failure) THEN
       colvar => subsys(isubsys)%subsys%colvar_p(icolvar)%colvar
       SELECT CASE(colvar%type_id)
       CASE (dist_colvar_id)
          CALL dist_colvar(colvar,cell,subsys=subsys(isubsys)%subsys,error=error)
       CASE (coord_colvar_id)
          CALL coord_colvar(colvar,cell,subsys=subsys(isubsys)%subsys, error=error)
       CASE (torsion_colvar_id)
          CALL torsion_colvar(colvar,cell,subsys=subsys(isubsys)%subsys, error=error)
       CASE (angle_colvar_id)
          CALL angle_colvar(colvar,cell,subsys=subsys(isubsys)%subsys, error=error)
       CASE (plane_distance_colvar_id)
          CALL plane_distance_colvar(colvar,cell,subsys=subsys(isubsys)%subsys, error=error)
       CASE (rotation_colvar_id)
          CALL rotation_colvar(colvar,cell,subsys=subsys(isubsys)%subsys, error=error)
       CASE default
          CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
       END SELECT
    END IF
  END SUBROUTINE colvar_eval_glob_f
  !***************************************************************************

  !!****f* colvar/plane_distance_colvar [1.0] *
  !!
  !!   NAME
  !!     plane_distance_colvar
  !!
  !!   FUNCTION
  !!     evaluates the force due (and on) the distance from the plane collective variable
  !!
  !!   NOTES
  !!     -
  !!   AUTHOR
  !!     Teodoro Laino 02.2006 [created]
  !!
  !!*** **********************************************************************
  SUBROUTINE plane_distance_colvar(colvar,cell,subsys,particles,error)

    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_subsystem_type), OPTIONAL, &
      POINTER                                :: subsys
    TYPE(particle_type), DIMENSION(:), &
      OPTIONAL, POINTER                      :: particles
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'plane_distance_colvar', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, j, k, l
    LOGICAL                                  :: failure
    REAL(dp) :: a, b, dsdxpn(3), dxpndxi(3,3), dxpndxj(3,3), dxpndxk(3,3), &
      r12, xpij(3), xpkj(3), xpl(3), xpn(3)
    TYPE(particle_list_type), POINTER        :: particles_i
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: my_particles

    failure=.FALSE.
    NULLIFY(particles_i)

    CPPrecondition(colvar%type_id==plane_distance_colvar_id,cp_failure_level,routineP,error,failure)
    IF (PRESENT(particles)) THEN
       my_particles => particles
    ELSE
       CPPrecondition(PRESENT(subsys),cp_failure_level,routineP,error,failure)
       CALL cp_subsys_get(subsys,particles=particles_i,error=error)
       my_particles => particles_i%els
    END IF

    i=colvar%plane_distance_param%plane(1)
    j=colvar%plane_distance_param%plane(2)
    k=colvar%plane_distance_param%plane(3)
    l=colvar%plane_distance_param%point
    xpij=my_particles(i)%r(1:3)-my_particles(j)%r(1:3)
    xpkj=my_particles(k)%r(1:3)-my_particles(j)%r(1:3)
    xpl =my_particles(l)%r(1:3)-(my_particles(i)%r(1:3)+&
         my_particles(j)%r(1:3)+&
         my_particles(k)%r(1:3))/3.0_dp
    xpn(1)  = xpij(2)*xpkj(3)-xpij(3)*xpkj(2)
    xpn(2)  = xpij(3)*xpkj(1)-xpij(1)*xpkj(3)
    xpn(3)  = xpij(1)*xpkj(2)-xpij(2)*xpkj(1)
    a = DOT_PRODUCT(xpn,xpn)
    b = DOT_PRODUCT(xpl,xpn)
    r12=SQRT(a)
    colvar%ss=b/r12
    dsdxpn(1) = xpl(1)/r12 - b*xpn(1)/(r12*a)
    dsdxpn(2) = xpl(2)/r12 - b*xpn(2)/(r12*a)
    dsdxpn(3) = xpl(3)/r12 - b*xpn(3)/(r12*a)
    !
    dxpndxi(1,1)=  0.0_dp
    dxpndxi(1,2)=  1.0_dp * xpkj(3)
    dxpndxi(1,3)= -1.0_dp * xpkj(2)
    dxpndxi(2,1)= -1.0_dp * xpkj(3)
    dxpndxi(2,2)=  0.0_dp
    dxpndxi(2,3)=  1.0_dp * xpkj(1)
    dxpndxi(3,1)=  1.0_dp * xpkj(2)
    dxpndxi(3,2)= -1.0_dp * xpkj(1)
    dxpndxi(3,3)=  0.0_dp
    !
    dxpndxj(1,1)=  0.0_dp
    dxpndxj(1,2)= -1.0_dp * xpkj(3) + xpij(3)
    dxpndxj(1,3)= -1.0_dp * xpij(2) + xpkj(2)
    dxpndxj(2,1)= -1.0_dp * xpij(3) + xpkj(3)
    dxpndxj(2,2)=  0.0_dp
    dxpndxj(2,3)= -1.0_dp * xpkj(1) + xpij(1)
    dxpndxj(3,1)= -1.0_dp * xpkj(2) + xpij(2)
    dxpndxj(3,2)= -1.0_dp * xpij(1) + xpkj(1)
    dxpndxj(3,3)=  0.0_dp
    !
    dxpndxk(1,1)=  0.0_dp
    dxpndxk(1,2)= -1.0_dp * xpij(3)
    dxpndxk(1,3)=  1.0_dp * xpij(2)
    dxpndxk(2,1)=  1.0_dp * xpij(3)
    dxpndxk(2,2)=  0.0_dp
    dxpndxk(2,3)= -1.0_dp * xpij(1)
    dxpndxk(3,1)= -1.0_dp * xpij(2)
    dxpndxk(3,2)=  1.0_dp * xpij(1)
    dxpndxk(3,3)=  0.0_dp
    !
    colvar%dsdr(:,1)=MATMUL(dsdxpn,dxpndxi)-xpn/(3.0_dp*r12)
    colvar%dsdr(:,2)=MATMUL(dsdxpn,dxpndxj)-xpn/(3.0_dp*r12)
    colvar%dsdr(:,3)=MATMUL(dsdxpn,dxpndxk)-xpn/(3.0_dp*r12)
    colvar%dsdr(:,4)=xpn/r12

  END SUBROUTINE plane_distance_colvar

  !!****f* colvar/rotation_colvar [1.0] *
  !!
  !!   NAME
  !!     rotation_colvar
  !!
  !!   FUNCTION
  !!     evaluates the force due (and on) the distance from the plane collective variable
  !!
  !!   NOTES
  !!     -
  !!   AUTHOR
  !!     Teodoro Laino 02.2006 [created]
  !!
  !!*** **********************************************************************
  SUBROUTINE rotation_colvar(colvar,cell,subsys,particles,error)
    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_subsystem_type), OPTIONAL, &
      POINTER                                :: subsys
    TYPE(particle_type), DIMENSION(:), &
      OPTIONAL, POINTER                      :: particles
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'rotation_colvar', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, idum, ii
    LOGICAL                                  :: failure
    REAL(dp)                                 :: a, b, fmod, t0, t1, t2, t3, &
                                                xdum(3), xij(3), xkj(3)
    REAL(KIND=dp)                            :: dp1b1(3), dp1b2(3), dp2b1(3), &
                                                dp2b2(3), xp1b1(3), xp1b2(3), &
                                                xp2b1(3), xp2b2(3)
    TYPE(particle_list_type), POINTER        :: particles_i
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: my_particles

    failure=.FALSE.
    NULLIFY(particles_i)

    CPPrecondition(colvar%type_id==rotation_colvar_id,cp_failure_level,routineP,error,failure)
    IF (PRESENT(particles)) THEN
       my_particles => particles
    ELSE
       CPPrecondition(PRESENT(subsys),cp_failure_level,routineP,error,failure)
       CALL cp_subsys_get(subsys,particles=particles_i,error=error)
       my_particles => particles_i%els
    END IF

    xp1b1 = 0.0_dp
    DO ii = 1, SIZE(colvar%rotation_param%i_at1_bond1)
       i = colvar%rotation_param%i_at1_bond1(ii)
       xp1b1 = xp1b1 + my_particles(i)%r
    END DO
    xp1b1 = xp1b1/REAL(SIZE(colvar%rotation_param%i_at1_bond1),KIND=dp)

    xp2b1 = 0.0_dp
    DO ii = 1, SIZE(colvar%rotation_param%i_at2_bond1)
       i = colvar%rotation_param%i_at2_bond1(ii)
       xp2b1 = xp2b1 + my_particles(i)%r
    END DO
    xp2b1 = xp2b1/REAL(SIZE(colvar%rotation_param%i_at2_bond1),KIND=dp)

    xp1b2 = 0.0_dp
    DO ii = 1, SIZE(colvar%rotation_param%i_at1_bond2)
       i = colvar%rotation_param%i_at1_bond2(ii)
       xp1b2 = xp1b2 + my_particles(i)%r
    END DO
    xp1b2 = xp1b2/REAL(SIZE(colvar%rotation_param%i_at1_bond2),KIND=dp)

    xp2b2 = 0.0_dp
    DO ii = 1, SIZE(colvar%rotation_param%i_at2_bond2)
       i = colvar%rotation_param%i_at2_bond2(ii)
       xp2b2 = xp2b2 + my_particles(i)%r
    END DO
    xp2b2 = xp2b2/REAL(SIZE(colvar%rotation_param%i_at2_bond2),KIND=dp)

    xij=xp1b1-xp2b1
    xkj=xp1b2-xp2b2
    a = SQRT(DOT_PRODUCT(xij,xij))
    b = SQRT(DOT_PRODUCT(xkj,xkj))
    t0 = 1.0_dp/(a*b)
    t1 = 1.0_dp/(a**3.0_dp*b)
    t2 = 1.0_dp/(a*b**3.0_dp)
    t3 = DOT_PRODUCT(xij,xkj)
    colvar%ss = ACOS(t3*t0)
    IF ((ABS(colvar%ss).LT.0.00001_dp).OR.(ABS(colvar%ss-pi).LT.0.00001_dp)) THEN
       fmod =   0.0_dp
    ELSE
       fmod = - 1.0_dp / SIN(colvar%ss)
    ENDIF
    dp1b1 =  xkj(:)*t0-xij(:)*t1*t3
    dp2b1 = -xkj(:)*t0+xij(:)*t1*t3
    dp1b2 =  xij(:)*t0-xkj(:)*t2*t3
    dp2b2 = -xij(:)*t0+xkj(:)*t2*t3

    idum = 0
    xdum = dp1b1/REAL(SIZE(colvar%rotation_param%i_at1_bond1),KIND=dp)
    DO ii=1, SIZE(colvar%rotation_param%i_at1_bond1)
       idum = idum+1
       colvar%dsdr(:,idum) = xdum
    END DO
    xdum = dp2b1/REAL(SIZE(colvar%rotation_param%i_at2_bond1),KIND=dp)
    DO ii=1, SIZE(colvar%rotation_param%i_at2_bond1)
       idum = idum+1
       colvar%dsdr(:,idum) = xdum
    END DO
    xdum = dp1b2/REAL(SIZE(colvar%rotation_param%i_at1_bond2),KIND=dp)
    DO ii=1, SIZE(colvar%rotation_param%i_at1_bond2)
       idum = idum+1
       colvar%dsdr(:,idum) = xdum
    END DO
    xdum = dp2b2/REAL(SIZE(colvar%rotation_param%i_at2_bond2),KIND=dp)
    DO ii=1, SIZE(colvar%rotation_param%i_at2_bond2)
       idum = idum+1
       colvar%dsdr(:,idum) = xdum
    END DO
    colvar%dsdr = colvar%dsdr * fmod
        
  END SUBROUTINE rotation_colvar

  !!****f* colvar/angle_colvar [1.0] *
  !!
  !!   NAME
  !!     angle_colvar
  !!
  !!   FUNCTION
  !!     evaluates the force due (and on) the distance from the plane collective variable
  !!
  !!   NOTES
  !!     -
  !!   AUTHOR
  !!     Teodoro Laino 02.2006 [created]
  !!
  !!*** **********************************************************************
  SUBROUTINE angle_colvar(colvar,cell,subsys,particles,error)
    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_subsystem_type), OPTIONAL, &
      POINTER                                :: subsys
    TYPE(particle_type), DIMENSION(:), &
      OPTIONAL, POINTER                      :: particles
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'angle_colvar', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, j, k
    LOGICAL                                  :: failure
    REAL(dp)                                 :: a, b, fmod, t0, t1, t2, t3, &
                                                xij(3), xkj(3)
    TYPE(particle_list_type), POINTER        :: particles_i
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: my_particles

    failure=.FALSE.
    NULLIFY(particles_i)

    CPPrecondition(colvar%type_id==angle_colvar_id,cp_failure_level,routineP,error,failure)
    IF (PRESENT(particles)) THEN
       my_particles => particles
    ELSE
       CPPrecondition(PRESENT(subsys),cp_failure_level,routineP,error,failure)
       CALL cp_subsys_get(subsys,particles=particles_i,error=error)
       my_particles => particles_i%els
    END IF

    i=colvar%angle_param%i_at_angle(1)
    j=colvar%angle_param%i_at_angle(2)
    k=colvar%angle_param%i_at_angle(3)
    xij=my_particles(i)%r(1:3)-my_particles(j)%r(1:3)
    xkj=my_particles(k)%r(1:3)-my_particles(j)%r(1:3)
    a = SQRT(DOT_PRODUCT(xij,xij))
    b = SQRT(DOT_PRODUCT(xkj,xkj))
    t0 = 1.0_dp/(a*b)
    t1 = 1.0_dp/(a**3.0_dp*b)
    t2 = 1.0_dp/(a*b**3.0_dp)
    t3 = DOT_PRODUCT(xij,xkj)
    colvar%ss = ACOS(t3*t0)
    IF ((ABS(colvar%ss).LT.0.00001_dp).OR.(ABS(colvar%ss-pi).LT.0.00001_dp)) THEN
       fmod =   0.0_dp
    ELSE
       fmod = - 1.0_dp / SIN(colvar%ss)
    ENDIF
    colvar%dsdr(:,1)= xkj(:)*t0-xij(:)*t1*t3
    colvar%dsdr(:,2)=-xkj(:)*t0+xij(:)*t1*t3-xij(:)*t0+xkj(:)*t2*t3
    colvar%dsdr(:,3)= xij(:)*t0-xkj(:)*t2*t3
    colvar%dsdr = colvar%dsdr * fmod

  END SUBROUTINE angle_colvar

  !!****f* colvar/dist_colvar [1.0] *
  !!
  !!   NAME
  !!     dist_colvar
  !!
  !!   FUNCTION
  !!     evaluates the force due (and on) the distance collective variable
  !!
  !!   NOTES
  !!     -
  !!   AUTHOR
  !!     Alessandro Laio, Fawzi Mohamed
  !!
  !!*** **********************************************************************
  SUBROUTINE dist_colvar(colvar,cell,subsys,particles,error)
    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_subsystem_type), OPTIONAL, &
      POINTER                                :: subsys
    TYPE(particle_type), DIMENSION(:), &
      OPTIONAL, POINTER                      :: particles
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'dist_colvar', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, j
    LOGICAL                                  :: failure
    REAL(dp)                                 :: r12, ss(3), xij(3), xpi(3), &
                                                xpj(3)
    TYPE(particle_list_type), POINTER        :: particles_i
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: my_particles

    failure=.FALSE.
    NULLIFY(particles_i)

    CPPrecondition(colvar%type_id==dist_colvar_id,cp_failure_level,routineP,error,failure)
    IF (PRESENT(particles)) THEN
       my_particles => particles
    ELSE
       CPPrecondition(PRESENT(subsys),cp_failure_level,routineP,error,failure)
       CALL cp_subsys_get(subsys,particles=particles_i,error=error)
       my_particles => particles_i%els
    END IF

    i=colvar%dist_param%i_at
    j=colvar%dist_param%j_at
    xpi=my_particles(i)%r(1:3)
    xpj=my_particles(j)%r(1:3)
    ss=MATMUL(cell%h_inv,xpi-xpj)
    ss=ss-NINT(ss)
    xij=MATMUL(cell%hmat,ss)
    r12=SQRT(xij(1)**2+xij(2)**2+xij(3)**2)
    colvar%ss=r12
    colvar%dsdr(:,1)=xij/r12
    colvar%dsdr(:,2)=-xij/r12

  END SUBROUTINE dist_colvar
  !***************************************************************************

  !!****f* colvar/coord_colvar [1.0] *
  !!
  !!   NAME
  !!     coord_colvar
  !!
  !!   FUNCTION
  !!     evaluates the force due (and on) the coordination collective variable
  !!
  !!   NOTES
  !!
  !!   AUTHOR
  !!     Alessandro Laio, Fawzi Mohamed
  !!
  !!*** **********************************************************************
  SUBROUTINE coord_colvar(colvar,cell,subsys,particles,error)
    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_subsystem_type), OPTIONAL, &
      POINTER                                :: subsys
    TYPE(particle_type), DIMENSION(:), &
      OPTIONAL, POINTER                      :: particles
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'coord_colvar', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, ii, jj, n_atoms_from, &
                                                n_atoms_to, ndcrd, nncrd
    LOGICAL                                  :: failure
    REAL(dp)                                 :: dfunc, func, invden, ncoord, &
                                                num, r12, r_0, rdist, ss(3), &
                                                xij(3)
    REAL(dp), DIMENSION(3)                   :: xpi, xpj
    TYPE(particle_list_type), POINTER        :: particles_i
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: my_particles

    failure=.FALSE.
    n_atoms_to=colvar%coord_param%n_atoms_to
    n_atoms_from=colvar%coord_param%n_atoms_from
    nncrd=colvar%coord_param%nncrd
    ndcrd=colvar%coord_param%ndcrd
    r_0=colvar%coord_param%r_0
    NULLIFY(particles_i)
    CPPrecondition(colvar%type_id==coord_colvar_id,cp_failure_level,routineP,error,failure)
    IF (PRESENT(particles)) THEN
       my_particles => particles
    ELSE
       CPPrecondition(PRESENT(subsys),cp_failure_level,routineP,error,failure)
       CALL cp_subsys_get(subsys,particles=particles_i,error=error)
       my_particles => particles_i%els
    END IF

    ncoord=0.0_dp
    colvar%dsdr=0.0_dp
    DO ii=1,n_atoms_from
       i=colvar%coord_param%i_at_from(ii)
       xpi(:)=my_particles(i)%r(1:3)
       DO jj=1,n_atoms_to
          i=colvar%coord_param%i_at_to(jj)
          xpj(:)=my_particles(i)%r(1:3)
          ss=MATMUL(cell%h_inv,xpi(:)-xpj(:))
          ss=ss-NINT(ss)
          xij=MATMUL(cell%hmat,ss)
          r12=SQRT(xij(1)**2+xij(2)**2+xij(3)**2)
          IF(r12 < 1.0e-8_dp)CYCLE
          rdist = r12/r_0
          num=(1.0_dp-rdist**nncrd)
          invden=1.0_dp/(1.0_dp-rdist**ndcrd)
          func=num*invden
          dfunc= (- nncrd*rdist **(nncrd-1) *invden  &
               + num*(invden)**2 * ndcrd *rdist **(ndcrd-1))/(r12*r_0)

          ncoord=ncoord+func
          colvar%dsdr(:,ii)=colvar%dsdr(:,ii)+dfunc*xij
          colvar%dsdr(:,n_atoms_from+jj)=colvar%dsdr(:,n_atoms_from+jj)-dfunc*xij
       ENDDO
    ENDDO
    colvar%ss=ncoord

  END SUBROUTINE coord_colvar
  !***************************************************************************

  !!****f* colvar/torsion_colvar [1.0] *
  !!
  !!   NAME
  !!     torsion_colvar
  !!
  !!   FUNCTION
  !!     evaluates the force due to the torsion collective variable
  !!
  !!   NOTES
  !!
  !!   AUTHOR
  !!     Alessandro Laio, Fawzi Mohamed
  !!
  !!*** **********************************************************************
  SUBROUTINE torsion_colvar(colvar,cell,subsys,particles,error)

    TYPE(colvar_type), POINTER               :: colvar
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_subsystem_type), OPTIONAL, &
      POINTER                                :: subsys
    TYPE(particle_type), DIMENSION(:), &
      OPTIONAL, POINTER                      :: particles
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'torsion_colvar', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: i, ii
    LOGICAL                                  :: failure
    REAL(dp) :: angle, cosine, dedphi, dedxia, dedxib, dedxic, dedxid, dedxt, &
      dedxu, dedyia, dedyib, dedyic, dedyid, dedyt, dedyu, dedzia, dedzib, &
      dedzic, dedzid, dedzt, dedzu, dt, e, o0, rcb, rt2, rtru, ru2, sine, &
      xba, xca, xcb, xdb, xdc, xia, xib, xic, xid, xt, xtu, xu, yba, yca, &
      ycb, ydb, ydc, yia, yib, yic, yid, yt, ytu, yu, zba, zca, zcb, zdb, &
      zdc, zia, zib, zic, zid, zt, ztu, zu
    REAL(dp), DIMENSION(3, 4)                :: rr
    TYPE(particle_list_type), POINTER        :: particles_i
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: my_particles

    failure=.FALSE.
    NULLIFY(particles_i)
    CPPrecondition(colvar%type_id==torsion_colvar_id,cp_failure_level,routineP,error,failure)
    IF (PRESENT(particles)) THEN
       my_particles => particles
    ELSE
       CPPrecondition(PRESENT(subsys),cp_failure_level,routineP,error,failure)
       CALL cp_subsys_get(subsys,particles=particles_i,error=error)
       my_particles => particles_i%els
    END IF

    DO ii=1,4
       i=colvar%torsion_param%i_at_tors(ii)
       rr(:,ii)=my_particles(i)%r(1:3)
    ENDDO
    o0 = colvar%torsion_param%o0
    ! temporary: from tinker improper torsion routines
    xia = rr(1,1)
    yia = rr(2,1)
    zia = rr(3,1)
    xib = rr(1,2)
    yib = rr(2,2)
    zib = rr(3,2)
    xic = rr(1,3)
    yic = rr(2,3)
    zic = rr(3,3)
    xid = rr(1,4)
    yid = rr(2,4)
    zid = rr(3,4)
    xba = xib - xia
    yba = yib - yia
    zba = zib - zia
    xcb = xic - xib
    ycb = yic - yib
    zcb = zic - zib
    xdc = xid - xic
    ydc = yid - yic
    zdc = zid - zic
    xt = yba*zcb - ycb*zba
    yt = zba*xcb - zcb*xba
    zt = xba*ycb - xcb*yba
    xu = ycb*zdc - ydc*zcb
    yu = zcb*xdc - zdc*xcb
    zu = xcb*ydc - xdc*ycb
    xtu = yt*zu - yu*zt
    ytu = zt*xu - zu*xt
    ztu = xt*yu - xu*yt
    rt2 = xt*xt + yt*yt + zt*zt
    ru2 = xu*xu + yu*yu + zu*zu
    rtru = SQRT(rt2 * ru2)
    IF (rtru .NE. 0.0_dp) THEN
       rcb = SQRT(xcb*xcb + ycb*ycb + zcb*zcb)
       cosine = (xt*xu + yt*yu + zt*zu) / rtru
       sine = (xcb*xtu + ycb*ytu + zcb*ztu) / (rcb*rtru)
       cosine = MIN(1.0_dp,MAX(-1.0_dp,cosine))
       angle  = ACOS(cosine)
       IF (sine .LT. 0.0_dp)  angle = -angle
       ! 
       dt = angle ! [rad]
       dt=MOD(2.0E4_dp*pi+dt-o0,2.0_dp*pi)
       IF ( dt .GT. pi ) dt = dt - 2.0_dp*pi
       dt=o0+dt
       colvar%torsion_param%o0 = dt
       !
       !     calculate improper energy and master chain rule term
       !
       e = dt
       dedphi = 1.0_dp
       !
       !     chain rule terms for first derivative components
       !
       xca = xic - xia
       yca = yic - yia
       zca = zic - zia
       xdb = xid - xib
       ydb = yid - yib
       zdb = zid - zib
       dedxt = dedphi * (yt*zcb - ycb*zt) / (rt2*rcb)
       dedyt = dedphi * (zt*xcb - zcb*xt) / (rt2*rcb)
       dedzt = dedphi * (xt*ycb - xcb*yt) / (rt2*rcb)
       dedxu = -dedphi * (yu*zcb - ycb*zu) / (ru2*rcb)
       dedyu = -dedphi * (zu*xcb - zcb*xu) / (ru2*rcb)
       dedzu = -dedphi * (xu*ycb - xcb*yu) / (ru2*rcb)
       !
       !     compute first derivative components for this angle
       !
       dedxia = zcb*dedyt - ycb*dedzt
       dedyia = xcb*dedzt - zcb*dedxt
       dedzia = ycb*dedxt - xcb*dedyt
       dedzia = ycb*dedxt - xcb*dedyt
       dedxib = yca*dedzt - zca*dedyt + zdc*dedyu - ydc*dedzu
       dedyib = zca*dedxt - xca*dedzt + xdc*dedzu - zdc*dedxu
       dedzib = xca*dedyt - yca*dedxt + ydc*dedxu - xdc*dedyu
       dedxic = zba*dedyt - yba*dedzt + ydb*dedzu - zdb*dedyu
       dedyic = xba*dedzt - zba*dedxt + zdb*dedxu - xdb*dedzu
       dedzic = yba*dedxt - xba*dedyt + xdb*dedyu - ydb*dedxu
       dedxid = zcb*dedyu - ycb*dedzu
       dedyid = xcb*dedzu - zcb*dedxu
       dedzid = ycb*dedxu - xcb*dedyu
    ENDIF
    !
    colvar%ss=e
    colvar%dsdr(1,1)=dedxia
    colvar%dsdr(2,1)=dedyia
    colvar%dsdr(3,1)=dedzia
    colvar%dsdr(1,2)=dedxib
    colvar%dsdr(2,2)=dedyib
    colvar%dsdr(3,2)=dedzib
    colvar%dsdr(1,3)=dedxic
    colvar%dsdr(2,3)=dedyic
    colvar%dsdr(3,3)=dedzic
    colvar%dsdr(1,4)=dedxid
    colvar%dsdr(2,4)=dedyid
    colvar%dsdr(3,4)=dedzid
  END SUBROUTINE torsion_colvar
  !***************************************************************************

END MODULE colvar_methods
