!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2006  CP2K developers group                          !
!-----------------------------------------------------------------------------!

!!****** cp2k/qs_initial_guess [1.0] *
!!
!!   NAME
!!     qs_initial_guess
!!
!!   FUNCTION
!!     Routines to somehow generate an intial guess
!!
!!   AUTHOR
!!
!!   MODIFICATION HISTORY
!!      2006.03 Moved here from qs_scf.F [Joost VandeVondele]
!!
!!   SOURCE
!******************************************************************************

MODULE qs_initial_guess
  USE atomic_kind_types,               ONLY: atomic_kind_type,&
                                             get_atomic_kind,&
                                             get_atomic_kind_set
  USE basis_set_types,                 ONLY: get_gto_basis_set,&
                                             gto_basis_set_type
  USE cp_control_types,                ONLY: dft_control_type
  USE cp_fm_types,                     ONLY: cp_fm_create,&
                                             cp_fm_init_random,&
                                             cp_fm_p_type,&
                                             cp_fm_release,&
                                             cp_fm_to_fm,&
                                             cp_fm_type
  USE cp_sm_fm_interactions,           ONLY: copy_sm_to_fm,&
                                             cp_sm_fm_multiply
  USE external_potential_types,        ONLY: all_potential_type,&
                                             gth_potential_type
  USE input_constants,                 ONLY: atomic_guess,&
                                             core_guess,&
                                             densities_guess,&
                                             history_guess,&
                                             random_guess,&
                                             restart_guess
  USE input_section_types,             ONLY: section_vals_get_subs_vals,&
                                             section_vals_type,&
                                             section_vals_val_get
  USE kinds,                           ONLY: default_path_length,&
                                             dp,&
                                             dp_size,&
                                             int_size
  USE machine,                         ONLY: m_mov
  USE message_passing,                 ONLY: mp_sum
  USE particle_types,                  ONLY: get_particle_set,&
                                             particle_type
  USE qs_collocate_density,            ONLY: collocate_atomic_charge_density
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_env_reorthogonalize_vectors,&
                                             qs_environment_type
  USE qs_ks_methods,                   ONLY: qs_ks_did_change,&
                                             qs_ks_update_qs_env
  USE qs_mo_methods,                   ONLY: calculate_density_matrix,&
                                             make_basis_simple,&
                                             make_basis_sm
  USE qs_mo_types,                     ONLY: get_mo_set,&
                                             mo_set_p_type,&
                                             mo_set_restrict,&
                                             read_mo_set
  USE qs_scf_methods,                  ONLY: eigensolver,&
                                             simple_eigensolver
  USE qs_scf_types,                    ONLY: ot_method_nr,&
                                             qs_scf_env_type
  USE qs_wf_history_methods,           ONLY: wfi_extrapolate,&
                                             wfi_update
  USE qs_wf_history_types,             ONLY: wfi_use_guess_method_nr
  USE scf_control_types,               ONLY: scf_control_type
  USE sparse_matrix_types,             ONLY: get_matrix_diagonal,&
                                             real_matrix_p_type,&
                                             set_matrix_diagonal
  USE termination,                     ONLY: stop_memory,&
                                             stop_program
  USE timings,                         ONLY: timeset,&
                                             timestop
#include "cp_common_uses.h"

  IMPLICIT NONE

  PRIVATE

! *** Global parameters ***

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'qs_initial_guess'

  PUBLIC ::  calculate_first_density_matrix

CONTAINS

!!****f* qs_initial_guess/calculate_first_density_matrix *
!!
!!   NAME
!!     calculate_first_density_matrix
!!
!!   FUNCTION
!!     can use a variety of methods to come up with an initial
!!     density matrix and optionally an initial wavefunction
!!
!!   NOTES
!!     badly needs to be split in subroutines each doing one of the possible
!!     schemes
!!
!!   INPUTS
!!
!!   MODIFICATION HISTORY
!!     03.2006 moved here from qs_scf [Joost VandeVondele]
!!
!!*** **********************************************************************
  SUBROUTINE calculate_first_density_matrix(scf_env,qs_env,error)

    TYPE(qs_scf_env_type), POINTER           :: scf_env
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(cp_error_type), INTENT(inout)  &
                                             :: error

    CHARACTER(LEN=*), PARAMETER :: &
      routineN = 'calculate_first_density_matrix', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_path_length)       :: file_name, filename
    INTEGER :: atom_a, density_guess, group, handle, homo, iatom, id_nr, &
      ikind, iset, isgf, isgfa, ishell, ispin, istat, la, maxl, maxll, nao, &
      natom, ncount, nelectron, nmo, nset, nspin, qs_env_id, nvec, i, &
      extrapolation_method_nr, not_read
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: first_sgf
    INTEGER, DIMENSION(:), POINTER           :: atom_list, elec_conf, nshell
    INTEGER, DIMENSION(:, :), POINTER        :: first_sgfa, l, last_sgfa
    LOGICAL                                  :: exist, failure, id_equal, &
                                                ortho_basis, orthogonal_wf
    REAL(KIND=dp)                            :: maxocc, nelec, paa, scale, &
                                                total_rho, trps1, trps2
    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: econf, pdiag, sdiag
    TYPE(all_potential_type), POINTER        :: all_potential
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_fm_p_type), DIMENSION(:), &
      POINTER                                :: work1
    TYPE(cp_fm_type), POINTER                :: mo_coeff, moa, mob, ortho, &
                                                sv, work2
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(gth_potential_type), POINTER        :: gth_potential
    TYPE(gto_basis_set_type), POINTER        :: orb_basis_set
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mo_array
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(real_matrix_p_type), DIMENSION(:), &
      POINTER                                :: h_core_sparse, p_rmpv, &
                                                s_sparse
    TYPE(scf_control_type), POINTER          :: scf_control
    TYPE(section_vals_type), POINTER         :: dft_section, input

!   ---------------------------------------------------------------------------

    NULLIFY(all_potential,atomic_kind, mo_coeff, sv,&
         gth_potential, orb_basis_set, atomic_kind_set, particle_set,&
         ortho,work2,work1,mo_array,s_sparse,p_rmpv,scf_control, &
         dft_control,h_core_sparse)
    NULLIFY(dft_section, input)
    NULLIFY (moa,mob)

    CALL timeset("calculate_first_density_matrix","I"," ",handle)

    CALL get_qs_env(qs_env,atomic_kind_set=atomic_kind_set,&
         particle_set=particle_set,mos=mo_array, matrix_s=s_sparse,&
         matrix_h=h_core_sparse,input=input,&
         scf_control=scf_control, id_nr=qs_env_id, dft_control=dft_control,&
         error=error)

    nspin=dft_control%nspins

    p_rmpv => qs_env%rho%rho_ao
    work1 => scf_env%scf_work1
    work2 => scf_env%scf_work2
    ortho => scf_env%ortho

    dft_section =>  section_vals_get_subs_vals(input,"DFT",error=error)
    ortho_basis = .FALSE.
    IF ( dft_control%qs_control%semi_empirical ) THEN
       IF ( dft_control%qs_control%se_control%orthogonal_basis ) &
          ortho_basis = .TRUE.
    END IF

    IF (scf_control%use_ot.AND.&
        (.NOT.((scf_control%density_guess == random_guess).OR.&
               (scf_control%density_guess == atomic_guess).OR.&
               (((scf_control%density_guess == restart_guess).OR.&
                (scf_control%density_guess == history_guess)).AND.&
                (scf_control%level_shift == 0.0_dp))))) THEN
       CALL stop_program("calculate_first_density_matrix",&
            "OT needs GUESS ATOMIC / RESTART / HISTORY RESTART: other options NYI")
    END IF

    density_guess=scf_control%density_guess

    ! if a restart was requested, check that the file exists,
    ! if not we fall back to an atomic guess. No kidding, the file name should remain
    ! in sync with read_mo_set_from_restart
    id_nr=0
    IF (density_guess == restart_guess) THEN
        CALL section_vals_val_get(qs_env%input,"DFT%RESTART_FILE_NAME",&
             c_val=file_name,error=error)
        INQUIRE(FILE=file_name,exist=exist)
        IF (.NOT. exist) THEN
          filename = file_name
          filename((LEN_TRIM(filename)+1):(LEN(filename))) = "-"//&
               ADJUSTL(cp_to_string(1))
          INQUIRE(FILE=filename,exist=exist)
          IF (.NOT. exist) THEN
            density_guess = atomic_guess
          ELSE
            CALL m_mov(filename, file_name)
          END IF
        END IF
    ELSE IF (density_guess == history_guess) THEN
       CALL section_vals_val_get(qs_env%input, "DFT%RESTART_FILE_NAME", &
            c_val=file_name, error=error)

       nvec = qs_env%wf_history%memory_depth
       not_read = nvec+1
       DO i=1,nvec
         filename = file_name
         filename((LEN_TRIM(file_name)+1):LEN(file_name)) = "-"//&
              ADJUSTL(cp_to_string(i))
         INQUIRE(FILE=filename,exist=exist)
         IF ((.NOT. exist) .AND. (i < not_read)) THEN
           not_read = i
         END IF
       END DO
       IF (not_read == 1) THEN
         ! Is RESTART present?
         filename = file_name
         filename((LEN_TRIM(filename)+1):(LEN(filename))) = "-"//&
             ADJUSTL(cp_to_string(1))
         INQUIRE(FILE=filename,exist=exist)
         IF (.NOT. exist) THEN
           density_guess = atomic_guess
         END IF
       END IF
    END IF

    IF (density_guess == restart_guess) THEN

       CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set)
       CALL read_mo_set(mo_array,atomic_kind_set,particle_set,qs_env%para_env,&
            id_nr=id_nr,multiplicity=dft_control%multiplicity,dft_section=dft_section,error=error)

       DO ispin=1,nspin
          IF (scf_control%level_shift /= 0.0_dp) THEN
             CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
                             mo_coeff=mo_coeff)
             CALL cp_fm_to_fm(mo_coeff,ortho,error=error)
          END IF

          ! make all nmo vectors present orthonormal
          CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
               mo_coeff=mo_coeff, nmo=nmo, homo=homo)

          IF(ortho_basis) THEN
            CALL make_basis_simple(mo_coeff,nmo,error=error)
          ELSE
            ! ortho so that one can restart for different positions (basis sets?)
            CALL make_basis_sm(mo_coeff,homo,s_sparse(1)%matrix,error=error)
          ENDIF
         ! only alpha spin is kept for restricted
          IF (dft_control%restricted) EXIT
       ENDDO
       IF (dft_control%restricted) CALL mo_set_restrict(mo_array,error=error)
       DO ispin=1,nspin
          CALL calculate_density_matrix(mo_array(ispin)%mo_set,&
               p_rmpv(ispin)%matrix,error=error)
       ENDDO

    ELSE IF (density_guess == history_guess) THEN
       IF (not_read > 1) THEN
         DO i=1,not_read-1
           CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set)
           CALL read_mo_set(mo_array,atomic_kind_set,particle_set,qs_env%para_env,&
                id_nr=not_read-i,multiplicity=dft_control%multiplicity,dft_section=dft_section,error=error)

           DO ispin=1,nspin
             IF (scf_control%level_shift /= 0.0_dp) THEN
               CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
                               mo_coeff=mo_coeff)
               CALL cp_fm_to_fm(mo_coeff,ortho,error=error)
             END IF
           
             ! make all nmo vectors present orthonormal
             CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
                  mo_coeff=mo_coeff, nmo=nmo, homo=homo)

             IF(ortho_basis) THEN
               CALL make_basis_simple(mo_coeff,nmo,error=error)
             ELSE
               ! ortho so that one can restart for different positions (basis sets?)
               CALL make_basis_sm(mo_coeff,homo,s_sparse(1)%matrix,error=error)
             ENDIF
             ! only alpha spin is kept for restricted
             IF (dft_control%restricted) EXIT
           END DO
           IF (dft_control%restricted) CALL mo_set_restrict(mo_array,error=error)
           DO ispin=1,nspin
             CALL calculate_density_matrix(mo_array(ispin)%mo_set, &
                                           p_rmpv(ispin)%matrix,error=error)
           ENDDO

           ! Write to extrapolation pipeline
           CALL wfi_update(wf_history=qs_env%wf_history, qs_env=qs_env, dt=1.0_dp, error=error)
         END DO

         !CALL wfi_extrapolate(wf_history=qs_env%wf_history, qs_env=qs_env, dt=1.0_dp, &
         !                     extrapolation_method_nr=extrapolation_method_nr, &
         !                     orthogonal_wf=orthogonal_wf, error=error)

       END IF

    ELSE IF (density_guess == random_guess) THEN

       DO ispin=1,nspin
          CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
               mo_coeff=mo_coeff, nmo=nmo)
          CALL cp_fm_init_random(mo_coeff,nmo,error=error)
          IF(ortho_basis) THEN
            CALL make_basis_simple(mo_coeff,nmo,error=error)
          ELSE
            CALL make_basis_sm(mo_coeff,nmo,s_sparse(1)%matrix,error=error)
          ENDIF
          ! only alpha spin is kept for restricted
          IF (dft_control%restricted) EXIT
       ENDDO
       IF (dft_control%restricted) CALL mo_set_restrict(mo_array,error=error)
       DO ispin=1,nspin
          CALL calculate_density_matrix(mo_array(ispin)%mo_set,&
               p_rmpv(ispin)%matrix,error=error)
       ENDDO

    ELSE IF (density_guess == core_guess) THEN

       ispin = 1

       ! Load core Hamiltonian into work matrix

       CALL copy_sm_to_fm(h_core_sparse(1)%matrix,work1(ispin)%matrix,error=error)

       ! Diagonalize the core Hamiltonian matrix and retrieve a first set of
       ! molecular orbitals (MOs)

       IF (ortho_basis) THEN
         CALL simple_eigensolver(work1(ispin)%matrix,mo_array(ispin)%mo_set,&
                                 work2,.FALSE.,0.0_dp,&
                                 work_syevx=scf_control%work_syevx,&
                                 smear=0.0_dp,&
                                 error=error)
       ELSE
         CALL eigensolver(work1(ispin)%matrix,mo_array(ispin)%mo_set,ortho,work2,&
                          .FALSE.,0.0_dp,&
                          use_cholesky=scf_control%use_cholesky,&
                          work_syevx=scf_control%work_syevx,&
                          use_jacobi=.FALSE.,&
                          jacobi_threshold=scf_control%jacobi_threshold,&
                          smear=0.0_dp,&
                          error=error)
       END IF

       ! Open shell case: copy alpha MOs to beta MOs

       IF (nspin == 2) THEN
         CALL get_mo_set(mo_set=mo_array(1)%mo_set,mo_coeff=moa)
         CALL get_mo_set(mo_set=mo_array(2)%mo_set,mo_coeff=mob,nmo=nmo)
         CALL cp_fm_to_fm(moa,mob,nmo)
       END IF

       ! Build an initial density matrix (for each spin in the case of
       ! an open shell calculation) from the first MOs set

       DO ispin=1,nspin
         CALL calculate_density_matrix(mo_array(ispin)%mo_set,&
                                       p_rmpv(ispin)%matrix,&
                                       error=error)
       END DO

    ELSE IF (density_guess == atomic_guess) THEN

      group = qs_env%para_env%group

      natom = SIZE(particle_set)
      ALLOCATE (first_sgf(natom),STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                       "first_sgf",natom*int_size)
      CALL get_particle_set(particle_set=particle_set,first_sgf=first_sgf)

      CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set,maxlgto=maxl)
      ALLOCATE (econf(0:maxl),STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                       "econf",(maxl + 1)*int_size)

      CALL get_mo_set(mo_array(1)%mo_set,nao=nao)
      ALLOCATE (pdiag(nao),STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                       "pdiag",nao*dp_size)
      pdiag(:) = 0.0_dp

      ALLOCATE (sdiag(nao),STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                       "sdiag",nao*dp_size)
      IF (ortho_basis) THEN
        sdiag(:) = 1.0_dp
      ELSE
        CALL get_matrix_diagonal(s_sparse(1)%matrix,sdiag)
        CALL mp_sum(sdiag,group)
      END IF

      DO ispin=1,nspin

        CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
                        maxocc=maxocc,&
                        nelectron=nelectron)

        ncount = 0
        trps1 = 0.0_dp
        trps2 = 0.0_dp
        pdiag(:) = 0.0_dp

        IF (nelectron /= 0) THEN

          DO ikind=1,SIZE(atomic_kind_set)

            atomic_kind => atomic_kind_set(ikind)

            CALL get_atomic_kind(atomic_kind=atomic_kind,&
                                 natom=natom,&
                                 atom_list=atom_list,&
                                 all_potential=all_potential,&
                                 gth_potential=gth_potential,&
                                 orb_basis_set=orb_basis_set)

            IF (ASSOCIATED(all_potential)) THEN
              CALL get_atomic_kind(atomic_kind=atomic_kind,elec_conf=elec_conf)
            ELSE IF (ASSOCIATED(gth_potential)) THEN
              CALL get_atomic_kind(atomic_kind=atomic_kind,elec_conf=elec_conf)
            ELSE
              CYCLE
            END IF

            maxll = MIN(SIZE(elec_conf) - 1,maxl)
            econf(:) = 0.0_dp
            econf(0:maxll) = 0.5_dp*maxocc*REAL(elec_conf(0:maxll),dp)

            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,&
                                   nset=nset,&
                                   nshell=nshell,&
                                   l=l,&
                                   first_sgf=first_sgfa,&
                                   last_sgf=last_sgfa)

            DO iset=1,nset
              DO ishell=1,nshell(iset)
                la = l(ishell,iset)
                nelec = maxocc*REAL(2*la + 1,dp)
                IF (econf(la) > 0.0_dp) THEN
                  IF (econf(la) >= nelec) THEN
                    paa = maxocc
                    econf(la) = econf(la) - nelec
                  ELSE
                    paa = maxocc*econf(la)/nelec
                    econf(la) = 0.0_dp
                    ncount = ncount + NINT(nelec/maxocc)
                  END IF
                  DO isgfa=first_sgfa(ishell,iset),last_sgfa(ishell,iset)
                    DO iatom=1,natom
                      atom_a = atom_list(iatom)
                      isgf = first_sgf(atom_a) + isgfa - 1
                      pdiag(isgf) = paa
                      IF (paa == maxocc) THEN
                        trps1 = trps1 + paa*sdiag(isgf)
                      ELSE
                        trps2 = trps2 + paa*sdiag(isgf)
                      END IF
                    END DO
                  END DO
                END IF
              END DO ! ishell
            END DO ! iset

          END DO ! ikind

          IF (trps2 == 0.0_dp) THEN
            DO isgf=1,nao
              IF (sdiag(isgf) > 0.0_dp) pdiag(isgf) = pdiag(isgf)/sdiag(isgf)
            END DO
          ELSE
            scale = (REAL(nelectron,dp) - trps1)/trps2
            DO isgf=1,nao
              IF (pdiag(isgf) < maxocc) pdiag(isgf) = scale*pdiag(isgf)
            END DO
          END IF

        END IF

        CALL set_matrix_diagonal(p_rmpv(ispin)%matrix,pdiag)

        ! The orbital transformation method (OT) requires not only an
        ! initial density matrix, but also an initial wavefunction (MO set)

        IF (scf_control%use_ot) THEN

          IF (dft_control%restricted.AND.(ispin == 2)) THEN

            CALL mo_set_restrict(mo_array,error=error)

          ELSE

            CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
                            mo_coeff=mo_coeff,&
                            nmo=nmo)
            CALL cp_fm_init_random(mo_coeff,nmo,error=error)
            CALL cp_fm_create(sv,mo_coeff%matrix_struct,"SV",error=error)

            ! multiply times PS

            IF (ortho_basis) THEN
              CALL cp_fm_to_fm(mo_coeff,sv,error=error)
            ELSE
              CALL cp_sm_fm_multiply(s_sparse(1)%matrix,mo_coeff,sv,nmo,error=error)
            END IF

            ! here we could easily multiply with the diag that we actually have replicated already

            CALL cp_sm_fm_multiply(p_rmpv(ispin)%matrix,sv,mo_coeff,nmo,error=error)
            CALL cp_fm_release(sv,error=error)

            ! and ortho the result

            IF (ortho_basis) THEN
              CALL make_basis_simple(mo_coeff,nmo,error=error)
            ELSE
              CALL make_basis_sm(mo_coeff,nmo,s_sparse(1)%matrix,error=error)
            END IF

          END IF

          CALL calculate_density_matrix(mo_array(ispin)%mo_set,&
                                        p_rmpv(ispin)%matrix,&
                                        error=error)

        END IF

      END DO

      DEALLOCATE (econf,STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,"econf")

      DEALLOCATE (first_sgf,STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,"first_sgf")

      DEALLOCATE (pdiag,STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,"pdiag")

      DEALLOCATE (sdiag,STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,"sdiag")

    ELSE IF (density_guess == densities_guess) THEN

      ! Collocation of the density into the PW-grid
      CALL collocate_atomic_charge_density(total_rho=total_rho, qs_env=qs_env, error=error)

      ! do some assertions here on these matrices having the same structure,
      ! as is currently required
      DO ispin=1,SIZE(qs_env%matrix_s)
        id_equal=(qs_env%matrix_s(ispin)%matrix%sparsity_id==qs_env%matrix_s(1)%matrix%sparsity_id)
        CPPrecondition(id_equal,cp_failure_level,routineP,error,failure)
      ENDDO
      ! matrix_p = rho%rho_ao
      DO ispin=1,SIZE(qs_env%rho%rho_ao)
        id_equal=(qs_env%rho%rho_ao(ispin)%matrix%sparsity_id==qs_env%matrix_s(1)%matrix%sparsity_id)
        CPPrecondition(id_equal,cp_failure_level,routineP,error,failure)
      ENDDO
      DO ispin=1,SIZE(qs_env%matrix_h)
        id_equal=(qs_env%matrix_h(ispin)%matrix%sparsity_id==qs_env%matrix_s(1)%matrix%sparsity_id)
        CPPrecondition(id_equal,cp_failure_level,routineP,error,failure)
      ENDDO
      DO ispin=1,SIZE(qs_env%matrix_ks)
        id_equal=(qs_env%matrix_ks(ispin)%matrix%sparsity_id==qs_env%matrix_s(1)%matrix%sparsity_id)
        CPPrecondition(id_equal,cp_failure_level,routineP,error,failure)
      ENDDO
      ! end sparsity check

      qs_env%scf_env%iter_count = 1

      ! qs_ks_build_kohn_sham_matrix (Integration)
      !CALL qs_ks_build_kohn_sham_matrix(ks_env=qs_env%ks_env, qs_env=qs_env, &
      !                                  ks_matrix=qs_env%matrix_ks, rho=qs_env%rho, &
      !                                  energy=qs_env%energy, calculate_forces=.TRUE., &
      !                                  just_energy=.FALSE., kg_gpw=.FALSE., error=error)
      CALL qs_ks_did_change(ks_env=qs_env%ks_env, rho_changed=.TRUE., error=error)

      CALL qs_ks_update_qs_env(ks_env=qs_env%ks_env, qs_env=qs_env, &
                               calculate_forces=.TRUE., just_energy=.FALSE., error=error)

      ! diagonalization
      DO ispin = 1,qs_env%dft_control%nspins
        CALL copy_sm_to_fm(qs_env%matrix_ks(ispin)%matrix, qs_env%scf_env%scf_work1(ispin)%matrix,error=error)
      END DO

      qs_env%scf_env%iter_method = "Mixing/Diag"
      qs_env%scf_env%iter_delta = 0.0_dp

      DO ispin = 1,qs_env%dft_control%nspins
        CALL eigensolver(matrix_ks=qs_env%scf_env%scf_work1(ispin)%matrix, &
                         mo_set=qs_env%mos(ispin)%mo_set, ortho=qs_env%scf_env%ortho, &
                         work=qs_env%scf_env%scf_work2, do_level_shift=.FALSE., &
                         level_shift=scf_control%level_shift, &
                         use_cholesky=scf_control%use_cholesky, work_syevx=scf_control%work_syevx, &
                         use_jacobi=.FALSE., jacobi_threshold=scf_control%jacobi_threshold, &
                         smear=scf_control%smear, error=error)

        ! calculate_density_matrix
        CALL calculate_density_matrix(qs_env%mos(ispin)%mo_set, qs_env%rho%rho_ao(ispin)%matrix, &
                                      error=error)
      END DO

    ELSE

      CALL stop_program(routineP,&
                        "An invalid keyword for the initial density "//&
                        "guess was specified")

    END IF

    CALL timestop(0.0_dp,handle)

  END SUBROUTINE calculate_first_density_matrix

  ! ***************************************************************************

END MODULE qs_initial_guess
