!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2007  CP2K developers group                          !
!-----------------------------------------------------------------------------!

#if !defined(__DEBUG__)

MODULE machine_nag

  USE f90_unix
  USE f90_unix_dir
  USE f90_unix_env,                    ONLY: gethostname,&
                                             getlogin
  USE f90_unix_proc
  USE kinds,                           ONLY: default_string_length,&
                                             dp, int_8

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: m_cputime, m_datum, m_flush, m_memory, &
            m_hostnm, m_getcwd, m_getlog, m_getuid, m_getpid, m_getarg,&
            m_iargc, m_abort, m_chdir, m_loc_r, m_loc_c, m_mov

#ifdef FD_DEBUG_ALLOC
! to use this you must link the object file generated by the follwing c file:
!----------------
! void fd_loc_(void* p,int * adr)
! { *adr = (int)p; }
!
! void fd_loc2_(void* p,int * adr)
! { *adr = (int)p; }
!----------------
  INTERFACE
     SUBROUTINE fd_loc(ar,val)
       USE kinds, ONLY: dp
    REAL(KIND=dp), DIMENSION(*), INTENT(in)  :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc
     SUBROUTINE fd_loc2(ar,val)
       USE kinds, ONLY: dp
    COMPLEX(KIND=dp), DIMENSION(*), &
      INTENT(in)                             :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc2
  END INTERFACE
#endif

!!*****
!******************************************************************************

CONTAINS

FUNCTION m_loc_r(a) RESULT(res)
  REAL(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_r
  
FUNCTION m_loc_c(a) RESULT(res)
  COMPLEX(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc2(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_c
  

! can be used to get a nice core
SUBROUTINE m_abort()
   CALL abort()
END SUBROUTINE m_abort


FUNCTION m_iargc() RESULT (ic)
    INTEGER                                  :: ic

  ic = iargc()
END FUNCTION m_iargc

!******************************************************************************
!!  cpu time in seconds
FUNCTION m_cputime() RESULT (ct)
    REAL(KIND=dp)                            :: ct

    REAL                                     :: ctr

  CALL CPU_TIME(ctr)
  ct=ctr
END FUNCTION m_cputime
!******************************************************************************
!!  time and date
SUBROUTINE m_datum(cal_date)
    CHARACTER(len=*), INTENT(OUT)            :: cal_date

    CHARACTER(len=10)                        :: time
    CHARACTER(len=5)                         :: zone
    CHARACTER(len=8)                         :: date
    INTEGER, DIMENSION(8)                    :: values

  CALL DATE_AND_TIME(date=date, time=time, zone=zone, values=values)
  cal_date=date//" "//time
END SUBROUTINE m_datum

! *****************************************************************************

  SUBROUTINE m_flush(lunit)

!   Purpose: Flush the output to a logical unit.

!   History: - Creation (14.10.1999,MK)

!   ***************************************************************************

    INTEGER, INTENT(IN)                      :: lunit

!   ---------------------------------------------------------------------------

    CALL flush(lunit)

  END SUBROUTINE m_flush

! *****************************************************************************

! *****************************************************************************
! returns the total amount of memory [bytes] in use, if known, zero otherwise
! *****************************************************************************
  FUNCTION m_memory()
    INTEGER(KIND=int_8) m_memory
    m_memory=0
  END FUNCTION m_memory

! *****************************************************************************


! *****************************************************************************

  SUBROUTINE m_mov(source,TARGET)

    CHARACTER(LEN=*), INTENT(IN)             :: source, TARGET

    CHARACTER(LEN=2*default_string_length+4) :: cmd

!   ---------------------------------------------------------------------------

    CALL rename(TRIM(source),TRIM(target))

  END SUBROUTINE m_mov

! *****************************************************************************

SUBROUTINE m_hostnm(hname)
    CHARACTER(len=*), INTENT(OUT)            :: hname

    INTEGER                                  :: len
    CHARACTER(len=60)                        :: tmpname

  len=60
  CALL gethostname(tmpname,len)
  hname=tmpname(1:len)
END SUBROUTINE m_hostnm

  ! ***************************************************************************

  SUBROUTINE m_getcwd(cwd)

    CHARACTER(LEN=*), INTENT(OUT)            :: cwd

! -------------------------------------------------------------------------

    CALL getcwd(cwd)

  END SUBROUTINE m_getcwd

! *****************************************************************************

SUBROUTINE m_chdir(dir,ierror)
    CHARACTER(len=*), INTENT(IN)             :: dir
    INTEGER, INTENT(OUT)                     :: ierror

    CALL chdir(dir,ierror)
END SUBROUTINE m_chdir

!******************************************************************************
SUBROUTINE m_getlog(user)
    CHARACTER(len=*), INTENT(OUT)            :: user

    INTEGER                                  :: len
    CHARACTER(len=60)                        :: tmp

  len=60
  CALL getlogin(tmp,len)
  user=tmp(1:len)
END SUBROUTINE m_getlog
!******************************************************************************
SUBROUTINE m_getuid(uid)
    INTEGER, INTENT(OUT)                     :: uid

  uid = getuid()
END SUBROUTINE m_getuid
!******************************************************************************
SUBROUTINE m_getpid(pid)
    INTEGER, INTENT(OUT)                     :: pid

  pid = getpid()
END SUBROUTINE m_getpid
!******************************************************************************
SUBROUTINE m_getarg(i,arg)
    INTEGER, INTENT(IN)                      :: i
    CHARACTER(len=*), INTENT(OUT)            :: arg

  CALL getarg(i,arg)
END SUBROUTINE m_getarg
!******************************************************************************
END MODULE machine_nag

#else

MODULE machine_nag

  USE kinds,                           ONLY: dp, int_8

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: m_cputime, m_datum, m_flush, m_memory, &
            m_hostnm, m_getcwd, m_getlog, m_getuid, m_getpid, m_getarg,&
            m_iargc, m_abort, m_chdir, m_loc_r, m_loc_c, m_mov

#ifdef FD_DEBUG_ALLOC
! to use this you must link the object file generated by the follwing c file:
!----------------
! void fd_loc_(void* p,int * adr)
! { *adr = (int)p; }
!
! void fd_loc2_(void* p,int * adr)
! { *adr = (int)p; }
!----------------
  INTERFACE
     SUBROUTINE fd_loc(ar,val)
       USE kinds, ONLY: dp
    REAL(KIND=dp), DIMENSION(*), INTENT(in)  :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc
     SUBROUTINE fd_loc2(ar,val)
       USE kinds, ONLY: dp
    COMPLEX(KIND=dp), DIMENSION(*), &
      INTENT(in)                             :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc2
  END INTERFACE
#endif

!!*****
!******************************************************************************

CONTAINS

FUNCTION m_loc_r(a) RESULT(res)
  REAL(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_r
  
FUNCTION m_loc_c(a) RESULT(res)
  COMPLEX(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc2(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_c
  

! can be used to get a nice core
SUBROUTINE m_abort()
   ! CALL abort()
END SUBROUTINE m_abort


FUNCTION m_iargc() RESULT (ic)
    INTEGER                                  :: ic

     ic = 1
END FUNCTION m_iargc

!******************************************************************************
!!  cpu time in seconds
FUNCTION m_cputime() RESULT (ct)
    REAL(KIND=dp)                            :: ct

    REAL                                     :: ctr

  CALL CPU_TIME(ctr)
  ct=ctr
END FUNCTION m_cputime
!******************************************************************************
!!  time and date
SUBROUTINE m_datum(cal_date)
    CHARACTER(len=*), INTENT(OUT)            :: cal_date

    CHARACTER(len=10)                        :: time
    CHARACTER(len=5)                         :: zone
    CHARACTER(len=8)                         :: date
    INTEGER, DIMENSION(8)                    :: values

  CALL DATE_AND_TIME(date=date, time=time, zone=zone, values=values)
  cal_date=date//" "//time
END SUBROUTINE m_datum

! *****************************************************************************

  SUBROUTINE m_flush(lunit)

!   Purpose: Flush the output to a logical unit.

!   History: - Creation (14.10.1999,MK)

!   ***************************************************************************

    INTEGER, INTENT(IN)                      :: lunit

!   ---------------------------------------------------------------------------

  END SUBROUTINE m_flush

! *****************************************************************************

! *****************************************************************************
! returns the total amount of memory [bytes] in use, if known, zero otherwise
! *****************************************************************************
  FUNCTION m_memory()
    INTEGER(KIND=int_8) m_memory
    m_memory=0
  END FUNCTION m_memory

! *****************************************************************************
SUBROUTINE m_hostnm(hname)
    CHARACTER(len=*), INTENT(OUT)            :: hname

    hname=""
END SUBROUTINE m_hostnm
!******************************************************************************
SUBROUTINE m_getcwd(curdir)
    CHARACTER(len=*), INTENT(OUT)            :: curdir

  curdir="./"
END SUBROUTINE m_getcwd
!******************************************************************************
SUBROUTINE m_chdir(dir,ierror)
    CHARACTER(len=*), INTENT(IN)             :: dir
    INTEGER, INTENT(OUT)                     :: ierror

    ierror=-1
END SUBROUTINE m_chdir

!******************************************************************************
SUBROUTINE m_getlog(user)
    CHARACTER(len=*), INTENT(OUT)            :: user

    user=""
END SUBROUTINE m_getlog
!******************************************************************************
SUBROUTINE m_getuid(uid)
    INTEGER, INTENT(OUT)                     :: uid

    uid = 0
END SUBROUTINE m_getuid
!******************************************************************************
SUBROUTINE m_getpid(pid)
    INTEGER, INTENT(OUT)                     :: pid

    pid = 0
END SUBROUTINE m_getpid
!******************************************************************************
SUBROUTINE m_getarg(i,arg)
    INTEGER, INTENT(IN)                      :: i
    CHARACTER(len=*), INTENT(OUT)            :: arg

    arg="inp" 
END SUBROUTINE m_getarg
!******************************************************************************
! *****************************************************************************

  SUBROUTINE m_mov(source,TARGET)

    CHARACTER(LEN=*), INTENT(IN)             :: source, TARGET

!   ---------------------------------------------------------------------------

    STOP "m_mov not supported .... "

  END SUBROUTINE m_mov

! *****************************************************************************

END MODULE machine_nag

#endif
