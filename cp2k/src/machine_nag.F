#if !defined(__DEBUG__)

MODULE machine_nag

  USE f90_unix
  USE f90_unix_dir
  USE f90_unix_env,                    ONLY: gethostname,&
                                             getlogin
  USE f90_unix_proc
  USE kinds,                           ONLY: dp

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: m_cputime, m_datum, m_flush, print_memory, &
            m_hostnm, m_getcwd, m_getlog, m_getuid, m_getpid, m_getarg,&
            m_iargc, m_abort, m_chdir, m_loc_r, m_loc_c

#ifdef FD_DEBUG_ALLOC
! to use this you must link the object file generated by the follwing c file:
!----------------
! void fd_loc_(void* p,int * adr)
! { *adr = (int)p; }
!
! void fd_loc2_(void* p,int * adr)
! { *adr = (int)p; }
!----------------
  INTERFACE
     SUBROUTINE fd_loc(ar,val)
       USE kinds, ONLY: dp
    REAL(KIND=dp), DIMENSION(*), INTENT(in)  :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc
     SUBROUTINE fd_loc2(ar,val)
       USE kinds, ONLY: dp
    COMPLEX(KIND=dp), DIMENSION(*), &
      INTENT(in)                             :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc2
  END INTERFACE
#endif

!!*****
!******************************************************************************

CONTAINS

FUNCTION m_loc_r(a) RESULT(res)
  REAL(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_r
  
FUNCTION m_loc_c(a) RESULT(res)
  COMPLEX(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc2(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_c
  

! can be used to get a nice core
SUBROUTINE m_abort()
   CALL abort()
END SUBROUTINE m_abort


FUNCTION m_iargc() RESULT (ic)
    INTEGER                                  :: ic

  ic = iargc()
END FUNCTION m_iargc

!******************************************************************************
!!  cpu time in seconds
FUNCTION m_cputime() RESULT (ct)
    REAL(KIND=dp)                            :: ct

    REAL                                     :: ctr

  CALL CPU_TIME(ctr)
  ct=ctr
END FUNCTION m_cputime
!******************************************************************************
!!  time and date
SUBROUTINE m_datum(cal_date)
    CHARACTER(len=*), INTENT(OUT)            :: cal_date

    CHARACTER(len=10)                        :: time
    CHARACTER(len=5)                         :: zone
    CHARACTER(len=8)                         :: date
    INTEGER, DIMENSION(8)                    :: values

  CALL DATE_AND_TIME(date=date, time=time, zone=zone, values=values)
  cal_date=date//" "//time
END SUBROUTINE m_datum

! *****************************************************************************

  SUBROUTINE m_flush(lunit)

!   Purpose: Flush the output to a logical unit.

!   History: - Creation (14.10.1999,MK)

!   ***************************************************************************

    INTEGER, INTENT(IN)                      :: lunit

!   ---------------------------------------------------------------------------

    CALL flush(lunit)

  END SUBROUTINE m_flush

! *****************************************************************************

  SUBROUTINE print_memory(checkpoint)

!   Purpose: Print the memory usage of the program at checkpoint.

!   ***************************************************************************

    CHARACTER(LEN=*), INTENT(IN)             :: checkpoint

    CHARACTER(LEN=200)                       :: cmdstr
    INTEGER                                  :: pid

!   ---------------------------------------------------------------------------

    CALL m_getpid(pid)

    WRITE(UNIT=cmdstr,FMT="(A,I8,A,I8,A)")&
      "echo -e ""\\n PID""",pid,""" <"//TRIM(checkpoint)//&
      ">:"" `ps -o vsz --no-headers -p",pid," ` KBytes""\\c"""

    CALL system(cmdstr)

  END SUBROUTINE print_memory

! *****************************************************************************

SUBROUTINE m_hostnm(hname)
    CHARACTER(len=*), INTENT(OUT)            :: hname

    INTEGER                                  :: len
    CHARACTER(len=60)                        :: tmpname

  len=60
  CALL gethostname(tmpname,len)
  hname=tmpname(1:len)
END SUBROUTINE m_hostnm

  ! ***************************************************************************

  SUBROUTINE m_getcwd(cwd)

    CHARACTER(LEN=*), INTENT(OUT)            :: cwd

! -------------------------------------------------------------------------

    CALL getcwd(cwd)

  END SUBROUTINE m_getcwd

! *****************************************************************************

SUBROUTINE m_chdir(dir,ierror)
    CHARACTER(len=*), INTENT(IN)             :: dir
    INTEGER, INTENT(OUT)                     :: ierror

    CALL chdir(dir,ierror)
END SUBROUTINE m_chdir

!******************************************************************************
SUBROUTINE m_getlog(user)
    CHARACTER(len=*), INTENT(OUT)            :: user

    INTEGER                                  :: len
    CHARACTER(len=60)                        :: tmp

  len=60
  CALL getlogin(tmp,len)
  user=tmp(1:len)
END SUBROUTINE m_getlog
!******************************************************************************
SUBROUTINE m_getuid(uid)
    INTEGER, INTENT(OUT)                     :: uid

  uid = getuid()
END SUBROUTINE m_getuid
!******************************************************************************
SUBROUTINE m_getpid(pid)
    INTEGER, INTENT(OUT)                     :: pid

  pid = getpid()
END SUBROUTINE m_getpid
!******************************************************************************
SUBROUTINE m_getarg(i,arg)
    INTEGER, INTENT(IN)                      :: i
    CHARACTER(len=*), INTENT(OUT)            :: arg

  CALL getarg(i,arg)
END SUBROUTINE m_getarg
!******************************************************************************
END MODULE machine_nag

#else

MODULE machine_nag

  USE kinds,                           ONLY: dp

  IMPLICIT NONE

  PRIVATE

  PUBLIC :: m_cputime, m_datum, m_flush, print_memory, &
            m_hostnm, m_getcwd, m_getlog, m_getuid, m_getpid, m_getarg,&
            m_iargc, m_abort, m_chdir, m_loc_r, m_loc_c

#ifdef FD_DEBUG_ALLOC
! to use this you must link the object file generated by the follwing c file:
!----------------
! void fd_loc_(void* p,int * adr)
! { *adr = (int)p; }
!
! void fd_loc2_(void* p,int * adr)
! { *adr = (int)p; }
!----------------
  INTERFACE
     SUBROUTINE fd_loc(ar,val)
       USE kinds, ONLY: dp
    REAL(KIND=dp), DIMENSION(*), INTENT(in)  :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc
     SUBROUTINE fd_loc2(ar,val)
       USE kinds, ONLY: dp
    COMPLEX(KIND=dp), DIMENSION(*), &
      INTENT(in)                             :: ar
    INTEGER, INTENT(out)                     :: val

     END SUBROUTINE fd_loc2
  END INTERFACE
#endif

!!*****
!******************************************************************************

CONTAINS

FUNCTION m_loc_r(a) RESULT(res)
  REAL(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_r
  
FUNCTION m_loc_c(a) RESULT(res)
  COMPLEX(KIND=dp), INTENT(in), DIMENSION(*) :: a
  INTEGER :: res

#ifdef FD_DEBUG_ALLOC
  CALL fd_loc2(a,res)
#else
  res=-1
#endif
END FUNCTION m_loc_c
  

! can be used to get a nice core
SUBROUTINE m_abort()
   ! CALL abort()
END SUBROUTINE m_abort


FUNCTION m_iargc() RESULT (ic)
    INTEGER                                  :: ic

     ic = 1
END FUNCTION m_iargc

!******************************************************************************
!!  cpu time in seconds
FUNCTION m_cputime() RESULT (ct)
    REAL(KIND=dp)                            :: ct

    REAL                                     :: ctr

  CALL CPU_TIME(ctr)
  ct=ctr
END FUNCTION m_cputime
!******************************************************************************
!!  time and date
SUBROUTINE m_datum(cal_date)
    CHARACTER(len=*), INTENT(OUT)            :: cal_date

    CHARACTER(len=10)                        :: time
    CHARACTER(len=5)                         :: zone
    CHARACTER(len=8)                         :: date
    INTEGER, DIMENSION(8)                    :: values

  CALL DATE_AND_TIME(date=date, time=time, zone=zone, values=values)
  cal_date=date//" "//time
END SUBROUTINE m_datum

! *****************************************************************************

  SUBROUTINE m_flush(lunit)

!   Purpose: Flush the output to a logical unit.

!   History: - Creation (14.10.1999,MK)

!   ***************************************************************************

    INTEGER, INTENT(IN)                      :: lunit

!   ---------------------------------------------------------------------------

  END SUBROUTINE m_flush

! *****************************************************************************

  SUBROUTINE print_memory(checkpoint)

!   Purpose: Print the memory usage of the program at checkpoint.

!   ***************************************************************************

    CHARACTER(LEN=*), INTENT(IN)             :: checkpoint

!   ---------------------------------------------------------------------------

    WRITE(6,*) checkpoint


  END SUBROUTINE print_memory

! *****************************************************************************

SUBROUTINE m_hostnm(hname)
    CHARACTER(len=*), INTENT(OUT)            :: hname

    hname=""
END SUBROUTINE m_hostnm
!******************************************************************************
SUBROUTINE m_getcwd(curdir)
    CHARACTER(len=*), INTENT(OUT)            :: curdir

  curdir="./"
END SUBROUTINE m_getcwd
!******************************************************************************
SUBROUTINE m_chdir(dir,ierror)
    CHARACTER(len=*), INTENT(IN)             :: dir
    INTEGER, INTENT(OUT)                     :: ierror

    ierror=-1
END SUBROUTINE m_chdir

!******************************************************************************
SUBROUTINE m_getlog(user)
    CHARACTER(len=*), INTENT(OUT)            :: user

    user=""
END SUBROUTINE m_getlog
!******************************************************************************
SUBROUTINE m_getuid(uid)
    INTEGER, INTENT(OUT)                     :: uid

    uid = 0
END SUBROUTINE m_getuid
!******************************************************************************
SUBROUTINE m_getpid(pid)
    INTEGER, INTENT(OUT)                     :: pid

    pid = 0
END SUBROUTINE m_getpid
!******************************************************************************
SUBROUTINE m_getarg(i,arg)
    INTEGER, INTENT(IN)                      :: i
    CHARACTER(len=*), INTENT(OUT)            :: arg

    arg="inp" 
END SUBROUTINE m_getarg
!******************************************************************************
END MODULE machine_nag

#endif
