!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C ) 2000  CP2K developers group                                !
!-----------------------------------------------------------------------------!
!!****** cp2k/pol_force_pw [1.0] *
!!
!!   NAME
!!     pol_force_pw
!!
!!   FUNCTION
!!
!!   AUTHOR
!!     CJM
!!
!!   SOURCE
!******************************************************************************

MODULE pol_force_pw

  USE atomic_kinds, ONLY : kind_info_type
  USE dg_types, ONLY : dg_type
  USE coefficient_types, ONLY : coeff_type
  USE empirical_parameters, ONLY : empirical_parameter_type
  USE ewald_parameters_types, ONLY : ewald_parameters_type
  USE fist_intra_force, ONLY : force_intra_control
  USE fist_nonbond_force, ONLY : force_nonbond, bonded_correct_gaussian
  USE global_types, ONLY : global_environment_type
  USE greens_fn, ONLY : pw_green_fn_init
  USE kinds, ONLY : dbl
  USE linklist_control, ONLY : list_control
  USE mathconstants, ONLY : pi, zero
  USE md, ONLY : thermodynamic_type, simulation_parameters_type
  USE molecule_types, ONLY : molecule_structure_type, particle_node_type, &
       linklist_neighbor, linklist_exclusion, linklist_bonds, &
       linklist_bends, linklist_torsions
  USE message_passing, ONLY : mp_sum
  USE pair_potential, ONLY : potentialparm_type
  USE pol_initialize_coef_pw, ONLY : initialize_coef_pw
  USE pol_electrostatics_pw, ONLY : electrostatics
  USE pol_overlap_pw, ONLY : force_overlap
  USE pol_projectors_pw, ONLY : projectors, pol_projector_type
  USE pol_thk_pw, ONLY : force_thk
  USE particle_types, ONLY : particle_type
  USE pol_grids, ONLY : pol_grids_allocate, pol_grids_count, &
       pol_grids_map, pol_grids_initialize, assign_coefs_to_grids, &
       pol_grids_ref_grid
  USE pw_grid_types, ONLY : pw_grid_type
  USE pw_grids, ONLY : pw_grid_change
  USE simulation_cell, ONLY : cell_type, get_hinv
  USE spme, ONLY : spme_evaluate
  USE termination, ONLY : stop_program, stop_memory
  USE timings, ONLY : timeset, timestop
  USE linklist_types, ONLY : linklist_internal_data_type

  PRIVATE
  PUBLIC :: force_control, debug_variables_type, get_pol_grids

  TYPE debug_variables_type
     REAL ( dbl ) :: pot_electrostatics, pot_overlap, pot_thk
     REAL ( dbl ), DIMENSION ( :, : ), POINTER :: f_ovlp_part, f_elec_part, f_thk_part
     COMPLEX ( dbl ), DIMENSION ( : ), POINTER :: f_ovlp_coef, f_elec_coef, f_thk_coef
     REAL ( dbl ), DIMENSION ( 3, 3 ) :: pv_electrostatic, pv_overlap, pv_thk
  END TYPE debug_variables_type

! globals to module
  TYPE ( pw_grid_type ),POINTER, DIMENSION ( : ) :: big_grid, small_grid
  TYPE ( dg_type ), POINTER, DIMENSION ( : ) :: dg_proj
  TYPE ( dg_type ), POINTER, DIMENSION ( : ) :: dg_atom
  REAL ( dbl ), DIMENSION ( :, : ), ALLOCATABLE :: f_nonbond
  INTEGER :: iref

!******************************************************************************
CONTAINS
!******************************************************************************
!!****** pol_force_pw/force_control [1.0] *
!!
!!   NAME
!!     force_control
!!
!!   SOURCE
!******************************************************************************

SUBROUTINE force_control ( molecule, pnode, part, box, box_ref, &
     drho_basis_info, rho0_basis_info, coef_pos, coef_vel, coef_force, &
     proj, pw_grid, thermo, potparm, empparm, ewald_param, box_change, &
     fc_global, lldata, simpar, debug)

  IMPLICIT NONE

! Arguments
  TYPE ( particle_type ), DIMENSION ( : ), INTENT ( INOUT ) :: part
  TYPE ( particle_node_type ), DIMENSION ( : ), INTENT ( INOUT ) :: pnode
  TYPE ( molecule_structure_type ), DIMENSION ( : ), INTENT ( IN ) :: molecule
  TYPE ( cell_type ), INTENT ( INOUT ) :: box
  TYPE ( cell_type ), INTENT ( IN ) :: box_ref
  TYPE ( kind_info_type ), POINTER, DIMENSION ( : ) :: drho_basis_info
  TYPE ( kind_info_type ), POINTER, DIMENSION ( : ) :: rho0_basis_info
  TYPE ( coeff_type ), INTENT (INOUT) :: coef_pos
  TYPE ( coeff_type ), INTENT (INOUT) :: coef_vel
  TYPE ( coeff_type ), INTENT (INOUT) :: coef_force
  TYPE ( coeff_type ), INTENT (INOUT) :: proj
  TYPE ( pw_grid_type ), INTENT (INOUT), TARGET :: pw_grid
  TYPE ( thermodynamic_type ), INTENT ( INOUT ) :: thermo
  TYPE ( potentialparm_type ), DIMENSION ( :,: ), INTENT ( IN ) :: potparm
  TYPE ( empirical_parameter_type ), DIMENSION ( : ), INTENT ( IN ) :: empparm
  TYPE ( ewald_parameters_type ), INTENT ( INOUT ) :: ewald_param
  LOGICAL, INTENT ( IN ) :: box_change
  TYPE ( global_environment_type ), INTENT ( IN ) :: fc_global
  TYPE ( linklist_internal_data_type), DIMENSION (:), INTENT (INOUT) :: lldata
  TYPE ( simulation_parameters_type ), intent (IN) :: simpar
  TYPE ( debug_variables_type ), INTENT ( OUT ), OPTIONAL :: debug

! Locals
  INTEGER :: id, i, ii, natoms, nnodes, handle, isos, ncoef
  INTEGER :: ng, igrid, ng_proj, ng_atom, nt_proj, nt_atom, npts_max ( 3 )
  INTEGER :: nproj
  REAL ( dbl ) :: pot_nonbond                                                
  REAL ( dbl ) :: pot_overlap, pot_electrostatics 
  REAL ( dbl ) :: pot_thk                                                
  REAL ( dbl ) :: e0, e1, e2                                                
  REAL ( dbl ) :: e_gsq                                                
  REAL ( dbl ), DIMENSION ( :,: ), ALLOCATABLE :: fe_part
  REAL ( dbl ), DIMENSION ( :,: ), ALLOCATABLE :: fo_part
  REAL ( dbl ), DIMENSION ( :,: ), ALLOCATABLE :: fthk_part
  COMPLEX ( dbl ), DIMENSION (:), ALLOCATABLE :: fe_coef
  COMPLEX ( dbl ), DIMENSION (:), ALLOCATABLE :: fo_coef
  COMPLEX ( dbl ), DIMENSION (:), ALLOCATABLE :: fthk_coef
  REAL ( dbl ), DIMENSION ( :,: ), ALLOCATABLE :: f_total
  REAL ( dbl ), DIMENSION ( 3,3 ) :: pv_nonbond
  LOGICAL :: first_time
  REAL ( dbl ) :: max_cut, cutoff_radius_max
  TYPE ( pol_projector_type ), ALLOCATABLE :: fproj_part ( : )
  

!------------------------------------------------------------------------------

  CALL timeset ( 'FORCE','I',' ',handle )

  nnodes = SIZE ( pnode )
  natoms = SIZE ( part )
  nproj = size ( proj % ao % cr )
  ncoef = size ( coef_pos % pw % cc )
  isos = 0
  pot_overlap = 0._dbl
  pot_electrostatics = 0._dbl
  e0 = 0._dbl
  e1 = 0._dbl
  e2 = 0._dbl
  pot_nonbond = 0._dbl
  pot_thk = 0

  first_time = .NOT. ALLOCATED ( f_nonbond )

  IF ( .NOT. ALLOCATED ( f_nonbond )  ) THEN
    ALLOCATE ( f_nonbond ( 3,natoms ), STAT = isos )
    IF ( isos /= 0 ) &
       CALL stop_memory ( 'force_control', 'f_nonbond', 3 * natoms )
  ELSE IF ( SIZE ( f_nonbond ( 1, : ) ) < natoms ) THEN
    DEALLOCATE ( f_nonbond, STAT = isos )
    IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'f_nonbond' )
    ALLOCATE ( f_nonbond ( 3, natoms ), STAT = isos )
    IF ( isos /= 0 ) &
       CALL stop_memory ( 'force_control', 'f_nonbond', 3 * natoms )
  END IF

  IF ( first_time.OR.box_change ) THEN
!
! Setting up PLANEWAVES
!
     coef_pos % pw % pw_grid => pw_grid

!
! Setting up double grids for ATOMICORBIALS
!

     CALL pol_grids_count ( drho_basis_info, rho0_basis_info, ng_proj, ng_atom, &
                             nt_proj, nt_atom )

     ng = ng_proj + ng_atom

     CALL pol_grids_allocate ( dg_proj, dg_atom, small_grid, big_grid, &
              nt_proj, nt_atom, ng ) 

     igrid = 0

     CALL pol_grids_map ( dg_proj, drho_basis_info, igrid )

     CALL pol_grids_map ( dg_atom, rho0_basis_info, igrid )

     CALL assign_coefs_to_grids ( proj % ao, part, drho_basis_info, nt_proj )

     CALL pol_grids_ref_grid ( dg_proj, dg_atom, drho_basis_info,  &
           rho0_basis_info, box, small_grid, big_grid, iref, npts_max, &
           cutoff_radius_max, max_cut )    

     CALL pol_grids_initialize ( dg_proj, dg_atom, part, pnode, proj % ao, &
            drho_basis_info, rho0_basis_info, fc_global,  box, &
            small_grid, big_grid, iref, npts_max, cutoff_radius_max, pw_grid )    
!
! Initializing green function to PW grid
!
     IF ( pw_grid % cutoff < big_grid ( iref ) % cutoff ) THEN
       WRITE ( *, * ) "PW CUTOFF = ",  pw_grid % cutoff
       WRITE ( *, * ) "REF CUTOFF = ", big_grid ( iref ) % cutoff
       CALL stop_program ( 'pol_force_pw', 'PW cutoff too small' )
     ENDIF
     WRITE ( *, '( A,T63,3I6 )' ) &
            ' NPOINTS REF GRID |  pw grid ',  pw_grid % npts  

     CALL pw_green_fn_init ( box % green, pw_grid )
!
! Initializing pw coefficients from scratch if needed
!
     IF (simpar%pol_read_type=='INIT') THEN
        SELECT CASE (simpar%pol_init_type)
        CASE DEFAULT
           CALL stop_program ( 'pol_force_pw', 'not implemented' )
        CASE ("AO")
! initialize coeffs with superposition of ao basis functions
           CALL initialize_coef_pw ( dg_proj, coef_pos % pw, part, box, small_grid,  &
                                     big_grid, ewald_param )
           DO i = 1, coef_pos % pw % pw_grid % ngpts_cut
              coef_pos % pw % cc (i) = box % deth * coef_pos % pw % cc (i)
              coef_pos % pw % cc (1) = CMPLX ( 0.0, 0 )
           END DO
        CASE ("GAUS")
! initialize coeffs with a gaussian
           DO i = 1, coef_pos % pw % pw_grid % ngpts_cut
              e_gsq = exp ( .25 *  coef_pos % pw % pw_grid % gsq ( i ) )
              coef_pos % pw % cc (i) = CMPLX ( e_gsq, 0 )
              coef_pos % pw % cc (1) = CMPLX ( 0.0, 0 )
           ENDDO
        END SELECT
     END IF
!
  END IF

! first check with list_control to update neighbor lists
!
  CALL list_control ( lldata ( 1 ), pnode, part, box )
!
! check to update the overlap neighbor list
!
  CALL list_control ( lldata ( 2 ), pnode, part, box, drho_basis_info )
 
!
! initial force, energy and pressure tensor arrays
!
  DO i = 1, natoms
     part ( i ) % f ( 1 ) = 0.0_dbl
     part ( i ) % f ( 2 ) = 0.0_dbl
     part ( i ) % f ( 3 ) = 0.0_dbl
  END DO
  coef_force % pw % cc ( : ) = 0.0_dbl
  thermo % pot = 0.0_dbl
  thermo % e_class = 0.0_dbl
  thermo % e_electro = 0.0_dbl
  thermo % e_electro_0 = 0.0_dbl
  thermo % e_electro_1 = 0.0_dbl
  thermo % e_electro_2 = 0.0_dbl
  thermo % e_overlap = 0.0_dbl
  thermo % e_thk = 0.0_dbl
  thermo % pv = 0.0_dbl

  IF ( .NOT. ALLOCATED ( fe_part )  ) &
         ALLOCATE ( fe_part ( 3, nnodes ), STAT=isos )
  IF ( isos /= 0 ) &
      CALL stop_memory ( 'force_control', 'fe_part', 3 * nnodes )

  IF ( .NOT. ALLOCATED ( fo_part )  ) &
         ALLOCATE ( fo_part ( 3, nnodes ), STAT=isos )
  IF ( isos /= 0 ) &
    CALL stop_memory ( 'force_control', 'fo_part',  3 * nnodes )

  IF ( .NOT. ALLOCATED ( fthk_part )  ) &
         ALLOCATE ( fthk_part ( 3, nnodes ), STAT=isos )
  IF ( isos /= 0 ) &
    CALL stop_memory ( 'force_control', 'fthk_part',  3 * nnodes )

  IF ( .NOT. ALLOCATED ( fproj_part )  ) &
         ALLOCATE ( fproj_part ( nproj ), STAT=isos )
  IF ( isos /= 0 ) &
    CALL stop_memory ( 'force_control', 'fproj_part',  nproj )

  IF ( .NOT. ALLOCATED ( fe_coef )  ) &
         ALLOCATE ( fe_coef ( ncoef ), STAT=isos )
  IF ( isos /= 0 ) &
    CALL stop_memory ( 'force_control', 'fe_coef',  ncoef )

  IF ( .NOT. ALLOCATED ( fo_coef )  ) &
         ALLOCATE ( fo_coef ( ncoef ), STAT=isos )
  IF ( isos /= 0 ) &
    CALL stop_memory ( 'force_control', 'fo_coef',  ncoef )

  IF ( .NOT. ALLOCATED ( fthk_coef )  ) &
         ALLOCATE ( fthk_coef ( ncoef ), STAT=isos )
  IF ( isos /= 0 ) &
    CALL stop_memory ( 'force_control', 'fthk_coef',  ncoef )
!DBG
!    do i = 1, nproj
!     proj% ao% norm (i) = 1
!    end do
!DBG
   
! get electrostatics forces   

    CALL electrostatics ( dg_atom, coef_pos % pw, part, box, small_grid, big_grid,  &
                          ewald_param, pot_electrostatics, e0, e1, e2, fe_coef, fe_part )
 
! get projectors and projector forces
   
    CALL projectors ( dg_proj, proj % ao, coef_pos % pw, part, box, small_grid,  &
                      big_grid, fproj_part ) 

! get overlap forces

     CALL force_overlap ( dg_proj, coef_pos % pw % pw_grid, proj % ao, drho_basis_info, &
                          part, pnode, box, empparm, small_grid, big_grid, pot_overlap, &
                         fo_coef, fo_part, fproj_part )

! get first order hk contribution

   CALL force_thk ( dg_proj, proj % ao, coef_pos % pw % pw_grid, part, box,  &
                    empparm, small_grid, big_grid, pot_thk, fthk_coef, fthk_part, &
                    fproj_part ) 

! get real-space non-bonded forces:
!
  f_nonbond = zero
  IF ( fc_global % program_name == 'POL' )  THEN
     CALL force_nonbond ( ewald_param, pnode, box, potparm, &
                         pot_nonbond, f_nonbond, pv_nonbond )
  END IF

!
! add up all the potential energies
!

! add up all the forces:
   DO i = 1, ncoef
     coef_force % pw % cc ( i )  = fo_coef ( i ) + fthk_coef ( i )  + fe_coef ( i )  
   END DO

! Nonbonded forces might be calculated for atoms not on this node
! electrostatic forces are strictly local -> sum only over pnode
! We first sum the forces in f_nonbond, this allows for a more efficient
! global sum in the parallel code and in the end copy them back to part

  isos = 0
  IF ( .NOT. ALLOCATED ( f_total ) ) ALLOCATE ( f_total ( 3,natoms ), STAT=isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'f_total', 3 * natoms )

  DO i = 1, natoms
     f_total ( 1, i ) = part ( i ) % f ( 1 ) + f_nonbond ( 1, i )
     f_total ( 2, i ) = part ( i ) % f ( 2 ) + f_nonbond ( 2, i )
     f_total ( 3, i ) = part ( i ) % f ( 3 ) + f_nonbond ( 3, i )
  END DO

  DO i = 1, nnodes
     ii = pnode ( i ) % p % iatom
     f_total ( 1, ii ) = f_total ( 1, ii ) + fe_part ( 1, i ) +  &
                         fo_part ( 1, i ) + fthk_part ( 1, i )
     f_total ( 2, ii ) = f_total ( 2, ii ) + fe_part ( 2, i ) +  &
                         fo_part ( 2, i ) + fthk_part ( 2, i )
     f_total ( 3, ii ) = f_total ( 3, ii ) + fe_part ( 3, i ) +  & 
                         fo_part ( 3, i ) + fthk_part ( 3, i )
  END DO

  IF ( PRESENT ( debug )  ) THEN
     debug % pot_electrostatics = pot_electrostatics
     debug % pot_overlap  = pot_overlap
     debug % pot_thk  = pot_thk
     debug % f_ovlp_part = fo_part
     debug % f_ovlp_coef = fo_coef
     debug % f_elec_part = fe_part
     debug % f_elec_coef = fe_coef
     debug % f_thk_part = fthk_part
     debug % f_thk_coef = fthk_coef
  END IF

  thermo % e_class = pot_nonbond
  thermo % e_electro = pot_electrostatics
  thermo % e_electro_0 = e0
  thermo % e_electro_1 = e1
  thermo % e_electro_2 = e2
  thermo % e_overlap = pot_overlap
  thermo % e_thk = pot_thk
  thermo % pot = pot_nonbond + pot_electrostatics + pot_overlap + pot_thk

#if defined ( __parallel )
  CALL mp_sum ( f_total, fc_global % group )
#endif

  DO i = 1, natoms
    part ( i ) % f ( 1 ) = f_total ( 1, i )
    part ( i ) % f ( 2 ) = f_total ( 2, i )
    part ( i ) % f ( 3 ) = f_total ( 3, i )
  END DO

! deallocating all local variables
  IF ( ALLOCATED ( f_total )  ) DEALLOCATE ( f_total, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'f_total' )
  IF ( ALLOCATED ( fe_coef )  ) DEALLOCATE ( fe_coef, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fe_coef' )
  IF ( ALLOCATED ( fo_coef )  ) DEALLOCATE ( fo_coef, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fo_coef' )
  IF ( ALLOCATED ( fe_part )  ) DEALLOCATE ( fe_part, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fe_part' )
  IF ( ALLOCATED ( fo_part )  ) DEALLOCATE ( fo_part, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fo_part' )
  IF ( ALLOCATED ( fthk_coef )  ) DEALLOCATE ( fthk_coef, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fthk_coef' )
  IF ( ALLOCATED ( fthk_part )  ) DEALLOCATE ( fthk_part, STAT = isos )
  IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fthk_part' )
  IF ( ALLOCATED ( fproj_part )  ) THEN 
     DEALLOCATE  ( fproj_part, STAT = isos )
     IF ( isos /= 0 ) CALL stop_memory ( 'force_control', 'fproj_part' )
  END IF

  CALL timestop ( zero, handle )

END SUBROUTINE force_control

!******************************************************************************
!!****** pol_force_pw/get_pol_grids [1.0] *
!!
!!   NAME
!!     get_pol_grids
!!
!!   SOURCE
!******************************************************************************

SUBROUTINE get_pol_grids ( pw_big, pw_small, dg1, dg2, ii )
  IMPLICIT NONE
  TYPE ( pw_grid_type ), POINTER, DIMENSION ( : ), OPTIONAL :: pw_big
  TYPE ( pw_grid_type ), POINTER, DIMENSION ( : ), OPTIONAL :: pw_small
  TYPE ( dg_type ), POINTER, DIMENSION ( : ), OPTIONAL :: dg1
  TYPE ( dg_type ), POINTER, DIMENSION ( : ), OPTIONAL :: dg2
  INTEGER, INTENT ( OUT ), OPTIONAL :: ii
  
  IF ( PRESENT ( pw_big ) ) pw_big  => big_grid 
  IF ( PRESENT ( pw_small ) ) pw_small => small_grid 
  IF ( PRESENT ( dg1 ) ) dg1 => dg_atom 
  IF ( PRESENT ( dg2 ) ) dg2 => dg_proj 
  IF ( PRESENT ( ii ) ) ii = iref

END SUBROUTINE get_pol_grids
!!*****
!******************************************************************************
END MODULE pol_force_pw
!******************************************************************************
