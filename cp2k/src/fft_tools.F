!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2008  CP2K developers group                          !
!-----------------------------------------------------------------------------!

! *****************************************************************************
!> \par History
!>      JGH (30-Nov-2000): ESSL FFT Library added
!>      JGH (05-Jan-2001): Added SGI library FFT
!>      JGH (14-Jan-2001): Added parallel 3d FFT
!>      JGH (10-Feb-2006): New interface type
!> \author JGH
! *****************************************************************************
MODULE fft_tools

  USE cp_files,                        ONLY: get_unit_number
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE f77_blas
  USE kinds,                           ONLY: dp,&
                                             sp
  USE message_passing,                 ONLY: &
       mp_alltoall, mp_cart_coords, mp_cart_rank, mp_cart_sub, &
       mp_comm_compare, mp_comm_free, mp_environ, mp_rank_compare, mp_sum
  USE termination,                     ONLY: stop_memory,&
                                             stop_program
  USE timings,                         ONLY: timeset,&
                                             timestop
#include "cp_common_uses.h"

  IMPLICIT NONE 
  
  PRIVATE
  PUBLIC :: init_fft, fft3d, finalize_fft
  PUBLIC :: fft_radix_operations
  PUBLIC :: FWFFT, BWFFT
  PUBLIC :: FFT_RADIX_CLOSEST, FFT_RADIX_NEXT, FFT_RADIX_ALLOWED
  PUBLIC :: FFT_RADIX_DISALLOWED, FFT_RADIX_NEXT_ODD
  
  INTEGER, PARAMETER :: FWFFT = +1, BWFFT = -1
  INTEGER, PARAMETER :: FFT_RADIX_CLOSEST = 493, FFT_RADIX_NEXT = 494
  INTEGER, PARAMETER :: FFT_RADIX_ALLOWED = 495, FFT_RADIX_DISALLOWED = 496
  INTEGER, PARAMETER :: FFT_RADIX_NEXT_ODD = 497
 
  ! these saved variables are FFT globals
  INTEGER, SAVE :: fft_type = 0
  LOGICAL, SAVE :: alltoall_sgl = .FALSE.
  LOGICAL, SAVE :: use_fftsg_sizes = .TRUE.

  INTERFACE fft3d
     MODULE PROCEDURE fft3d_s, fft3d_ps, fft3d_pb
  END INTERFACE

#if defined(__FFTSGL)
  INTEGER, PARAMETER :: lp = sp
#else
  INTEGER, PARAMETER :: lp = dp
#endif

CONTAINS

! *****************************************************************************
!> \author JGH
! *****************************************************************************
SUBROUTINE init_fft ( fftlib, alltoall, fftsg_sizes, wisdom_file, para_env )

    CHARACTER(LEN=*), INTENT(IN)             :: fftlib
    LOGICAL, INTENT(IN)                      :: alltoall, fftsg_sizes
    CHARACTER(LEN=*), INTENT(IN)             :: wisdom_file
    TYPE(cp_para_env_type), POINTER          :: para_env

    INTEGER                                  :: fft_library, istat, isuccess, &
                                                iunit
    LOGICAL                                  :: exist

    use_fftsg_sizes = fftsg_sizes
    alltoall_sgl = alltoall
    fft_type = fft_library ( fftlib )
    IF ( fft_type <= 0 ) &
         CALL stop_program ("init_fft","Unknown FFT library: "//TRIM(fftlib))

    ! only do FFTW3 related stuff right now
    ! note that the library might not actually be available
    ! all nodes are opening the file here...
    IF (fft_library ( "FFTW3" ) == fft_type) THEN
        INQUIRE(FILE=wisdom_file,exist=exist)
        IF (exist) THEN
           iunit=get_unit_number()           
           OPEN(UNIT=iunit,FILE=wisdom_file,STATUS="OLD",FORM="FORMATTED",POSITION="REWIND",ACTION="READ",IOSTAT=istat)
           IF (istat==0) THEN
              CALL fftw_import_wisdom_from_file(isuccess,iunit)
              ! write(6,*) "FFTW3 import wisdom from file ....",MERGE((/"OK    "/),(/"NOT OK"/),(/isuccess==1/))
              CLOSE(iunit)
           ENDIF
        ENDIF
    ENDIF

END SUBROUTINE init_fft

! *****************************************************************************
!> \brief does whatever is needed to finalize the current fft setup
!> \par History
!>      10.2007 created [Joost VandeVondele]
! *****************************************************************************
SUBROUTINE finalize_fft( para_env )
    TYPE(cp_para_env_type), POINTER          :: para_env

    INTEGER                                  :: fft_library, iunit

! we don't want to use this yet, it is only meaningful if we really plan with something else than estimate

    RETURN
    ! only do FFTW3 related stuff right now
    ! note that the library might not actually be available
    IF (fft_library ( "FFTW3" ) == fft_type) THEN
        ! only the ionode updates the wisdom
        IF (para_env%ionode) THEN
           iunit=get_unit_number()           
           OPEN(UNIT=iunit,FILE="fftw_wisdom.dat",STATUS="UNKNOWN",FORM="FORMATTED",ACTION="WRITE")
           CALL fftw_export_wisdom_to_file(iunit)
           CLOSE(iunit)
        ENDIF
    ENDIF

END SUBROUTINE finalize_fft

! *****************************************************************************
!> \brief Determine the allowed lengths of FFT's   '''
!> \par History
!>      new library structure (JGH)
!> \author Ari Seitsonen
! *****************************************************************************
SUBROUTINE fft_radix_operations ( radix_in, radix_out, operation )

    INTEGER, INTENT(IN)                      :: radix_in
    INTEGER, INTENT(OUT)                     :: radix_out
    INTEGER, INTENT(IN)                      :: operation

    INTEGER, PARAMETER                       :: fft_type_sg = 1

    INTEGER                                  :: i, iloc, ldata
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: DATA

!------------------------------------------------------------------------------

  ldata = 1024
  ALLOCATE ( DATA(ldata) )
  DATA = -1

  ! if the user wants to use fftsg sizes go for it
  IF (use_fftsg_sizes) THEN
      CALL fft_get_lengths ( fft_type_sg, DATA, ldata )
  ELSE
      CALL fft_get_lengths ( fft_type, DATA, ldata )
  ENDIF

  iloc = 0
  DO i = 1, ldata
     IF ( DATA ( i ) == radix_in ) THEN
        iloc = i
        EXIT
     ELSE
        IF ( OPERATION == FFT_RADIX_ALLOWED ) THEN
           CYCLE
        ELSE IF ( DATA ( i ) > radix_in ) THEN
           iloc = i
           EXIT
        END IF
     END IF
  END DO

  IF ( iloc == 0 ) THEN
     CALL stop_program ( "fft_radix_operations",&
                         "index to radix array not found" )
  END IF

  IF ( OPERATION == FFT_RADIX_ALLOWED ) THEN
     IF ( DATA ( iloc ) == radix_in ) THEN
        radix_out = FFT_RADIX_ALLOWED
     ELSE
        radix_out = FFT_RADIX_DISALLOWED
     END IF

  ELSE IF ( OPERATION == FFT_RADIX_CLOSEST ) THEN
     IF ( DATA ( iloc ) == radix_in ) THEN
        radix_out = DATA ( iloc )
     ELSE
        IF ( ABS ( DATA ( iloc - 1 ) - radix_in ) <= &
             ABS ( DATA ( iloc ) - radix_in ) ) THEN
           radix_out = DATA ( iloc - 1 )
        ELSE
           radix_out = DATA ( iloc )
        END IF
     END IF

  ELSE IF ( OPERATION == FFT_RADIX_NEXT ) THEN
     radix_out = DATA ( iloc )

  ELSE IF ( OPERATION == FFT_RADIX_NEXT_ODD ) THEN
     DO i = iloc, ldata
       IF ( MOD ( DATA ( i ), 2 ) == 1 ) THEN
         radix_out = DATA ( i )
         EXIT
       END IF
     END DO
     IF ( MOD ( radix_out, 2 ) == 0 ) THEN
        CALL stop_program ( "fft_radix_operations", "no odd radix found" )
     END IF
     
  ELSE
     CALL stop_program ( "fft_radix_operations",&
                         "disallowed radix operation" )
  END IF

  DEALLOCATE(DATA) 
  
END SUBROUTINE fft_radix_operations

! *****************************************************************************
!> \brief Calls the 3D-FFT function from the initialized library
!> \par History
!>      none
!> \author JGH
! *****************************************************************************
SUBROUTINE fft3d_s ( fsign, n, zin, zout, scale, status, debug )

    INTEGER, INTENT(IN)                      :: fsign
    INTEGER, DIMENSION(:), INTENT(INOUT)     :: n
    COMPLEX(KIND=dp), DIMENSION(:, :, :), &
      INTENT(INOUT)                          :: zin
    COMPLEX(KIND=dp), DIMENSION(:, :, :), &
      INTENT(INOUT), OPTIONAL, TARGET        :: zout
    REAL(KIND=dp), INTENT(IN), OPTIONAL      :: scale
    INTEGER, INTENT(OUT), OPTIONAL           :: status
    LOGICAL, INTENT(IN), OPTIONAL            :: debug

    COMPLEX(KIND=lp), DIMENSION(1, 1, 1), &
      TARGET                                 :: zdum
    COMPLEX(KIND=lp), DIMENSION(:, :, :), &
      POINTER                                :: zoptr
    INTEGER                                  :: handle, ierr, ld(3), lo(3), &
                                                sign
    LOGICAL                                  :: fft_in_place, test
    REAL(KIND=dp)                            :: flops, in_sum, nx, out_sum
    REAL(KIND=lp)                            :: norm

!------------------------------------------------------------------------------

  CALL timeset("fft3d_s","I","Gflops",handle)

  IF ( PRESENT ( scale ) ) THEN
    norm = scale
  ELSE
    norm = 1.0_lp
  END IF

  IF ( PRESENT ( debug ) ) THEN
    test = debug
  ELSE
    test = .FALSE.
  END IF

  IF ( PRESENT ( zout ) ) THEN
    fft_in_place = .FALSE.
  ELSE
    fft_in_place = .TRUE.
  END IF

  IF ( test ) THEN
    in_sum = SUM ( ABS ( zin ) )
  ENDIF

  ld ( 1 ) = SIZE ( zin ,1 )
  ld ( 2 ) = SIZE ( zin ,2 )
  ld ( 3 ) = SIZE ( zin ,3 )

  IF ( n(1) /= ld(1) .OR. n(2) /= ld(2) .OR. n(3) /= ld(3) ) THEN
    CALL stop_program("fft3d","Size and dimension (zin) have to be the same")
  END IF

  sign = fsign
#if defined(__FFTSGL)
  ALLOCATE ( zoptr ( n(1), n(2), n(3) ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "zoptr", n(1)*n(2)*n(3) )

  zoptr(:,:,:) = zin(:,:,:)
  CALL fft_3d ( fft_type, .TRUE., sign, norm, n, zoptr, zoptr )
  IF ( fft_in_place ) THEN
    zin(:,:,:) = zoptr(:,:,:)
  ELSE
    zout(:,:,:) = zoptr(:,:,:)
  END IF

  DEALLOCATE ( zoptr, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "zoptr" )
#else
  IF ( fft_in_place ) THEN
    zoptr => zdum
  ELSE
    zoptr => zout
  END IF
  CALL fft_3d ( fft_type, fft_in_place, sign, norm, n, zin, zoptr )
#endif

  IF ( PRESENT ( zout ) ) THEN
    lo ( 1 ) = SIZE ( zout ,1 )
    lo ( 2 ) = SIZE ( zout ,2 )
    lo ( 3 ) = SIZE ( zout ,3 )
    IF ( n(1) /= lo(1) .OR. n(2) /= lo(2) .OR. n(3) /= lo(3) ) THEN
      CALL stop_program("fft3d","Size and dimension (zout) have to be the same")
    END IF
  END IF

  IF ( PRESENT ( status ) ) THEN
    IF ( sign == 0 ) THEN
      status = 1
    ELSE
      status = 0
    END IF
  END IF

  IF ( test ) THEN
    IF ( PRESENT ( zout ) ) THEN
      out_sum = SUM ( ABS ( zout ) )
      WRITE ( *, '(A)') "  Out of place 3D FFT (local)  : fft3d_s"
      WRITE ( *, '(A,T60,3I7)') "     Transform lengths ",n
      WRITE ( *, '(A,T60,3I7)') "     Input array dimensions ",ld
      WRITE ( *, '(A,T60,3I7)') "     Output array dimensions ",lo
      WRITE ( *, '(A,T61,E20.14)') "     Sum of input data ",in_sum
      WRITE ( *, '(A,T61,E20.14)') "     Sum of output data ",out_sum
    ELSE
      out_sum = SUM ( ABS ( zin ) )
      WRITE ( *, '(A)') "  In place 3D FFT (local)  : fft3d_s"
      WRITE ( *, '(A,T60,3I7)') "     Transform lengths ",n
      WRITE ( *, '(A,T60,3I7)') "     Input/output array dimensions ",ld
      WRITE ( *, '(A,T61,E20.14)') "     Sum of input data ",in_sum
      WRITE ( *, '(A,T61,E20.14)') "     Sum of output data ",out_sum
    END IF
  END IF

  ! definition used with FFTW
  nx = 5.e-9_dp * REAL ( n(1)*n(2)*n(3),KIND=dp)
  flops = nx * LOG ( REAL ( n(1)*n(2)*n(3),KIND=dp) ) / LOG ( 2.0_dp )
  CALL timestop(flops,handle)

END SUBROUTINE fft3d_s

! *****************************************************************************
SUBROUTINE fft3d_ps ( fsign, n, cin, gin, gs_group, rs_group, yzp, nyzray, &
                      bo, scale, status, debug )

    INTEGER, INTENT(IN)                      :: fsign
    INTEGER, DIMENSION(:), INTENT(IN)        :: n
    COMPLEX(KIND=dp), DIMENSION(:, :, :), &
      INTENT(INOUT)                          :: cin
    COMPLEX(KIND=dp), DIMENSION(:, :), &
      INTENT(INOUT)                          :: gin
    INTEGER, INTENT(IN)                      :: gs_group, rs_group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: yzp
    INTEGER, DIMENSION(0:), INTENT(IN)       :: nyzray
    INTEGER, DIMENSION(:, :, 0:, :), &
      INTENT(IN)                             :: bo
    REAL(KIND=dp), INTENT(IN), OPTIONAL      :: scale
    INTEGER, INTENT(OUT), OPTIONAL           :: status
    LOGICAL, INTENT(IN), OPTIONAL            :: debug

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: pbuf, qbuf, rbuf, sbuf
    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :, :)                     :: tbuf
    INTEGER :: g_pos, handle, ierr, iout, lg, lmax, mg, mmax, mx1, mx2, my1, &
      mz2, numtask, numtask_g, numtask_r, nx, ny, nz, r_dim(2), r_pos(2), rp, &
      sign
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: p2p
    LOGICAL                                  :: test
    REAL(KIND=dp)                            :: flops, nf, sum_data
    REAL(KIND=lp)                            :: norm

!------------------------------------------------------------------------------

  CALL timeset("fft3d_ps","I","Gflops",handle)

  IF ( PRESENT ( debug ) ) THEN
    test = debug
  ELSE
    test = .FALSE.
  END IF

  CALL mp_environ ( numtask_g, g_pos, gs_group )
  CALL mp_environ ( numtask_r, r_dim, r_pos, rs_group )
  IF ( numtask_g /= numtask_r ) THEN
    CALL stop_program ( "fft3d", "Real space and G space groups are different")
  END IF
  numtask = numtask_r
  CALL mp_comm_compare ( rs_group, gs_group, iout )
  IF ( iout >3 ) THEN
    CALL stop_program("fft3d","Real space and G space groups are different")
  END IF

  IF ( PRESENT ( scale ) ) THEN
    norm = scale
  ELSE
    norm = 1.0_lp
  END IF

  sign = fsign

  lg = SIZE ( gin ,1 )
  mg = SIZE ( gin ,2 )

  nx = SIZE ( cin ,1 )
  ny = SIZE ( cin ,2 )
  nz = SIZE ( cin ,3 )

  ALLOCATE ( p2p ( 0 : numtask - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "p2p", numtask )
    
  CALL mp_rank_compare ( gs_group, rs_group, p2p )

  rp = p2p ( g_pos )
  mx1 = bo ( 2, 1, rp, 1 ) - bo ( 1, 1, rp, 1 ) + 1
  my1 = bo ( 2, 2, rp, 1 ) - bo ( 1, 2, rp, 1 ) + 1
  mx2 = bo ( 2, 1, rp, 2 ) - bo ( 1, 1, rp, 2 ) + 1
  mz2 = bo ( 2, 3, rp, 2 ) - bo ( 1, 3, rp, 2 ) + 1

  IF ( test ) THEN
    IF ( g_pos == 0 ) THEN
      WRITE ( *, '(A)') "  Parallel 3D FFT : fft3d_ps"
      WRITE ( *, '(A,T60,3I7)') "     Transform lengths ",n
      WRITE ( *, '(A,T67,2I7)') "     Array dimensions (gin) ",lg,mg
      WRITE ( *, '(A,T60,3I7)') "     Array dimensions (cin) ",nx,ny,nz
    END IF
  END IF

  IF ( r_dim ( 2 ) > 1 ) THEN

    !
    ! real space is distributed over x and y coordinate
    ! we have two stages of communication
    !

    IF ( r_dim ( 1 ) == 1 ) THEN
      CALL stop_program ( "fft3d", "This processor distribution is not supported" )
    END IF

    IF ( sign == FWFFT ) THEN
      ! cin -> gin

      IF ( test ) THEN
        sum_data = ABS ( SUM ( cin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A)') "  Two step communication algorithm "
          WRITE ( *, '(A,T60,3I7)') "     Transform Z ",n(3),mx1*my1
          WRITE ( *, '(A,T60,3I7)') "     Transform Y ",n(2),mx2*mz2
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),nyzray(g_pos)
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      ALLOCATE ( pbuf ( mx1*my1, n(3) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf", n(3)*mx1*my1 )
      ALLOCATE ( qbuf ( n(3), mx1*my1 ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf", n(3)*mx1*my1 )

      ! FFT along z
      pbuf = RESHAPE(cin,SHAPE(pbuf))
      CALL fft_1dm ( fft_type, sign, .TRUE., n(3), mx1*my1, pbuf, qbuf, norm )

      DEALLOCATE ( pbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf" )
      ALLOCATE ( rbuf ( mx2*mz2, n(2) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf", n(2)*mx2*mz2 )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( qbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) T",sum_data
        END IF
      END IF

     ! Exchange data ( transpose of matrix )
      CALL cube_transpose_2 ( qbuf, rs_group, bo ( :, :, :, 1 ), &
                            bo ( :, :, :, 2 ), rbuf )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( rbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) T",sum_data
        END IF
      END IF

      DEALLOCATE ( qbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf" )
      ALLOCATE ( pbuf ( n(2), mx2*mz2 ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf", mx2*mz2*n(2) )

      ! FFT along y
      CALL fft_1dm ( fft_type, sign, .TRUE., n(2), mx2*mz2, rbuf, pbuf, 1.0_lp )

      DEALLOCATE ( rbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf" )
      ALLOCATE ( qbuf ( nyzray ( g_pos ), n(1) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf", nyzray ( g_pos )*n(1) )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( pbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) TS",sum_data
        END IF
      END IF

      ! Exchange data ( transpose of matrix ) and sort
      CALL xz_to_yz ( pbuf, rs_group, r_dim, g_pos, p2p, yzp, nyzray, &
                      bo ( :, : , 0: , 2 ), qbuf )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( qbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(5) TS",sum_data
        END IF
      END IF

      DEALLOCATE ( pbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf" )

      ! FFT along x
#if defined(__FFTSGL)
      ALLOCATE ( pbuf ( lg, mg ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf", lg*mg )

      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     qbuf, pbuf, 1.0_lp )
      gin(:,:) = pbuf(:,:)

      DEALLOCATE ( pbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf" )
#else
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     qbuf, gin, 1.0_lp )
#endif

      DEALLOCATE ( qbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf" )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(6) ",sum_data
        END IF
      END IF

    ELSE IF ( sign == BWFFT ) THEN
      ! gin -> cin

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A)') "  Two step communication algorithm "
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),nyzray(g_pos)
          WRITE ( *, '(A,T60,3I7)') "     Transform Y ",n(2),mx2*mz2
          WRITE ( *, '(A,T60,3I7)') "     Transform Z ",n(3),mx1*my1
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      ALLOCATE ( pbuf ( mg, lg ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf", lg*mg )

      ! FFT along x
#if defined(__FFTSGL)
      ALLOCATE ( qbuf ( lg, mg ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf", lg*mg )

      qbuf = gin

      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     qbuf, pbuf, norm )

      DEALLOCATE ( qbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf" )
#else
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     gin, pbuf, norm )
#endif

      ALLOCATE ( qbuf ( n ( 2 ), mx2*mz2 ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf", n(2)*mx2*mz2 )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( pbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) TS",sum_data
        END IF
      END IF

      ! Exchange data ( transpose of matrix ) and sort
      CALL yz_to_xz ( pbuf, rs_group, r_dim, g_pos, p2p, yzp, nyzray, &
                      bo ( :, : , : , 2 ), qbuf )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( qbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) TS",sum_data
        END IF
      END IF

      DEALLOCATE ( pbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf" )
      ALLOCATE ( rbuf ( mx2*mz2, n ( 2 ) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf", n ( 2 ) * mx2*mz2 )

      ! FFT along y
      CALL fft_1dm ( fft_type, sign, .TRUE., n(2), mx2*mz2, qbuf, rbuf, 1.0_lp )

      DEALLOCATE ( qbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf" )
      ALLOCATE ( pbuf ( n(3), mx1*my1 ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf", n(3)*mx1*my1 )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( rbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) T",sum_data
        END IF
      END IF

      ! Exchange data ( transpose of matrix )
      CALL cube_transpose_1 ( rbuf, rs_group, bo ( :, :, :, 2 ), &
                            bo ( :, :, :, 1 ), pbuf )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( pbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(5) T",sum_data
        END IF
      END IF

      DEALLOCATE ( rbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf" )
      ALLOCATE ( qbuf ( mx1*my1, n(3) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf", mx1*my1*n(3) )

      ! FFT along z
      CALL fft_1dm ( fft_type, sign, .TRUE., n(3), mx1*my1, pbuf, qbuf, 1.0_lp )
#if defined(__FFTSGL) && defined(__NAG)
      CALL copy_cz(n(3)*mx1*my1,qbuf,cin)
#else
      cin = RESHAPE(qbuf,SHAPE(cin))
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( cin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(6) ",sum_data
        END IF
      END IF

      DEALLOCATE ( qbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "qbuf" )
      DEALLOCATE ( pbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "pbuf" )

    ELSE

      CALL stop_program ( "fft3d", "Illegal fsign parameter" )

    ENDIF

  ELSE

    !
    ! real space is only distributed over x coordinate
    ! we have one stage of communication, after the transform of
    ! direction x
    !

    IF ( mg == 0 ) THEN
      mmax = 1
    ELSE
      mmax = mg
    END IF
    lmax = MAX ( lg, (nx*ny*nz)/mmax + 1 )

    ALLOCATE ( sbuf ( mmax, lmax ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "sbuf", mmax*lmax )

    ALLOCATE ( tbuf ( ny, nz, nx ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "tbuf", nx*ny*nz )

    IF ( sign == FWFFT ) THEN
      ! cin -> gin
      
      IF ( test ) THEN
        sum_data = ABS ( SUM ( cin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A)') "     One step communication algorithm "
          WRITE ( *, '(A,T60,3I7)') "     Transform YZ ",n(2),n(3),nx
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),nyzray(g_pos)
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      ! FFT along y and z
#if defined(__FFTSGL)
      tbuf = RESHAPE(cin,SHAPE(tbuf))
      CALL fft_1dm ( fft_type, sign, .TRUE., nz, nx*ny, tbuf, sbuf, 1._lp )
      CALL fft_1dm ( fft_type, sign, .TRUE., ny, nx*nz, sbuf, tbuf, 1._lp )
#else
      CALL fft_1dm ( fft_type, sign, .TRUE., nz, nx*ny, cin, sbuf, 1._lp )
      CALL fft_1dm ( fft_type, sign, .TRUE., ny, nx*nz, sbuf, tbuf, 1._lp )
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( tbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) TS",sum_data
        END IF
      END IF

      ! Exchange data ( transpose of matrix ) and sort
      CALL yz_to_x ( tbuf, gs_group, g_pos, p2p, yzp, nyzray, &
                     bo ( :, :, :, 2 ), sbuf )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( sbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) TS",sum_data
        END IF
      END IF

      ! FFT along x
#if defined(__FFTSGL)
      ALLOCATE ( rbuf ( lg, mg ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf", lg*mg )
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     sbuf, rbuf, norm )
      gin = rbuf
      DEALLOCATE ( rbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf" )
#else
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     sbuf, gin, norm )
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) ",sum_data
        END IF
      END IF

    ELSE IF ( sign == BWFFT ) THEN
      ! gin -> cin      

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A)') "  One step communication algorithm "
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),nyzray(g_pos)
          WRITE ( *, '(A,T60,3I7)') "     Transform YZ ",n(2),n(3),nx
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      ! FFT along x
#if defined(__FFTSGL)
      ALLOCATE ( rbuf ( lg, mg ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf", lg*mg )
      rbuf = gin
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     rbuf, sbuf, norm )
      DEALLOCATE ( rbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "rbuf" )
#else
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), nyzray(g_pos), &
                     gin, sbuf, norm )
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( sbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) TS",sum_data
        END IF
      END IF

      ! Exchange data ( transpose of matrix ) and sort
      CALL x_to_yz ( sbuf, gs_group, g_pos, p2p, yzp, nyzray, &
                     bo ( :, :, :, 2 ), tbuf )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( tbuf ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) TS",sum_data
        END IF
      END IF

      ! FFT along y and z
#if defined(__FFTSGL)
      CALL fft_1dm ( fft_type, sign, .TRUE., ny, nx*nz, tbuf, sbuf, 1._lp )
      CALL fft_1dm ( fft_type, sign, .TRUE., nz, nx*ny, sbuf, tbuf, 1._lp )
#if defined(__NAG)
      CALL copy_cz(nx*ny*nz,tbuf,cin)
#else
      cin = RESHAPE(tbuf,SHAPE(cin))
#endif
#else
      CALL fft_1dm ( fft_type, sign, .TRUE., ny, nx*nz, tbuf, sbuf, 1._lp )
      CALL fft_1dm ( fft_type, sign, .TRUE., nz, nx*ny, sbuf, cin, 1._lp )
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( cin ) )
        CALL mp_sum ( sum_data, gs_group )
        IF ( g_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) ",sum_data
        END IF
      END IF

    ELSE
      CALL stop_program ( "fft3d", "Illegal fsign parameter" )
    ENDIF

    DEALLOCATE ( tbuf, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "tbuf" ) 
    DEALLOCATE ( sbuf, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "sbuf" )
  
  ENDIF

  DEALLOCATE ( p2p, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "p2p" )

  IF ( PRESENT ( status ) ) THEN
    IF ( sign == 0 ) THEN
      status = 1
    ELSE
      status = 0
    END IF
  END IF

  nf = 5.e-6_dp * REAL ( n(1)*n(2)*n(3),KIND=dp)
  flops = nf * LOG ( REAL ( n(1)*n(2)*n(3),KIND=dp) ) / LOG ( 2.0_dp) ! FFTW definition
  flops = 1.0e-3_dp*flops/numtask_r  ! per cpu
  CALL timestop(flops,handle)

END SUBROUTINE fft3d_ps

! *****************************************************************************
SUBROUTINE fft3d_pb ( fsign, n, zin, gin, group, bo, scale, status, debug )

    INTEGER, INTENT(IN)                      :: fsign
    INTEGER, DIMENSION(3), INTENT(IN)        :: n
    COMPLEX(KIND=dp), DIMENSION(:, :, :), &
      INTENT(INOUT)                          :: zin
    COMPLEX(KIND=dp), DIMENSION(:, :), &
      INTENT(INOUT)                          :: gin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:, :), &
      INTENT(IN)                             :: bo
    REAL(KIND=dp), INTENT(IN), OPTIONAL      :: scale
    INTEGER, INTENT(OUT), OPTIONAL           :: status
    LOGICAL, INTENT(IN), OPTIONAL            :: debug

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: abuf, bbuf
    INTEGER                                  :: handle, ierr, lg(2), lz(3), &
                                                mx, my, my_pos, mz, np, sign
    INTEGER, DIMENSION(2)                    :: dim, pos
    LOGICAL                                  :: test
    REAL(KIND=dp)                            :: flops, nx, sum_data
    REAL(KIND=lp)                            :: norm

!------------------------------------------------------------------------------
! "Real Space"  1) xyZ      or      1) xYZ
!               2) xYz      or         not used
! "G Space"     3) Xyz      or      3) XYz
!
! There is one communicator (2-dimensional) for all distributions
! np = n1 * n2, where np is the total number of processors
! If n2 = 1, we have the second case and only one transpose step is needed
! 
! Assignment of dimensions to axis for different steps
! First case: 1) n1=x; n2=y
!             2) n1=x; n2=z
!             3) n1=y; n2=z
! Second case 1) n1=x
!             3) n1=z
!
! The more general case with two communicators for the initial and final
! distribution is not covered.
!------------------------------------------------------------------------------

  CALL timeset("fft3d_pb","I","Gflops",handle)

  CALL mp_environ ( np, dim, pos, group )
  CALL mp_cart_rank ( group, pos, my_pos )

  IF ( PRESENT ( debug ) ) THEN
    test = debug
  ELSE
    test = .FALSE.
  END IF

  IF ( PRESENT ( scale ) ) THEN
    norm = scale
  ELSE
    norm = 1.0_lp
  END IF

  sign = fsign

  IF ( test ) THEN
    lg ( 1 ) = SIZE ( gin ,1 )
    lg ( 2 ) = SIZE ( gin ,2 )
    lz ( 1 ) = SIZE ( zin ,1 )
    lz ( 2 ) = SIZE ( zin ,2 )
    lz ( 3 ) = SIZE ( zin ,3 )
    IF ( my_pos == 0 ) THEN
      WRITE ( *, '(A)') "  Parallel 3D FFT : fft3d_pb"
      WRITE ( *, '(A,T60,3I7)') "     Transform lengths ",n
      WRITE ( *, '(A,T67,2I7)') "     Array dimensions (gin) ",lg
      WRITE ( *, '(A,T60,3I7)') "     Array dimensions (cin) ",lz
    END IF
  END IF

  IF ( DIM ( 1 ) > 1 .AND. DIM ( 2 ) > 1 ) THEN

    !
    ! First case; two stages of communication
    !

    IF ( sign == FWFFT ) THEN
      ! Stage 1 -> 3

      mx = bo ( 2, 1, my_pos, 1 ) - bo ( 1, 1, my_pos, 1 ) + 1
      my = bo ( 2, 2, my_pos, 1 ) - bo ( 1, 2, my_pos, 1 ) + 1
      ALLOCATE ( abuf ( mx*my, n(3) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", mx*my*n(3) )
      ALLOCATE ( bbuf ( n(3), mx*my ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(3)*mx*my )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( zin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A)') "  Two step communication algorithm "
          WRITE ( *, '(A,T67,2I7)') "     Transform Z ",n(3),mx*my
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      abuf = RESHAPE(zin,SHAPE(abuf))

      ! FFT along z
      CALL fft_1dm ( fft_type, sign, .TRUE., n(3), mx*my, abuf, bbuf, norm )

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      mx = bo ( 2, 1, my_pos, 2 ) - bo ( 1, 1, my_pos, 2 ) + 1
      mz = bo ( 2, 3, my_pos, 2 ) - bo ( 1, 3, my_pos, 2 ) + 1
      ALLOCATE ( abuf ( mx*mz, n(2) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", mx*mz*n(2) )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( bbuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) T",sum_data
        END IF
      END IF

      CALL cube_transpose_2 ( bbuf, group, bo(:,:,:,1), bo(:,:,:,2), abuf )

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( n(2), mx*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", mx*mz*n(2) )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( abuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T67,2I7)') "     Transform Y ",n(2),mx*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) ",sum_data
        END IF
      END IF

      ! FFT along y
      CALL fft_1dm ( fft_type, sign, .TRUE., n(2), mx*mz, abuf, bbuf, 1.0_lp )

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      my = bo ( 2, 2, my_pos, 3 ) - bo ( 1, 2, my_pos, 3 ) + 1
      mz = bo ( 2, 3, my_pos, 3 ) - bo ( 1, 3, my_pos, 3 ) + 1
      ALLOCATE ( abuf ( my*mz, n(1) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", my*mz*n(1) )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( bbuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) T",sum_data
        END IF
      END IF

      CALL cube_transpose_4 ( bbuf, group, bo(:,:,:,2), bo(:,:,:,3), abuf )

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( n(1), my*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", mx*my*n(1) )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( abuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),my*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(5) ",sum_data
        END IF
      END IF

      ! FFT along x
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), my*mz, abuf, bbuf, 1.0_lp )

#if defined(__FFTSGL) && defined(__NAG)
      CALL copy_cz(n(1)*my*mz,bbuf,gin)
#else
      gin = RESHAPE(bbuf,SHAPE(gin))
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(6) ",sum_data
        END IF
      END IF

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )

    ELSEIF ( sign == BWFFT ) THEN
      ! Stage 3 -> 1

      my = bo ( 2, 2, my_pos, 3 ) - bo ( 1, 2, my_pos, 3 ) + 1
      mz = bo ( 2, 3, my_pos, 3 ) - bo ( 1, 3, my_pos, 3 ) + 1
      ALLOCATE ( abuf ( n(1), my*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(1)*my*mz )
      ALLOCATE ( bbuf ( my*mz, n(1) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(1)*my*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A)') "  Two step communication algorithm "
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),my*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      abuf = RESHAPE(gin,SHAPE(abuf))

      ! FFT along x
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), my*mz, abuf, bbuf, 1.0_lp )

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      mx = bo ( 2, 1, my_pos, 2 ) - bo ( 1, 1, my_pos, 2 ) + 1
      mz = bo ( 2, 3, my_pos, 2 ) - bo ( 1, 3, my_pos, 2 ) + 1
      ALLOCATE ( abuf ( n(2), mx*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(2)*mx*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( bbuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) T",sum_data
        END IF
      END IF

      CALL cube_transpose_3 ( bbuf, group, bo(:,:,:,3), bo(:,:,:,2), abuf )

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( mx*mz, n(2) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(2)*mx*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( abuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T67,2I7)') "     Transform Y ",n(2),mx*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) ",sum_data
        END IF
      END IF

      ! FFT along y
      CALL fft_1dm ( fft_type, sign, .TRUE., n(2), mx*mz, abuf, bbuf, 1.0_lp )

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      mx = bo ( 2, 1, my_pos, 1 ) - bo ( 1, 1, my_pos, 1 ) + 1
      my = bo ( 2, 2, my_pos, 1 ) - bo ( 1, 2, my_pos, 1 ) + 1
      ALLOCATE ( abuf ( n(3), mx*my ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(3)*mx*my )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( bbuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) T",sum_data
        END IF
      END IF

      CALL cube_transpose_1 ( bbuf, group, bo(:,:,:,2), bo(:,:,:,1), abuf )

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( mx*my, n(3) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(3)*mx*my )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( abuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T67,2I7)') "     Transform Z ",n(3),mx*my
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(5) ",sum_data
        END IF
      END IF

      ! FFT along z
      CALL fft_1dm ( fft_type, sign, .TRUE., n(3), mx*my, abuf, bbuf, norm )

#if defined(__FFTSGL) && defined(__NAG)
      CALL copy_cz(n(3)*mx*my,bbuf,zin)
#else
      zin = RESHAPE(bbuf,SHAPE(zin))
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( zin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(6) ",sum_data
        END IF
      END IF

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )

    ELSE
      CALL stop_program ( "fft3d", "Illegal fsign parameter" )
    ENDIF

  ELSEIF ( DIM ( 2 ) == 1 ) THEN

    !
    ! Second case; one stage of communication
    !

    IF ( sign == FWFFT ) THEN
      ! Stage 1 -> 3

      mx = bo ( 2, 1, my_pos, 1 ) - bo ( 1, 1, my_pos, 1 ) + 1
      my = bo ( 2, 2, my_pos, 1 ) - bo ( 1, 2, my_pos, 1 ) + 1
      mz = bo ( 2, 3, my_pos, 1 ) - bo ( 1, 3, my_pos, 1 ) + 1

      ALLOCATE ( abuf ( mx*my, n(3) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", mx*my*n(3) )
      ALLOCATE ( bbuf ( n(3), mx*my ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(3)*mx*my )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( zin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A)') "  one step communication algorithm "
          WRITE ( *, '(A,T67,2I7)') "     Transform Z ",n(3),mx*my
          WRITE ( *, '(A,T67,2I7)') "     Transform Y ",n(2),mx*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      abuf = RESHAPE(zin,SHAPE(abuf))

      ! FFT along z
      CALL fft_1dm ( fft_type, sign, .TRUE., n(3), mx*my, abuf, bbuf, norm )

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      ALLOCATE ( abuf ( mx*mz, n(2) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", mx*mz*n(2) )

      abuf = RESHAPE(bbuf,SHAPE(abuf))

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( n(2), mx*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", mx*mz*n(2) )

      ! FFT along y
      CALL fft_1dm ( fft_type, sign, .TRUE., n(2), mx*mz, abuf, bbuf, 1.0_lp )

      mx = bo ( 2, 1, my_pos, 3 ) - bo ( 1, 1, my_pos, 3 ) + 1
      my = bo ( 2, 2, my_pos, 3 ) - bo ( 1, 2, my_pos, 3 ) + 1
      mz = bo ( 2, 3, my_pos, 3 ) - bo ( 1, 3, my_pos, 3 ) + 1

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( abuf ( my*mz, n ( 1 ) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", my*mz*n(1) )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( bbuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) T",sum_data
        END IF
      END IF

      CALL cube_transpose_6 ( bbuf, group, bo(:,:,:,1), bo(:,:,:,3), abuf )

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( n ( 1 ), my*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(1)*my*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( abuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),my*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) ",sum_data
        END IF
      END IF

      ! FFT along x
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), my*mz, abuf, bbuf, 1.0_lp )

#if defined(__FFTSGL) && defined(__NAG)
      CALL copy_cz(n(1)*my*mz,bbuf,gin)
#else
      gin = RESHAPE(bbuf,SHAPE(gin))
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) ",sum_data
        END IF
      END IF

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )

    ELSEIF ( sign == BWFFT ) THEN
      ! Stage 3 -> 1

      mx = bo ( 2, 1, my_pos, 3 ) - bo ( 1, 1, my_pos, 3 ) + 1
      my = bo ( 2, 2, my_pos, 3 ) - bo ( 1, 2, my_pos, 3 ) + 1
      mz = bo ( 2, 3, my_pos, 3 ) - bo ( 1, 3, my_pos, 3 ) + 1
      ALLOCATE ( abuf ( n(1), my*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(1)*my*mz )
      ALLOCATE ( bbuf ( my*mz, n(1) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(1)*my*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( gin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A)') "  one step communication algorithm "
          WRITE ( *, '(A,T67,2I7)') "     Transform X ",n(1),my*mz
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(1) ",sum_data
        END IF
      END IF

      abuf = RESHAPE(gin,SHAPE(abuf))

      ! FFT along x
      CALL fft_1dm ( fft_type, sign, .TRUE., n(1), my*mz, abuf, bbuf, 1.0_lp )

      mx = bo ( 2, 1, my_pos, 1 ) - bo ( 1, 1, my_pos, 1 ) + 1
      my = bo ( 2, 2, my_pos, 1 ) - bo ( 1, 2, my_pos, 1 ) + 1
      mz = bo ( 2, 3, my_pos, 1 ) - bo ( 1, 3, my_pos, 1 ) + 1

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      ALLOCATE ( abuf ( n(2), mx*mz ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(2)*mx*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( bbuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(2) T",sum_data
        END IF
      END IF

      CALL cube_transpose_5 ( bbuf, group, bo(:,:,:,3), bo(:,:,:,1), abuf )

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( mz*mx, n(2) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(2)*mx*mz )

      IF ( test ) THEN
        sum_data = ABS ( SUM ( abuf ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T67,2I7)') "     Transform Y ",n(2),mx*mz
          WRITE ( *, '(A,T67,2I7)') "     Transform Z ",n(3),mx*my
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(3) ",sum_data
        END IF
      END IF

      ! FFT along y
      CALL fft_1dm ( fft_type, sign, .TRUE., n(2), mx*mz, abuf, bbuf, 1.0_lp )

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      ALLOCATE ( abuf ( n(3), mx*my ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf", n(3)*mx*my )

      abuf = RESHAPE(bbuf,SHAPE(abuf))

      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )
      ALLOCATE ( bbuf ( mx*my,n(3) ), STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf", n(3)*mx*my )

      ! FFT along z
      CALL fft_1dm ( fft_type, sign, .TRUE., n(3), mx*my, abuf, bbuf, norm )

#if defined(__FFTSGL) && defined(__NAG)
      CALL copy_cz(n(3)*mx*my,bbuf,zin)
#else
      zin = RESHAPE(bbuf,SHAPE(zin))
#endif

      IF ( test ) THEN
        sum_data = ABS ( SUM ( zin ) )
        CALL mp_sum ( sum_data, group )
        IF ( my_pos == 0 ) THEN
          WRITE ( *, '(A,T61,E20.14)') "     Sum of data(4) ",sum_data
        END IF
      END IF

      DEALLOCATE ( abuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "abuf" )
      DEALLOCATE ( bbuf, STAT = ierr )
      IF ( ierr /= 0 ) CALL stop_memory ( "fft3d", "bbuf" )

    ELSE
      CALL stop_program ( "fft3d", "Illegal fsign parameter" )
    ENDIF

  ELSE
     
    CALL stop_program ( "fft3d", "This partition not implemented" )

  END IF

  IF ( PRESENT ( status ) ) THEN
    IF ( sign == 0 ) THEN
      status = 1
    ELSE
      status = 0
    END IF
  END IF

  nx = 5.e-9_dp * REAL ( n(1)*n(2)*n(3),KIND=dp)
  flops = nx * LOG ( REAL ( n(1)*n(2)*n(3),KIND=dp) ) / LOG (2.0_dp)
  CALL timestop(flops,handle)

END SUBROUTINE fft3d_pb

! *****************************************************************************
!> \par History
!>      15. Feb. 2006 : single precision all_to_all
!> \author JGH (14-Jan-2001)
! *****************************************************************************
SUBROUTINE x_to_yz ( sb, group, my_pos, p2p, yzp, nray, bo, tb )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: sb
    INTEGER, INTENT(IN)                      :: group, my_pos
    INTEGER, DIMENSION(0:), INTENT(IN)       :: p2p
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: yzp
    INTEGER, DIMENSION(0:), INTENT(IN)       :: nray
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: bo
    COMPLEX(KIND=lp), DIMENSION(:, :, :), &
      INTENT(OUT)                            :: tb

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rr
    COMPLEX(KIND=sp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: ss, tt
    INTEGER                                  :: handle, ierr, ip, ir, ix, &
                                                ixx, iy, iz, mpr, nm, np, nr, &
                                                ns1, ns2, nx
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rcount, rdispl, scount, sdispl
    REAL(KIND=dp)                            :: flop

!------------------------------------------------------------------------------

  CALL timeset("x_to_yz","I","Mcopy",handle)

  np = SIZE ( p2p )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "scount", 4*np )

  mpr = p2p ( my_pos )
  nx = bo ( 2, 1, mpr ) - bo ( 1, 1, mpr ) + 1
  nm = MAXVAL ( nray ( 0 : np - 1 ) )

  IF ( alltoall_sgl ) THEN
    ns1 = SIZE ( sb, 1)
    ns2 = SIZE ( sb, 2)
    ALLOCATE ( ss ( ns1, ns2 ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "ss", ns1*ns2 )
    ss(:,:) = sb(:,:)
    ALLOCATE ( tt ( nm * nx, 0 : np - 1 ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "tt", np*nm*nx )
    tt(:,:) = 0._sp
  ELSE
    ALLOCATE ( rr ( nm * nx, 0 : np - 1 ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "rr", np*nm*nx )
    rr(:,:) = 0._lp
  END IF
  
  nr = nray ( my_pos )
  DO ip = 0, np - 1
    ix = p2p ( ip )
    nx = bo ( 2, 1, ix ) - bo ( 1, 1, ix ) + 1
    scount ( ip ) = nr * nx
    sdispl ( ip ) = nr * ( bo ( 1, 1, ix ) - 1 ) 
  END DO
  nx = bo ( 2, 1, mpr ) - bo ( 1, 1, mpr ) + 1
  DO ip = 0, np - 1
    nr = nray ( ip )
    rcount ( ip ) = nr * nx
    rdispl ( ip ) = nm * nx * ip 
  END DO
  flop = REAL ( nm * nx * np,KIND=dp)

  IF ( alltoall_sgl ) THEN
    CALL mp_alltoall ( ss, scount, sdispl, tt, rcount, rdispl, group )
  ELSE
    CALL mp_alltoall ( sb, scount, sdispl, rr, rcount, rdispl, group )
  END IF

  tb(:,:,:) = 0._lp
  nx = bo ( 2, 1, mpr ) - bo ( 1, 1, mpr ) + 1
  DO ip = 0, np - 1
    nr = nray ( ip )
    DO ix = 1, nx
      ixx = nr * ( ix - 1 )
      IF ( alltoall_sgl ) THEN
        DO ir = 1, nray ( ip )
          iy = yzp ( 1, ir, ip )
          iz = yzp ( 2, ir, ip )
          tb ( iy, iz, ix ) = tt ( ir + ixx, ip )
        END DO
      ELSE
        DO ir = 1, nray ( ip )
          iy = yzp ( 1, ir, ip )
          iz = yzp ( 2, ir, ip )
          tb ( iy, iz, ix ) = rr ( ir + ixx, ip )
        END DO
      END IF
    END DO
  END DO

  IF ( alltoall_sgl ) THEN
    DEALLOCATE ( ss, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "ss" )
    DEALLOCATE ( tt, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "tt" )
  ELSE
    DEALLOCATE ( rr, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "rr" )
  END IF
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "x_to_yz", "scount" )

  flop = flop * 1.e-6_dp
  CALL timestop(flop,handle)

END SUBROUTINE x_to_yz

! *****************************************************************************
!> \par History
!>      15. Feb. 2006 : single precision all_to_all
!> \author JGH (14-Jan-2001)
! *****************************************************************************
SUBROUTINE yz_to_x ( tb, group, my_pos, p2p, yzp, nray, bo, sb )

    COMPLEX(KIND=lp), DIMENSION(:, :, :), &
      INTENT(IN)                             :: tb
    INTEGER, INTENT(IN)                      :: group, my_pos
    INTEGER, DIMENSION(0:), INTENT(IN)       :: p2p
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: yzp
    INTEGER, DIMENSION(0:), INTENT(IN)       :: nray
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: bo
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sb

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rr
    COMPLEX(KIND=sp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: ss, tt
    INTEGER                                  :: handle, ierr, ip, ir, ix, &
                                                ixx, iy, iz, mpr, nm, np, nr, &
                                                ns1, ns2, nx
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rcount, rdispl, scount, sdispl
    REAL(KIND=dp)                            :: flop

!------------------------------------------------------------------------------

  CALL timeset("yz_to_x","I","Mcopy",handle)

  np = SIZE ( p2p )
  mpr = p2p ( my_pos )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "scount", 4*np )

  nx = bo ( 2, 1, mpr ) - bo ( 1, 1, mpr ) + 1
  nm = MAXVAL ( nray ( 0 : np - 1 ) )
  IF ( alltoall_sgl ) THEN
    ns1 = SIZE ( sb, 1)
    ns2 = SIZE ( sb, 2)
    ALLOCATE ( ss ( ns1, ns2 ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "ss", ns1*ns2 )
    ss(:,:) = 0.0_sp
    ALLOCATE ( tt ( nm * nx, 0 : np - 1 ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "tt", np*nm*nx )
    tt(:,:) = 0.0_sp
  ELSE
    ALLOCATE ( rr ( nm * nx, 0 : np - 1 ), STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "rr", np*nm*nx )
    rr(:,:) = 0.0_lp
  END IF
  
  nx = bo ( 2, 1, mpr ) - bo ( 1, 1, mpr ) + 1
  DO ip = 0, np - 1
    nr = nray ( ip )
    DO ix = 1, nx
      ixx = nr * ( ix - 1 )
      IF ( alltoall_sgl ) THEN
        DO ir = 1, nray ( ip )
          iy = yzp ( 1, ir, ip )
          iz = yzp ( 2, ir, ip )
          tt ( ir + ixx, ip ) = tb ( iy, iz, ix )
        END DO
      ELSE
        DO ir = 1, nray ( ip )
          iy = yzp ( 1, ir, ip )
          iz = yzp ( 2, ir, ip )
          rr ( ir + ixx, ip ) = tb ( iy, iz, ix )
        END DO
      END IF
    END DO
  END DO

  nr = nray ( my_pos )
  DO ip = 0, np - 1
    ix = p2p ( ip )
    nx = bo ( 2, 1, ix ) - bo ( 1, 1, ix ) + 1
    rcount ( ip ) = nr * nx
    rdispl ( ip ) = nr * ( bo ( 1, 1, ix ) - 1 )
  END DO
  nx = bo ( 2, 1, mpr ) - bo ( 1, 1, mpr ) + 1
  DO ip = 0, np - 1
    nr = nray ( ip )
    scount ( ip ) = nr * nx
    sdispl ( ip ) = nm * nx * ip
  END DO
  flop = REAL ( nm * nx * np,KIND=dp)

  IF ( alltoall_sgl ) THEN
    CALL mp_alltoall ( tt, scount, sdispl, ss, rcount, rdispl, group )
  ELSE
    CALL mp_alltoall ( rr, scount, sdispl, sb, rcount, rdispl, group )
  END IF

  IF ( alltoall_sgl ) THEN
    sb(:,:) = ss(:,:)
    DEALLOCATE ( ss, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "ss" )
    DEALLOCATE ( tt, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "tt" )
  ELSE
    DEALLOCATE ( rr, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "rr" )
  END IF
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_x", "scount" )

  flop = flop * 1.e-6
  CALL timestop(flop,handle)

END SUBROUTINE yz_to_x

! *****************************************************************************
!> \par History
!>      15. Feb. 2006 : single precision all_to_all
!> \author JGH (18-Jan-2001)
! *****************************************************************************
SUBROUTINE yz_to_xz ( sb, group, dims, my_pos, p2p, yzp, nray, bo, tb )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: sb
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(2), INTENT(IN)        :: dims
    INTEGER, INTENT(IN)                      :: my_pos
    INTEGER, DIMENSION(0:), INTENT(IN)       :: p2p
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: yzp
    INTEGER, DIMENSION(0:), INTENT(IN)       :: nray
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: bo
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: tb

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rq, rs
    COMPLEX(KIND=sp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: tq, ts
    INTEGER                                  :: cpos( 2 ), handle, ierr, ip, &
                                                ipr, ir, ix, iz, jj, jx, jy, &
                                                jz, myx, myz, nmax, np, npx, &
                                                npz, nx, ny, nz, rs_pos
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rcount, rdispl, scount, &
                                                sdispl, xcor, zcor
    INTEGER, ALLOCATABLE, DIMENSION(:, :)    :: pgrid
    REAL(KIND=dp)                            :: flop

!------------------------------------------------------------------------------

  CALL timeset("yz_to_xz","I","Mcopy",handle)

  np = SIZE ( p2p )
  ny = MAXVAL ( bo ( 2, 2, : ) - bo ( 1, 2, : ) + 1 )
  nmax = MAX ( (2*ny)/np, 2) * SIZE ( tb ,2 )
  nx = MAXVAL ( bo ( 2, 1, : ) - bo ( 1, 1, : ) + 1 )
  nmax = MAX ( nmax, nx*MAXVAL(nray(:)) )

  rs_pos = p2p ( my_pos )

  IF ( alltoall_sgl ) THEN
    ALLOCATE ( ts ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "ts", nmax*np )
    ts = 0.0_sp
    ALLOCATE ( tq ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "tq", nmax*np )
  ELSE
    ALLOCATE ( rs ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "rs", nmax*np )
    rs = 0.0_lp
    ALLOCATE ( rq ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "rq", nmax*np )
  END IF
  npx = dims ( 1 )
  npz = dims ( 2 )
  ALLOCATE ( pgrid ( 0:npx-1, 0:npz-1 ) , STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "pgrid", npx*npz )
  nx = MAXVAL ( bo ( 2, 1, : ) )
  ALLOCATE ( xcor ( 1:nx ) , STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "xcor", nx )
  nz = MAXVAL ( bo ( 2, 3, : ) )
  ALLOCATE ( zcor ( 1:nz ) , STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "zcor", nz )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "scount", 4*np )

  DO ix = 0, npx - 1
    DO iz = 0, npz - 1
      cpos ( 1 ) = ix
      cpos ( 2 ) = iz
      CALL mp_cart_rank ( group, cpos, pgrid ( ix, iz ) )
    END DO
  END DO
  DO ix = 0, npx - 1
    ip = pgrid ( ix, 0 )
    xcor ( bo ( 1, 1, ip ) : bo ( 2, 1, ip ) ) = ix
  END DO
  DO iz = 0, npz - 1
    ip = pgrid ( 0, iz )
    zcor ( bo ( 1, 3, ip ) : bo ( 2, 3, ip ) ) = iz
  END DO

  scount = 0
  nx = SIZE ( sb ,2 )
  DO jx = 1, nx
    IF ( alltoall_sgl ) THEN
      DO ir = 1, nray ( my_pos )
        jy = yzp ( 1, ir, my_pos )
        jz = yzp ( 2, ir, my_pos )
        ip = pgrid ( xcor ( jx ), zcor ( jz ) )
        scount ( ip ) = scount ( ip ) + 1
        ts ( scount ( ip ), ip ) = sb ( ir, jx )
      END DO
    ELSE
      DO ir = 1, nray ( my_pos )
        jy = yzp ( 1, ir, my_pos )
        jz = yzp ( 2, ir, my_pos )
        ip = pgrid ( xcor ( jx ), zcor ( jz ) )
        scount ( ip ) = scount ( ip ) + 1
        rs ( scount ( ip ), ip ) = sb ( ir, jx )
      END DO
    END IF
  END DO

  DO ip = 0, np - 1
    sdispl ( ip ) = nmax * ip
    rdispl ( ip ) = nmax * ip
  END DO
  flop = REAL ( nmax * np,KIND=dp)

  CALL mp_alltoall ( scount, rcount, 1, group )
  IF ( alltoall_sgl ) THEN
    CALL mp_alltoall ( ts, scount, sdispl, tq, rcount, rdispl, group )
  ELSE
    CALL mp_alltoall ( rs, scount, sdispl, rq, rcount, rdispl, group )
  END IF

  CALL mp_cart_coords ( group, rs_pos, cpos )
  myx = cpos ( 1 )
  myz = cpos ( 2 )
  nz = bo ( 2, 3, rs_pos ) - bo ( 1, 3, rs_pos ) + 1
  tb = 0.0_lp
  DO ip = 0, np - 1
    ipr = p2p ( ip )
    jj = 0
    DO jx = 0, bo ( 2, 1, rs_pos ) - bo ( 1, 1, rs_pos )
      DO ir = 1, nray ( ip )
        jz = yzp ( 2, ir, ip )
        IF ( alltoall_sgl ) THEN
          IF ( zcor ( jz ) == myz ) THEN
            jj = jj + 1
            jy = yzp ( 1, ir, ip )
            jz = jz - bo ( 1, 3, rs_pos ) + 1
            tb ( jy, jz + jx * nz ) = tq ( jj, ipr )
          END IF
        ELSE
          IF ( zcor ( jz ) == myz ) THEN
            jj = jj + 1
            jy = yzp ( 1, ir, ip )
            jz = jz - bo ( 1, 3, rs_pos ) + 1
            tb ( jy, jz + jx * nz ) = rq ( jj, ipr )
          END IF
        END IF
      END DO
    END DO
  END DO

  IF ( alltoall_sgl ) THEN
    DEALLOCATE ( ts, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "ts" )
    DEALLOCATE ( tq, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "tq" )
  ELSE
    DEALLOCATE ( rs, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "rs" )
    DEALLOCATE ( rq, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "rq" )
  END IF
  DEALLOCATE ( pgrid, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "pgrid" )
  DEALLOCATE ( xcor, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "xcor" )
  DEALLOCATE ( zcor, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "zcor" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "scount" )

  flop = flop * 1.e-6
  CALL timestop(flop,handle)

END SUBROUTINE yz_to_xz

! *****************************************************************************
!> \par History
!>      15. Feb. 2006 : single precision all_to_all
!> \author JGH (19-Jan-2001)
! *****************************************************************************
SUBROUTINE xz_to_yz ( sb, group, dims, my_pos, p2p, yzp, nray, bo, tb )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: sb
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(2), INTENT(IN)        :: dims
    INTEGER, INTENT(IN)                      :: my_pos
    INTEGER, DIMENSION(0:), INTENT(IN)       :: p2p
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: yzp
    INTEGER, DIMENSION(0:), INTENT(IN)       :: nray
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: bo
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: tb

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rq, rs
    COMPLEX(KIND=sp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: tq, ts
    INTEGER                                  :: cpos( 2 ), handle, ierr, ip, &
                                                ipl, ir, ix, ixx, iz, jj, jx, &
                                                jy, jz, mp, myx, myz, nmax, &
                                                np, npx, npz, nx, ny, nz
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rcount, rdispl, scount, &
                                                sdispl, xcor, zcor
    INTEGER, ALLOCATABLE, DIMENSION(:, :)    :: pgrid
    REAL(KIND=dp)                            :: flop

!------------------------------------------------------------------------------

  CALL timeset("xz_to_yz","I","Mcopy",handle)

  np = SIZE ( p2p )
  ny = MAXVAL ( bo ( 2, 2, : ) - bo ( 1, 2, : ) + 1 )
  nmax = MAX ( (2*ny)/np, 2) * SIZE ( sb ,2 )
  nx = MAXVAL ( bo ( 2, 1, : ) - bo ( 1, 1, : ) + 1 )
  nmax = MAX ( nmax, nx*MAXVAL(nray(:)) )

  IF ( alltoall_sgl ) THEN
    ALLOCATE ( ts ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "ts", nmax*np )
    ts = 0.0_sp
    ALLOCATE ( tq ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "tq", nmax*np )
    tq = 0.0_sp
  ELSE
    ALLOCATE ( rs ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "rs", nmax*np )
    rs = 0.0_lp
    ALLOCATE ( rq ( nmax, 0:np-1 ) , STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "rq", nmax*np )
    rq = 0.0_lp
  END IF
  npx = dims ( 1 )
  npz = dims ( 2 )
  ALLOCATE ( pgrid ( 0:npx-1, 0:npz-1 ) , STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "pgrid", npx*npz )
  nx = MAXVAL ( bo ( 2, 1, : ) )
  ALLOCATE ( xcor ( 1:nx ) , STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "xcor", nx )
  nz = MAXVAL ( bo ( 2, 3, : ) )
  ALLOCATE ( zcor ( 1:nz ) , STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "zcor", nz )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "xz_to_yz", "scount", 4*np )

  DO ix = 0, npx - 1
    DO iz = 0, npz - 1
      cpos ( 1 ) = ix
      cpos ( 2 ) = iz
      CALL mp_cart_rank ( group, cpos, pgrid ( ix, iz ) )
    END DO
  END DO
  DO ix = 0, npx - 1
    ip = pgrid ( ix, 0 )
    xcor ( bo ( 1, 1, ip ) : bo ( 2, 1, ip ) ) = ix
  END DO
  DO iz = 0, npz - 1
    ip = pgrid ( 0, iz )
    zcor ( bo ( 1, 3, ip ) : bo ( 2, 3, ip ) ) = iz
  END DO

  rcount = 0
  nx = MAXVAL ( bo ( 2, 1, : ) )
  DO jx = 1, nx
    DO ir = 1, nray ( my_pos )
      jy = yzp ( 1, ir, my_pos )
      jz = yzp ( 2, ir, my_pos )
      ip = pgrid ( xcor ( jx ), zcor ( jz ) )
      rcount ( ip ) = rcount ( ip ) + 1
    END DO
  END DO

  CALL mp_alltoall ( rcount, scount, 1, group )

  CALL mp_cart_coords ( group, p2p ( my_pos ), cpos )
  myx = cpos ( 1 )
  myz = cpos ( 2 )
  mp = p2p ( my_pos )
  nz = bo ( 2, 3, mp ) - bo ( 1, 3, mp ) + 1
  nx = bo ( 2, 1, mp ) - bo ( 1, 1, mp ) + 1
  DO ip = 0, np - 1
    jj = 0
    ipl = p2p ( ip )
    DO ir = 1, nray ( ip )
      jz = yzp ( 2, ir, ip )
      IF ( zcor ( jz ) == myz ) THEN
        jj = jj + 1
        jy = yzp ( 1, ir, ip )
        jz = yzp ( 2, ir, ip ) - bo ( 1, 3, mp ) + 1
        IF ( alltoall_sgl ) THEN
          DO jx = 0, nx - 1
            ixx = jj + jx * scount ( ipl )/nx
            tq ( ixx, ipl ) = sb ( jy, jz + jx * nz ) 
          END DO
        ELSE
          DO jx = 0, nx - 1
            ixx = jj + jx * scount ( ipl )/nx
            rq ( ixx, ipl ) = sb ( jy, jz + jx * nz ) 
          END DO
        END IF
      END IF
    END DO
  END DO

  DO ip = 0, np - 1
    sdispl ( ip ) = nmax * ip
    rdispl ( ip ) = nmax * ip
  END DO
  flop = REAL ( nmax * np,KIND=dp)

  IF ( alltoall_sgl ) THEN
    CALL mp_alltoall ( tq, scount, sdispl, ts, rcount, rdispl, group )
  ELSE
    CALL mp_alltoall ( rq, scount, sdispl, rs, rcount, rdispl, group )
  END IF

  rcount = 0
  nx = MAXVAL ( bo ( 2, 1, : ) )
  DO jx = 1, nx
    IF ( alltoall_sgl ) THEN
      DO ir = 1, nray ( my_pos )
        jy = yzp ( 1, ir, my_pos )
        jz = yzp ( 2, ir, my_pos )
        ip = pgrid ( xcor ( jx ), zcor ( jz ) )
        rcount ( ip ) = rcount ( ip ) + 1
        tb ( ir, jx ) = ts ( rcount ( ip ), ip )
      END DO
    ELSE
      DO ir = 1, nray ( my_pos )
        jy = yzp ( 1, ir, my_pos )
        jz = yzp ( 2, ir, my_pos )
        ip = pgrid ( xcor ( jx ), zcor ( jz ) )
        rcount ( ip ) = rcount ( ip ) + 1
        tb ( ir, jx ) = rs ( rcount ( ip ), ip )
      END DO
    END IF
  END DO

  IF ( alltoall_sgl ) THEN
    DEALLOCATE ( ts, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "ts" )
    DEALLOCATE ( tq, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "tq" )
  ELSE
    DEALLOCATE ( rs, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "rs" )
    DEALLOCATE ( rq, STAT = ierr )
    IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "rq" )
  END IF
  DEALLOCATE ( pgrid, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "pgrid" )
  DEALLOCATE ( xcor, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "xcor" )
  DEALLOCATE ( zcor, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "zcor" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "yz_to_xz", "scount" )

  flop = flop * 1.e-6
  CALL timestop(flop,handle)

END SUBROUTINE xz_to_yz

! *****************************************************************************
!> \par History
!>      none
!> \author JGH (20-Jan-2001)
! *****************************************************************************
SUBROUTINE cube_transpose_1 ( cin, group, boin, boout, sout )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: cin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: boin, boout
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sout

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rbuf
    INTEGER                                  :: handle, ierr, ip, ipl, ir, &
                                                is, ixy, iz, mip, mz, n, np, &
                                                nx, ny, nz, sub_group
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: pgrid, rcount, rdispl, &
                                                scount, sdispl
    INTEGER, DIMENSION(2)                    :: dim, pos, pp
    LOGICAL, DIMENSION(2)                    :: rdim

!------------------------------------------------------------------------------

  CALL timeset("cube_transpose_1","I","",handle)

  rdim ( 1 ) = .FALSE.
  rdim ( 2 ) = .TRUE.
  CALL mp_environ ( n, dim, pos, group )
  CALL mp_cart_rank ( group, pos, mip )
  CALL mp_cart_sub ( group, rdim, sub_group )

  np = DIM ( 2 )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount", 4*np )
  ALLOCATE ( pgrid ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid", np )

  pp = pos
  DO ip = 0, np - 1
    pp ( 2 ) = ip
    CALL mp_cart_rank ( group, pp, pgrid ( ip ) )
  END DO

  nx = boin ( 2, 1, mip ) - boin ( 1, 1, mip ) + 1
  nz = boin ( 2, 3, mip ) - boin ( 1, 3, mip ) + 1
  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    ny = boout ( 2, 2, ipl ) - boout ( 1, 2, ipl ) + 1
    scount ( ip ) = nx * nz * ny
    sdispl ( ip ) = nx * nz * ( boout ( 1, 2, ipl ) - 1 )
  END DO
  ny = boout ( 2, 2, mip ) - boout ( 1, 2, mip ) + 1
  mz = MAXVAL ( boin ( 2, 3, : ) - boin ( 1, 3, : ) + 1 )
  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    nz = boin ( 2, 3, ipl ) - boin ( 1, 3, ipl ) + 1
    rcount ( ip ) = nx * nz * ny
    rdispl ( ip ) = nx * ny * mz * ip
  END DO

  ALLOCATE ( rbuf ( mz*nx*ny, 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf", mz*nx*ny*np )
  rbuf = 0.0_lp

  CALL mp_alltoall ( cin, scount, sdispl, rbuf, rcount, rdispl, sub_group )

  DO ixy = 1, nx * ny
    DO ip = 0, np - 1
      ipl = pgrid ( ip )
      nz = boin ( 2, 3, ipl ) - boin ( 1, 3, ipl ) + 1
      DO iz = 1, nz
        is = boin ( 1, 3, ipl ) + iz - 1
        ir = iz + nz * ( ixy - 1 )
        sout ( is, ixy ) = rbuf ( ir, ip )
      END DO
    END DO
  END DO

  DEALLOCATE ( rbuf, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount" )
  DEALLOCATE ( pgrid, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid" )

  CALL mp_comm_free ( sub_group )

  CALL timestop(0.0_dp,handle)

END SUBROUTINE cube_transpose_1

! *****************************************************************************
SUBROUTINE cube_transpose_2 ( cin, group, boin, boout, sout )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: cin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: boin, boout
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sout

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rbuf
    INTEGER                                  :: handle, ierr, ip, ipl, ir, &
                                                ixy, iz, mip, mz, n, np, nx, &
                                                ny, nz, sub_group
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: pgrid, rcount, rdispl, &
                                                scount, sdispl
    INTEGER, DIMENSION(2)                    :: dim, pos, pp
    LOGICAL, DIMENSION(2)                    :: rdim

!------------------------------------------------------------------------------

  CALL timeset("cube_transpose_2","I","",handle)

  rdim ( 1 ) = .FALSE.
  rdim ( 2 ) = .TRUE.
  CALL mp_environ ( n, dim, pos, group )
  CALL mp_cart_rank ( group, pos, mip )
  CALL mp_cart_sub ( group, rdim, sub_group )

  np = DIM ( 2 )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount", 4*np )
  ALLOCATE ( pgrid ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid", np )

  pp = pos
  DO ip = 0, np - 1
    pp ( 2 ) = ip
    CALL mp_cart_rank ( group, pp, pgrid ( ip ) )
  END DO

  nx = boin ( 2, 1, mip ) - boin ( 1, 1, mip ) + 1
  ny = boin ( 2, 2, mip ) - boin ( 1, 2, mip ) + 1
  mz = MAXVAL ( boin ( 2, 3, : ) - boin ( 1, 3, : ) + 1 )

  ALLOCATE ( rbuf ( mz*nx*ny, 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf", mz*nx*ny*np )
  rbuf = 0.0_lp

  DO ixy = 1, nx * ny
    DO ip = 0, np - 1
      ipl = pgrid ( ip )
      nz = boout ( 2, 3, ipl ) - boout ( 1, 3, ipl ) + 1
      DO iz = boout ( 1, 3, ipl ), boout ( 2, 3, ipl )
        ir = iz - boout ( 1, 3, ipl ) + 1 + ( ixy - 1 ) * nz
        rbuf ( ir, ip ) = cin ( iz, ixy )
      END DO
    END DO
  END DO

  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    nz = boout ( 2, 3, ipl ) - boout ( 1, 3, ipl ) + 1
    scount ( ip ) = nx * ny * nz
    sdispl ( ip ) = nx * ny * mz * ip
  END DO
  nz = boout ( 2, 3, mip ) - boout ( 1, 3, mip ) + 1
  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    ny = boin ( 2, 2, ipl ) - boin ( 1, 2, ipl ) + 1
    rcount ( ip ) = nx * ny * nz
    rdispl ( ip ) = nx * nz * ( boin ( 1, 2, ipl ) - 1 )
  END DO

  sout = 0.0_lp
  CALL mp_alltoall ( rbuf, scount, sdispl, sout, rcount, rdispl, sub_group )

  DEALLOCATE ( rbuf, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount" )
  DEALLOCATE ( pgrid, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid" )

  CALL mp_comm_free ( sub_group )

  CALL timestop(0.0_dp,handle)

END SUBROUTINE cube_transpose_2

! *****************************************************************************
SUBROUTINE cube_transpose_3 ( cin, group, boin, boout, sout )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: cin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: boin, boout
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sout

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rbuf
    INTEGER                                  :: handle, ierr, ip, ipl, ir, &
                                                is, ixz, iy, mip, my, n, np, &
                                                nx, ny, nz, sub_group
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: pgrid, rcount, rdispl, &
                                                scount, sdispl
    INTEGER, DIMENSION(2)                    :: dim, pos, pp
    LOGICAL, DIMENSION(2)                    :: rdim

!------------------------------------------------------------------------------

  CALL timeset("cube_transpose_3","I","",handle)

  rdim ( 1 ) = .TRUE. 
  rdim ( 2 ) = .FALSE.
  CALL mp_environ ( n, dim, pos, group )
  CALL mp_cart_rank ( group, pos, mip )
  CALL mp_cart_sub ( group, rdim, sub_group )

  np = DIM ( 1 )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount", 4*np )
  ALLOCATE ( pgrid ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid", np )

  pp = pos
  DO ip = 0, np - 1
    pp ( 1 ) = ip
    CALL mp_cart_rank ( group, pp, pgrid ( ip ) )
  END DO

  ny = boin ( 2, 2, mip ) - boin ( 1, 2, mip ) + 1
  nz = boin ( 2, 3, mip ) - boin ( 1, 3, mip ) + 1
  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    nx = boout ( 2, 1, ipl ) - boout ( 1, 1, ipl ) + 1
    scount ( ip ) = nx * nz * ny
    sdispl ( ip ) = ny * nz * ( boout ( 1, 1, ipl ) - 1 )
  END DO
  nx = boout ( 2, 1, mip ) - boout ( 1, 1, mip ) + 1
  my = MAXVAL ( boin ( 2, 2, : ) - boin ( 1, 2, : ) + 1 )
  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    ny = boin ( 2, 2, ipl ) - boin ( 1, 2, ipl ) + 1
    rcount ( ip ) = nx * nz * ny
    rdispl ( ip ) = nx * my * nz * ip
  END DO

  ALLOCATE ( rbuf ( nz*nx*my, 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf", nz*nx*my*np )
  rbuf = 0.0_lp

  CALL mp_alltoall ( cin, scount, sdispl, rbuf, rcount, rdispl, sub_group )

  DO ixz = 1, nx * nz
    DO ip = 0, np - 1
      ipl = pgrid ( ip )
      ny = boin ( 2, 2, ipl ) - boin ( 1, 2, ipl ) + 1
      DO iy = 1, ny
        is = boin ( 1, 2, ipl ) + iy - 1
        ir = iy + ny * ( ixz - 1 )
        sout ( is, ixz ) = rbuf ( ir, ip )
      END DO
    END DO
  END DO

  DEALLOCATE ( rbuf, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount" )
  DEALLOCATE ( pgrid, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid" )

  CALL mp_comm_free ( sub_group )

  CALL timestop(0.0_dp,handle)

END SUBROUTINE cube_transpose_3

! *****************************************************************************
SUBROUTINE cube_transpose_4 ( cin, group, boin, boout, sout )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: cin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: boin, boout
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sout

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rbuf
    INTEGER                                  :: handle, ierr, ip, ipl, ir, &
                                                iy, izx, mip, my, n, np, nx, &
                                                ny, nz, sub_group
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: pgrid, rcount, rdispl, &
                                                scount, sdispl
    INTEGER, DIMENSION(2)                    :: dim, pos, pp
    LOGICAL, DIMENSION(2)                    :: rdim

!------------------------------------------------------------------------------

  CALL timeset("cube_transpose_4","I","",handle)

  rdim ( 1 ) = .TRUE.
  rdim ( 2 ) = .FALSE.
  CALL mp_environ ( n, dim, pos, group )
  CALL mp_cart_rank ( group, pos, mip )
  CALL mp_cart_sub ( group, rdim, sub_group )

  np = DIM ( 1 )
  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount", 4*np )
  ALLOCATE ( pgrid ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid", np )

  pp = pos
  DO ip = 0, np - 1
    pp ( 1 ) = ip
    CALL mp_cart_rank ( group, pp, pgrid ( ip ) )
  END DO

  nx = boin ( 2, 1, mip ) - boin ( 1, 1, mip ) + 1
  nz = boin ( 2, 3, mip ) - boin ( 1, 3, mip ) + 1
  my = MAXVAL ( boout ( 2, 2, : ) - boout ( 1, 2, : ) + 1 )

  ALLOCATE ( rbuf ( nz*nx*my, 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf", nz*nx*my*np )
  rbuf = 0.0_lp

  DO izx = 1, nz * nx
    DO ip = 0, np - 1
      ipl = pgrid ( ip )
      ny = boout ( 2, 2, ipl ) - boout ( 1, 2, ipl ) + 1
      DO iy = boout ( 1, 2, ipl ), boout ( 2, 2, ipl )
        ir = iy - boout ( 1, 2, ipl ) + 1 + ( izx - 1 ) * ny
        rbuf ( ir, ip ) = cin ( iy, izx )
      END DO
    END DO
  END DO

  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    ny = boout ( 2, 2, ipl ) - boout ( 1, 2, ipl ) + 1
    scount ( ip ) = nx * ny * nz
    sdispl ( ip ) = nx * nz * my * ip
  END DO
  ny = boout ( 2, 2, mip ) - boout ( 1, 2, mip ) + 1
  DO ip = 0, np - 1
    ipl = pgrid ( ip )
    nx = boin ( 2, 1, ipl ) - boin ( 1, 1, ipl ) + 1
    rcount ( ip ) = nx * ny * nz
    rdispl ( ip ) = ny * nz * ( boin ( 1, 1, ipl ) - 1 )
  END DO

  CALL mp_alltoall ( rbuf, scount, sdispl, sout, rcount, rdispl, sub_group )

  DEALLOCATE ( rbuf, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount" )
  DEALLOCATE ( pgrid, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "pgrid" )

  CALL mp_comm_free ( sub_group )

  CALL timestop(0.0_dp,handle)

END SUBROUTINE cube_transpose_4

! *****************************************************************************
SUBROUTINE cube_transpose_5 ( cin, group, boin, boout, sout )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: cin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: boin, boout
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sout

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rbuf
    INTEGER                                  :: handle, ierr, ip, ir, is, &
                                                ixz, iy, mip, my, np, nx, ny, &
                                                nz
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rcount, rdispl, scount, sdispl
    INTEGER, DIMENSION(2)                    :: dim, pos

!------------------------------------------------------------------------------

  CALL timeset("cube_transpose_5","I","",handle)

  CALL mp_environ ( np, dim, pos, group )
  CALL mp_cart_rank ( group, pos, mip )

  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount", 4*np )

  ny = boin ( 2, 2, mip ) - boin ( 1, 2, mip ) + 1
  nz = boin ( 2, 3, mip ) - boin ( 1, 3, mip ) + 1
  DO ip = 0, np - 1
    nx = boout ( 2, 1, ip ) - boout ( 1, 1, ip ) + 1
    scount ( ip ) = nx * nz * ny
    sdispl ( ip ) = ny * nz * ( boout ( 1, 1, ip ) - 1 )
  END DO
  nx = boout ( 2, 1, mip ) - boout ( 1, 1, mip ) + 1
  my = MAXVAL ( boin ( 2, 2, : ) - boin ( 1, 2, : ) + 1 )
  DO ip = 0, np - 1
    ny = boin ( 2, 2, ip ) - boin ( 1, 2, ip ) + 1
    rcount ( ip ) = nx * nz * ny
    rdispl ( ip ) = nx * my * nz * ip
  END DO

  ALLOCATE ( rbuf ( nz*nx*my, 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf", nz*nx*my*np )
  rbuf = 0.0_lp

  CALL mp_alltoall ( cin, scount, sdispl, rbuf, rcount, rdispl, group )

  DO ixz = 1, nx * nz
    DO ip = 0, np - 1
      ny = boin ( 2, 2, ip ) - boin ( 1, 2, ip ) + 1
      DO iy = 1, ny
        is = boin ( 1, 2, ip ) + iy - 1
        ir = iy + ny * ( ixz - 1 )
        sout ( is, ixz ) = rbuf ( ir, ip )
      END DO
    END DO
  END DO

  DEALLOCATE ( rbuf, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount" )

  CALL timestop(0.0_dp,handle)

END SUBROUTINE cube_transpose_5

! *****************************************************************************
SUBROUTINE cube_transpose_6 ( cin, group, boin, boout, sout )

    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(IN)                             :: cin
    INTEGER, INTENT(IN)                      :: group
    INTEGER, DIMENSION(:, :, 0:), INTENT(IN) :: boin, boout
    COMPLEX(KIND=lp), DIMENSION(:, :), &
      INTENT(OUT)                            :: sout

    COMPLEX(KIND=lp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: rbuf
    INTEGER                                  :: handle, ierr, ip, ir, iy, &
                                                izx, mip, my, np, nx, ny, nz
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: rcount, rdispl, scount, sdispl
    INTEGER, DIMENSION(2)                    :: dim, pos

!------------------------------------------------------------------------------

  CALL timeset("cube_transpose_6","I","",handle)

  CALL mp_environ ( np, dim, pos, group )
  CALL mp_cart_rank ( group, pos, mip )

  ALLOCATE ( scount ( 0 : np - 1 ), sdispl ( 0 : np - 1 ), &
             rcount ( 0 : np - 1 ), rdispl ( 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount", 4*np )

  nx = boin ( 2, 1, mip ) - boin ( 1, 1, mip ) + 1
  nz = boin ( 2, 3, mip ) - boin ( 1, 3, mip ) + 1
  my = MAXVAL ( boout ( 2, 2, : ) - boout ( 1, 2, : ) + 1 )

  ALLOCATE ( rbuf ( nz*nx*my, 0 : np - 1 ), STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf", nz*nx*my*np )
  rbuf = 0.0_lp

  DO izx = 1, nz * nx
    DO ip = 0, np - 1
      ny = boout ( 2, 2, ip ) - boout ( 1, 2, ip ) + 1
      DO iy = boout ( 1, 2, ip ), boout ( 2, 2, ip )
        ir = iy - boout ( 1, 2, ip ) + 1 + ( izx - 1 ) * ny
        rbuf ( ir, ip ) = cin ( iy, izx )
      END DO
    END DO
  END DO

  DO ip = 0, np - 1
    ny = boout ( 2, 2, ip ) - boout ( 1, 2, ip ) + 1
    scount ( ip ) = nx * ny * nz
    sdispl ( ip ) = nx * nz * my * ip
  END DO
  ny = boout ( 2, 2, mip ) - boout ( 1, 2, mip ) + 1
  DO ip = 0, np - 1
    nx = boin ( 2, 1, ip ) - boin ( 1, 1, ip ) + 1
    rcount ( ip ) = nx * ny * nz
    rdispl ( ip ) = ny * nz * ( boin ( 1, 1, ip ) - 1 )
  END DO

  CALL mp_alltoall ( rbuf, scount, sdispl, sout, rcount, rdispl, group )

  DEALLOCATE ( rbuf, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "rbuf" )
  DEALLOCATE ( scount, sdispl, rcount, rdispl, STAT = ierr )
  IF ( ierr /= 0 ) CALL stop_memory ( "cube_transpose", "scount" )

  CALL timestop(0.0_dp,handle)

END SUBROUTINE cube_transpose_6

END MODULE fft_tools

