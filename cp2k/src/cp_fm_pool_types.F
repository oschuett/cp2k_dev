!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2002  CP2K developers group                                 !
!-----------------------------------------------------------------------------!

#include "cp_prep_globals.h"

!!****h* cp2k/cp_fm_pool_types [1.0] *
!!
!!   NAME
!!     cp_fm_pool_types
!!
!!   FUNCTION
!!     pool for full matrixes
!!
!!   NOTES
!!     -
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!   SOURCE
!****************************************************************************
MODULE cp_fm_pool_types
  USE cp_error_handling,               ONLY: cp_a_l,&
                                             cp_assert,&
                                             cp_assertion_failed,&
                                             cp_debug,&
                                             cp_error_dealloc_ref,&
                                             cp_error_get_logger,&
                                             cp_error_init,&
                                             cp_error_message,&
                                             cp_error_type,&
                                             cp_internal_error,&
                                             cp_unimplemented_error
  USE cp_fm_struct,                    ONLY: cp_fm_struct_release,&
                                             cp_fm_struct_retain,&
                                             cp_fm_struct_type
  USE cp_fm_types,                     ONLY: cp_fm_create,&
                                             cp_fm_release,&
                                             cp_full_matrix_p_type,&
                                             cp_full_matrix_type
  USE cp_linked_list_fm,               ONLY: cp_sll_fm_dealloc,&
                                             cp_sll_fm_get_first_el,&
                                             cp_sll_fm_insert_el,&
                                             cp_sll_fm_next,&
                                             cp_sll_fm_rm_first_el,&
                                             cp_sll_fm_type
  USE cp_log_handling,                 ONLY: cp_failure_level,&
                                             cp_fatal_level,&
                                             cp_log,&
                                             cp_note_level,&
                                             cp_to_string,&
                                             cp_warning_level
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE kinds,                           ONLY: wp=>dp
  USE timings,                         ONLY: timeset,&
                                             timestop
  IMPLICIT NONE
  PRIVATE

  LOGICAL, PRIVATE, PARAMETER :: debug_this_module=.TRUE.
  CHARACTER(len=*), PRIVATE, PARAMETER :: moduleN='cp_fm_pool_types'
  INTEGER, SAVE, PRIVATE :: last_fm_pool_id_nr=0

  PUBLIC :: cp_fm_pool_type, cp_fm_pool_p_type
  PUBLIC :: fm_pool_create, fm_pool_retain, fm_pool_release,&
       fm_pool_create_matrix, fm_pool_give_back_matrix,&
       fm_pool_get_mstruct, fm_pool_create_matrix_vect,&
       fm_pool_give_back_matrix_vect
  PUBLIC :: fm_pools_copy, fm_pools_dealloc, fm_pools_flush_cache,&
       fm_pools_create_matrix_vect, fm_pools_give_back_matrix_vect
!***
!****************************************************************************

!!****s* cp_fm_pool_types/cp_fm_pool_type [1.0] *
!!
!!   NAME
!!     cp_fm_pool_type
!!
!!   FUNCTION
!!     represent a pool of full matrixes
!!
!!   NOTES
!!     -
!!
!!   ATTRIBUTES
!!     - ref_count: reference count (see /cp2k/doc/ReferenceCounting.html)
!!     - matrix_struct: matrix structure of the matrixes in this pool
!!     - cache: linked list with the matrixes in the pool
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!   SOURCE
!***************************************************************************
  TYPE cp_fm_pool_type
     PRIVATE
     INTEGER :: ref_count, id_nr
     TYPE(cp_fm_struct_type), POINTER :: matrix_struct
     TYPE(cp_sll_fm_type), POINTER :: cache
  END TYPE cp_fm_pool_type
!!***
!****************************************************************************


!!****s* cp_fm_pool_types/cp_fm_pool_p_type [1.0] *
!!
!!   NAME
!!     cp_fm_pool_p_type
!!
!!   FUNCTION
!!     to create arrays of pools
!!
!!   NOTES
!!     -
!!
!!   ATTRIBUTES
!!     - pool: the pool
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!   SOURCE
!***************************************************************************
  TYPE cp_fm_pool_p_type
     TYPE(cp_fm_pool_type), POINTER :: pool
  END TYPE cp_fm_pool_p_type
!!***
!****************************************************************************

CONTAINS

!!****f* cp_fm_pool_types/fm_pool_create [1.0] *
!!
!!   NAME
!!     fm_pool_create
!!
!!   SYNOPSIS
!!     Subroutine fm_pool_create(pool, matrix_struct, error)
!!       Type(cp_fm_pool_type), Pointer:: pool
!!       Type(cp_fm_struct_type), Pointer:: matrix_struct
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pool_create
!!
!!   FUNCTION
!!     creates a pool of full matrixes
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool to create
!!     - matrix_struct: the structure of the matrixes that are stored in
!!       this pool
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_create(pool, matrix_struct, error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_fm_struct_type), POINTER :: matrix_struct
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_create',&
         routineP=moduleN//':'//routineN
    INTEGER :: stat
    failure=.FALSE.

    ALLOCATE(pool, stat=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    IF (.NOT.failure) THEN
       pool%matrix_struct=> matrix_struct
       CALL cp_fm_struct_retain(pool%matrix_struct,error=error)
       last_fm_pool_id_nr=last_fm_pool_id_nr+1
       pool%id_nr=last_fm_pool_id_nr
       pool%ref_count=1
       NULLIFY(pool%cache)
    END IF
  END SUBROUTINE fm_pool_create
!***************************************************************************

!!****f* cp_fm_pool_types/cp_fm_pool_retain [1.0] *
!!
!!   NAME
!!     cp_fm_pool_retain
!!
!!   FUNCTION
!!     retains the pool (see cp2k/doc/ReferenceCounting.html)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool to retain
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_retain(pool,error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_retain',&
         routineP=moduleN//':'//routineN
    failure=.FALSE.

    CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)

       pool%ref_count=pool%ref_count+1
    END IF
  END SUBROUTINE fm_pool_retain
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pool_flush_cache [1.0] *
!!
!!   NAME
!!     fm_pool_flush_cache
!!
!!   FUNCTION
!!     deallocates all the cached matrixes
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool to flush
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_flush_cache(pool,error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_flush_cache',&
         routineP=moduleN//':'//routineN
    TYPE(cp_sll_fm_type), POINTER :: iterator
    TYPE(cp_full_matrix_type), POINTER :: m_att
    failure=.FALSE.

    CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
    CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       iterator => pool%cache
       DO
          IF (.NOT.cp_sll_fm_next(iterator,el_att=m_att)) EXIT
          CALL cp_fm_release(m_att,error=error)
       END DO
       CALL cp_sll_fm_dealloc(pool%cache,error=error)
    END IF
  END SUBROUTINE fm_pool_flush_cache
!***************************************************************************

!!****f* cp_fm_pool_types/cp_fm_pool_release [1.0] *
!!
!!   NAME
!!     cp_fm_pool_release
!!
!!   FUNCTION
!!     releases the given pool (see cp2k/doc/ReferenceCounting.html)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool to release
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_release(pool,error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='cp_fm_pool_release',&
         routineP=moduleN//':'//routineN
    TYPE(cp_sll_fm_type), POINTER :: iterator
    TYPE(cp_full_matrix_type), POINTER :: matrix_att
    INTEGER :: stat
    failure=.FALSE.

    IF (ASSOCIATED(pool)) THEN
       CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
       pool%ref_count=pool%ref_count-1
       IF (pool%ref_count<1) THEN
          CALL fm_pool_flush_cache(pool,error=error)
          CALL cp_fm_struct_release(pool%matrix_struct,error=error)

          DEALLOCATE(pool,stat=stat)
          CPPostcondition(stat==0,cp_warning_level,routineP,error,failure)
       END IF
    END IF
    NULLIFY(pool)
  END SUBROUTINE fm_pool_release
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pool_create_matrix [1.0] *
!!
!!   NAME
!!     fm_pool_create_matrix
!!
!!   SYNOPSIS
!!     Subroutine fm_pool_create_matrix(pool, matrix, name, error)
!!       Type(cp_fm_pool_type), Pointer:: pool
!!       Type(cp_full_matrix_type), Pointer:: matrix
!!       Character(Len=*), Optional, Intent (IN):: name
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pool_create_matrix
!!
!!   FUNCTION
!!     returns a matrix, allocating it if none is in the pool
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool from where you get the matrix
!!     - matrix: will contain the new matrix
!!     - name: the name for the new matrix (optional)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_create_matrix(pool, matrix,name,error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_full_matrix_type), POINTER :: matrix
    CHARACTER(len=*), OPTIONAL, INTENT(in) :: name
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_create_matrix',&
         routineP=moduleN//':'//routineN
    INTEGER :: stat
    failure=.FALSE.

    CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
    CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
    IF (.NOT.failure) THEN
       IF (ASSOCIATED(pool%cache)) THEN
          matrix => cp_sll_fm_get_first_el(pool%cache)
          CALL cp_sll_fm_rm_first_el(pool%cache)
       ELSE
          NULLIFY(matrix)
          CALL cp_fm_create(matrix,matrix_struct=pool%matrix_struct,&
               error=error)
       END IF
       IF (PRESENT(name)) THEN
          matrix%name=name
          matrix%print_count=0
       ELSE
          matrix%name="tmp_matrix "//ADJUSTL(cp_to_string(matrix%id_nr))
       END IF
    END IF
    CPPostcondition(ASSOCIATED(matrix),cp_failure_level,routineP,error,failure)
    CPPostcondition(matrix%ref_count==1,cp_warning_level,routineP,error,failure)
  END SUBROUTINE fm_pool_create_matrix
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pool_create_matrix_vect [1.0] *
!!
!!   NAME
!!     fm_pool_create_matrix_vect
!!
!!   SYNOPSIS
!!     Subroutine fm_pool_create_matrix_vect(pool, n_matrixes, matrixes,&
!!         name, error)
!!       Type(cp_fm_pool_type), Pointer:: pool
!!       Integer, Intent (IN):: n_matrixes
!!       Type(cp_full_matrix_p_type), Dimension(:), Pointer:: matrixes
!!       Character(Len=*), Intent (IN), Optional:: name
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pool_create_matrix_vect
!!
!!   FUNCTION
!!     returns a vector of identical matrixes, allocating it if none
!!     is in the pool
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool from where you get the matrix
!!     - n_matrixes: the number of matrixes in the vector
!!     - matrixes: will contain the new matrix vector
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_create_matrix_vect(pool, n_matrixes, matrixes, name,&
       error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    INTEGER, INTENT(in) :: n_matrixes
    TYPE(cp_full_matrix_p_type), DIMENSION(:), POINTER :: matrixes
    CHARACTER(len=*), INTENT(in), OPTIONAL :: name
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_create_matrix_vect',&
         routineP=moduleN//':'//routineN
    INTEGER :: stat,i
    failure=.FALSE.

    CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
    CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
    ALLOCATE(matrixes(n_matrixes), stat=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    IF (.NOT.failure) THEN
       DO i=1,n_matrixes
          NULLIFY(matrixes(i)%matrix)
          IF (PRESENT(name)) THEN
             CALL fm_pool_create_matrix(pool,matrixes(i)%matrix,&
                  name=name//"-"//ADJUSTL(cp_to_string(i)),&
                  error=error)
          ELSE
             CALL fm_pool_create_matrix(pool,matrixes(i)%matrix,error=error)
          END IF
       END DO
    END IF
  END SUBROUTINE fm_pool_create_matrix_vect
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pool_give_back_matrix [1.0] *
!!
!!   NAME
!!     fm_pool_give_back_matrix
!!
!!   SYNOPSIS
!!     Subroutine fm_pool_give_back_matrix(pool, matrix, error)
!!       Type(cp_fm_pool_type), Pointer:: pool
!!       Type(cp_full_matrix_type), Pointer:: matrix
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pool_give_back_matrix
!!
!!   FUNCTION
!!     returns the matrix to the pool
!!
!!   NOTES
!!     transfers the ownership of the matrix to the pool
!!     (it is as if you had called cp_fm_release)
!!     Accept give_backs of non associated matrixes?
!!
!!   INPUTS
!!     - pool: the pool where to cache the matrix
!!     - matrix: the matrix to give back
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_give_back_matrix(pool, matrix, error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_full_matrix_type), POINTER :: matrix
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_give_back_matrix',&
         routineP=moduleN//':'//routineN
    INTEGER :: stat
    failure=.FALSE.

    CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
    CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(matrix),cp_warning_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       CALL cp_assert(pool%matrix_struct%id_nr==matrix%matrix_struct%id_nr,&
            cp_failure_level, cp_assertion_failed, routineP,&
            "pool cannot reuse matrixes with another structure "//&
            CPSourceFileRef,&
            error=error,failure=failure)
    END IF

    IF (.NOT. failure) THEN
       CPPreconditionNoFail(matrix%ref_count==1,cp_warning_level,routineP,error)
       CALL cp_sll_fm_insert_el(pool%cache, element=matrix)
    END IF
    NULLIFY(matrix)
  END SUBROUTINE fm_pool_give_back_matrix
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pool_give_back_matrix_vect [1.0] *
!!
!!   NAME
!!     fm_pool_give_back_matrix_vect
!!
!!   SYNOPSIS
!!     Subroutine fm_pool_give_back_matrix_vect(pool, matrixes, error)
!!       Type(cp_fm_pool_type), Pointer:: pool
!!       Type(cp_full_matrix_p_type), Dimension(:), Pointer:: matrixes
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pool_give_back_matrix_vect
!!
!!   FUNCTION
!!     returns the matrix to the pool
!!
!!   NOTES
!!     transfers the ownership of the matrixes to the pool
!!     and deallocates the array of matrixes
!!     (it is as if you had called cp_fm_vect_dealloc)
!!     Accept give_backs of non associated matrixes?
!!
!!   INPUTS
!!     - pool: the pool where to cache the matrix
!!     - matrixes: the matrixes to give back
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE fm_pool_give_back_matrix_vect(pool, matrixes, error)
    TYPE(cp_fm_pool_type), POINTER :: pool
    TYPE(cp_full_matrix_p_type), DIMENSION(:), POINTER :: matrixes
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='fm_pool_give_back_matrix_vect',&
         routineP=moduleN//':'//routineN
    INTEGER :: stat,i
    failure=.FALSE.

    CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
    CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(matrixes),cp_warning_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       DO i=1,SIZE(matrixes)
          IF (ASSOCIATED(matrixes(i)%matrix)) THEN
             CALL fm_pool_give_back_matrix(pool, matrixes(i)%matrix,&
                  error=error)
          END IF
       END DO
       DEALLOCATE(matrixes,stat=stat)
       CPPostconditionNoFail(stat==0,cp_warning_level,routineP,error)
    END IF
    NULLIFY(matrixes)
  END SUBROUTINE fm_pool_give_back_matrix_vect
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pool_get_mstruct [1.0] *
!!
!!   NAME
!!     fm_pool_get_mstruct
!!
!!   SYNOPSIS
!!     Function fm_pool_get_mstruct(pool, error) Result(res)
!!       Type(cp_fm_struct_type), Pointer:: res
!!       Type(cp_fm_pool_type), Pointer:: pool
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Function fm_pool_get_mstruct
!!
!!   FUNCTION
!!     returns the matrix structure of this pool
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pool: the pool you are interested in
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     05.2002 created [fawzi]
!!
!!*** **********************************************************************
FUNCTION fm_pool_get_mstruct(pool,error) RESULT(res)
  TYPE(cp_fm_struct_type), POINTER       :: res
  TYPE(cp_fm_pool_type), POINTER               :: pool
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure
  CHARACTER(len=*), PARAMETER :: routineN='fm_pool_get_mstruct',&
        routineP=moduleN//':'//routineN
  failure=.FALSE.
  
  CPPrecondition(ASSOCIATED(pool),cp_failure_level,routineP,error,failure)
  CPPrecondition(pool%ref_count>0,cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
     res => pool%matrix_struct
  ELSE
     NULLIFY(res)
  END IF
END FUNCTION fm_pool_get_mstruct
!***************************************************************************

!================== pools ================

!!****f* cp_fm_pool_types/fm_pools_copy [1.0] *
!!
!!   NAME
!!     fm_pools_copy
!!
!!   SYNOPSIS
!!     Subroutine fm_pools_copy(source_pools, target_pools, error)
!!       Type(cp_fm_pool_p_type), Dimension(:), Pointer:: source_pools,&
!!         target_pools
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pools_copy
!!
!!   FUNCTION
!!     shallow copy of an array of pools (retains each pool)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - source_pools: the pools to copy
!!     - target_pools: will contains the new pools
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     11.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE fm_pools_copy(source_pools, target_pools, error)
  TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER :: source_pools,&
       target_pools
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure
  INTEGER :: stat, i
  CHARACTER(len=*), PARAMETER :: routineN='fm_pools_copy',&
        routineP=moduleN//':'//routineN
  failure=.FALSE.
  
  CPPrecondition(ASSOCIATED(source_pools),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
     ALLOCATE(target_pools(SIZE(source_pools)),stat=stat)
     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  END IF
  IF (.NOT.failure) THEN
     DO i=1,SIZE(source_pools)
        target_pools(i)%pool => source_pools(i)%pool
        CALL fm_pool_retain(source_pools(i)%pool,error=error)
     END DO
  END IF
END SUBROUTINE fm_pools_copy
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pools_dealloc [1.0] *
!!
!!   NAME
!!     fm_pools_dealloc
!!
!!   SYNOPSIS
!!     Subroutine fm_pools_dealloc(pools, error)
!!       Type(cp_fm_pool_p_type), Dimension(:), Pointer:: pools
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pools_dealloc
!!
!!   FUNCTION
!!     deallocate an array of pools (releasing each pool)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pools: the pools to release
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     11.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE fm_pools_dealloc(pools, error)
  TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER :: pools
  TYPE(cp_error_type), OPTIONAL, INTENT(inout)   :: error
  
  LOGICAL :: failure
  INTEGER :: stat, i
  CHARACTER(len=*), PARAMETER :: routineN='fm_pools_dealloc',&
        routineP=moduleN//':'//routineN
  failure=.FALSE.
  
  IF (ASSOCIATED(pools)) THEN
     DO i=1,SIZE(pools)
        CALL fm_pool_release(pools(i)%pool,error=error)
     END DO
     DEALLOCATE(pools,stat=stat)
     CPPostconditionNoFail(stat==0,cp_warning_level,routineP,error)
  END IF
END SUBROUTINE fm_pools_dealloc
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pools_flush_cache [1.0] *
!!
!!   NAME
!!     fm_pools_flush_cache
!!
!!   SYNOPSIS
!!     Subroutine fm_pools_flush_cache(pools, error)
!!       Type(cp_fm_pool_p_type), Dimension(:), Pointer:: pools
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pools_flush_cache
!!
!!   FUNCTION
!!     deallocates all the cached matrixes of an array of pools
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pools: the pools to flush
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     09.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE fm_pools_flush_cache(pools, error)
  TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER :: pools
  TYPE(cp_error_type), OPTIONAL, INTENT(inout)   :: error
  
  LOGICAL :: failure
  INTEGER :: stat,i
  CHARACTER(len=*), PARAMETER :: routineN='fm_pools_flush_cache',&
        routineP=moduleN//':'//routineN
  failure=.FALSE.
  
  CPPrecondition(ASSOCIATED(pools),cp_failure_level,routineP,error,failure)
  IF (.NOT.failure) THEN
     DO i=1,SIZE(pools)
        CALL fm_pool_flush_cache(pools(i)%pool,error=error)
     END DO
  END IF
END SUBROUTINE fm_pools_flush_cache
!***************************************************************************

!!****f* cp_fm_pool_types/fm_pools_create_matrix_vect [1.0] *
!!
!!   NAME
!!     fm_pools_create_matrix_vect
!!
!!   SYNOPSIS
!!     Subroutine fm_pools_create_matrix_vect(pools, matrixes, name, error)
!!       Type(cp_fm_pool_p_type), Dimension(:), Pointer:: pools
!!       Type(cp_full_matrix_p_type), Dimension(:), Pointer:: matrixes
!!       Character(Len=*), Optional, Intent (IN):: name
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pools_create_matrix_vect
!!
!!   FUNCTION
!!     Returns a matrix vector with a matrix from each pool
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - pools: the pools to create the matrix from
!!     - matrixes: will contain the vector of matrixes
!!     - name: optionally a name for the matrixes
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     09.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE fm_pools_create_matrix_vect(pools,matrixes,name,error)
  TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER :: pools
  TYPE(cp_full_matrix_p_type), DIMENSION(:), POINTER :: matrixes
  CHARACTER(len=*), OPTIONAL, INTENT(in) :: name
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure
  INTEGER :: stat,i
  CHARACTER(len=*), PARAMETER :: routineN='fm_pools_create_matrix_vect',&
        routineP=moduleN//':'//routineN
  failure=.FALSE.
  
  CPPrecondition(ASSOCIATED(pools),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
     ALLOCATE(matrixes(SIZE(pools)),stat=stat)
     CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  END IF
  IF (.NOT.failure) THEN
     DO i=1,SIZE(pools)
        NULLIFY(matrixes(i)%matrix)
        IF (PRESENT(name)) THEN
           CALL fm_pool_create_matrix(pools(i)%pool,matrixes(i)%matrix,&
                name=name//'-'//ADJUSTL(cp_to_string(i)),error=error)
        ELSE
           CALL fm_pool_create_matrix(pools(i)%pool,matrixes(i)%matrix,&
                error=error)
        END IF
     END DO
  END IF
END SUBROUTINE fm_pools_create_matrix_vect
!***************************************************************************

!!****f* cp_fm_pool_p_types/fm_pools_give_back_matrix_vect [1.0] *
!!
!!   NAME
!!     fm_pools_give_back_matrix_vect
!!
!!   SYNOPSIS
!!     Subroutine fm_pools_give_back_matrix_vect(pools, matrixes, error)
!!       Type(cp_fm_pool_p_type), Dimension(:), Pointer:: pools
!!       Type(cp_full_matrix_p_type), Dimension(:), Pointer:: matrixes
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine fm_pools_give_back_matrix_vect
!!
!!   FUNCTION
!!     returns a matrix vector to the pools. The vector is deallocated
!!     (like cp_fm_vect_dealloc)
!!
!!   NOTES
!!     accept unassociated vect?
!!
!!   INPUTS
!!     - pools: the pool where to give back the matrix vector
!!     - matrixes: the matrixes to give back
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     09.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE fm_pools_give_back_matrix_vect(pools,matrixes,error)
  TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER :: pools
  TYPE(cp_full_matrix_p_type), DIMENSION(:), POINTER :: matrixes
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure
  INTEGER :: i, stat
  CHARACTER(len=*), PARAMETER :: routineN='fm_pools_give_back_matrix_vect',&
        routineP=moduleN//':'//routineN
  failure=.FALSE.
  
  CPPrecondition(ASSOCIATED(pools),cp_failure_level,routineP,error,failure)
  CPPrecondition(ASSOCIATED(matrixes),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
     DO i=1,SIZE(pools)
        CALL fm_pool_give_back_matrix(pools(i)%pool,&
             matrixes(i)%matrix,error=error)
     END DO
  END IF
END SUBROUTINE fm_pools_give_back_matrix_vect
!***************************************************************************

END MODULE cp_fm_pool_types
