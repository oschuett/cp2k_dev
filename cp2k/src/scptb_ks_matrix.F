!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2012  CP2K developers group                          !
!-----------------------------------------------------------------------------!

! *****************************************************************************
!> \brief Calculation of Hamiltonian matrices in SCPTB
!> \author JGH
! *****************************************************************************
MODULE scptb_ks_matrix
  USE atomic_kind_types,               ONLY: atomic_kind_type,&
                                             get_atomic_kind,&
                                             get_atomic_kind_set
  USE cell_types,                      ONLY: cell_type,&
                                             get_cell,&
                                             pbc
  USE cp_control_types,                ONLY: dft_control_type,&
                                             scptb_control_type
  USE cp_dbcsr_interface,              ONLY: cp_dbcsr_add,&
                                             cp_dbcsr_copy,&
                                             cp_dbcsr_get_block_p,&
                                             cp_dbcsr_iterator_blocks_left,&
                                             cp_dbcsr_iterator_next_block,&
                                             cp_dbcsr_iterator_start,&
                                             cp_dbcsr_iterator_stop,&
                                             cp_dbcsr_multiply
  USE cp_dbcsr_types,                  ONLY: cp_dbcsr_iterator,&
                                             cp_dbcsr_p_type,&
                                             cp_dbcsr_type
  USE cp_output_handling,              ONLY: cp_print_key_finished_output,&
                                             cp_print_key_unit_nr
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE distribution_1d_types,           ONLY: distribution_1d_type
  USE ewald_environment_types,         ONLY: ewald_env_get,&
                                             ewald_environment_type
  USE ewald_pw_types,                  ONLY: ewald_pw_type
  USE f77_blas
  USE gamma,                           ONLY: fgamma_0
  USE input_constants,                 ONLY: do_ewald_ewald,&
                                             do_ewald_none,&
                                             do_ewald_pme,&
                                             do_ewald_spme
  USE input_section_types,             ONLY: section_vals_get_subs_vals,&
                                             section_vals_type
  USE kinds,                           ONLY: dp
  USE mathconstants,                   ONLY: oorootpi,&
                                             pi
  USE message_passing,                 ONLY: mp_sum
  USE mulliken,                        ONLY: mulliken_charges
  USE orbital_pointers,                ONLY: indso
  USE particle_types,                  ONLY: particle_type
  USE pw_env_types,                    ONLY: pw_env_get,&
                                             pw_env_type
  USE pw_methods,                      ONLY: pw_transfer
  USE pw_poisson_methods,              ONLY: pw_poisson_solve
  USE pw_poisson_types,                ONLY: pw_poisson_type
  USE pw_pool_types,                   ONLY: pw_pool_create_pw,&
                                             pw_pool_give_back_pw,&
                                             pw_pool_p_type,&
                                             pw_pool_type
  USE pw_types,                        ONLY: COMPLEXDATA1D,&
                                             REALDATA3D,&
                                             REALSPACE,&
                                             RECIPROCALSPACE,&
                                             pw_p_type
  USE qs_collocate_density,            ONLY: calculate_scp_charge
  USE qs_dftb_coulomb,                 ONLY: dftb_ewald_overlap,&
                                             dftb_spme_evaluate
  USE qs_energy_types,                 ONLY: qs_energy_type
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_environment_type
  USE qs_force_types,                  ONLY: qs_force_type
  USE qs_integrate_potential,          ONLY: integrate_scp_rspace
  USE qs_ks_types,                     ONLY: qs_ks_env_type
  USE qs_mo_types,                     ONLY: get_mo_set,&
                                             mo_set_p_type
  USE qs_neighbor_list_types,          ONLY: get_iterator_info,&
                                             neighbor_list_iterate,&
                                             neighbor_list_iterator_create,&
                                             neighbor_list_iterator_p_type,&
                                             neighbor_list_iterator_release,&
                                             neighbor_list_set_p_type
  USE qs_rho_types,                    ONLY: qs_rho_type
  USE scptb_types,                     ONLY: &
       get_scptb_parameter, scp_vector_add, scp_vector_copy, &
       scp_vector_create, scp_vector_dot, scp_vector_release, &
       scp_vector_scale, scp_vector_set, scp_vector_type, scptb_parameter_type
  USE timings,                         ONLY: timeset,&
                                             timestop
  USE virial_methods,                  ONLY: virial_pair_force
  USE virial_types,                    ONLY: virial_type
#include "cp_common_uses.h"

  IMPLICIT NONE

  PRIVATE

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'scptb_ks_matrix'

  PUBLIC :: build_scptb_ks_matrix

CONTAINS

! *****************************************************************************
  SUBROUTINE build_scptb_ks_matrix (ks_env,qs_env,ks_matrix,rho,energy,&
               calculate_forces,just_energy,error)

    TYPE(qs_ks_env_type), POINTER            :: ks_env
    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: ks_matrix
    TYPE(qs_rho_type), POINTER               :: rho
    TYPE(qs_energy_type), POINTER            :: energy
    LOGICAL, INTENT(in)                      :: calculate_forces, just_energy
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'build_scptb_ks_matrix', &
      routineP = moduleN//':'//routineN

    INTEGER :: atom_a, handle, iatom, ikind, ispin, istat, lmaxscp, natom, &
      natom_kind, nkind, nspins, output_unit
    LOGICAL                                  :: do_es, do_scp, failure
    REAL(KIND=dp)                            :: zeff
    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: mcharge
    REAL(KIND=dp), DIMENSION(:), POINTER     :: occupation_numbers
    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: charges, dmcharge
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_h, matrix_p, matrix_s, &
                                                mo_derivs
    TYPE(cp_dbcsr_type), POINTER             :: mo_coeff
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mo_array
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(scptb_control_type), POINTER        :: scptb_control
    TYPE(scptb_parameter_type), POINTER      :: scptb_kind
    TYPE(section_vals_type), POINTER         :: scf_section

    CALL timeset(routineN,handle)

    NULLIFY(dft_control, logger, scf_section)
    NULLIFY(matrix_p, particle_set)

    logger => cp_error_get_logger(error)

    failure=.FALSE.
    CPPrecondition(ASSOCIATED(ks_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(ks_env%ref_count>0,cp_failure_level,routineP,error,failure)

    IF ( .NOT. failure ) THEN

      CALL get_qs_env(qs_env=qs_env,&
           dft_control=dft_control,&
           atomic_kind_set=atomic_kind_set,&
           matrix_h=matrix_h,&
           para_env=para_env,error=error)

      scf_section => section_vals_get_subs_vals(qs_env%input,"DFT%SCF",error=error)
      nspins=dft_control%nspins
      CPPrecondition(ASSOCIATED(matrix_h),cp_failure_level,routineP,error,failure)
      CPPrecondition(ASSOCIATED(rho),cp_failure_level,routineP,error,failure)
      CPPrecondition(SIZE(ks_matrix)>0,cp_failure_level,routineP,error,failure)

      do_es = .FALSE.
      do_scp = .FALSE.
      nkind = SIZE(atomic_kind_set)
      DO ikind=1,nkind
        atomic_kind => atomic_kind_set(ikind)
        CALL get_atomic_kind(atomic_kind=atomic_kind,natom=natom_kind,scptb_parameter=scptb_kind)
        CALL get_scptb_parameter(scptb_kind,lmaxscp=lmaxscp)
        IF(lmaxscp > 0) do_scp = .TRUE.
        IF(lmaxscp >= 0) do_es = .TRUE.
      END DO
      scptb_control => dft_control%qs_control%scptb_control
      IF(.NOT.scptb_control%do_scp) do_scp = .FALSE.

      DO ispin=1,nspins
        ! copy the core matrix into the fock matrix
         CALL cp_dbcsr_copy(ks_matrix(ispin)%matrix,matrix_h(1)%matrix,error=error)
      END DO

      IF (do_es) THEN
         ! Mulliken charges
         CALL get_qs_env(qs_env=qs_env,particle_set=particle_set,matrix_s=matrix_s,error=error)
         matrix_p => rho%rho_ao
         natom=SIZE(particle_set)
         ALLOCATE(charges(natom,nspins),STAT=istat)
         CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
         ALLOCATE(mcharge(natom),STAT=istat)
         CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
         IF(calculate_forces) THEN
            ALLOCATE(dmcharge(natom,3),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            CALL mulliken_charges(matrix_p,matrix_s,para_env,charges,dmcharge,error=error)
         ELSE
            NULLIFY(dmcharge)
            charges = 0._dp
            CALL mulliken_charges(matrix_p,matrix_s(1)%matrix,para_env,charges,error=error)
         END IF
         nkind = SIZE(atomic_kind_set)
         DO ikind=1,nkind
            atomic_kind => atomic_kind_set(ikind)
            CALL get_atomic_kind(atomic_kind=atomic_kind,natom=natom_kind,scptb_parameter=scptb_kind)
            CALL get_scptb_parameter(scptb_kind,zeff=zeff)
            DO iatom=1,natom_kind
              atom_a = atomic_kind%atom_list(iatom)
              mcharge(atom_a) = zeff - SUM(charges(atom_a,1:nspins))
            END DO
         END DO
         DEALLOCATE(charges,STAT=istat)
         CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

         IF (do_scp) THEN
            CALL scp_coulomb(qs_env,ks_matrix,matrix_s,rho,mcharge,dmcharge,calculate_forces,just_energy,error)
         ELSE
            CALL tb_coulomb(qs_env,ks_matrix,matrix_s,rho,mcharge,dmcharge,calculate_forces,just_energy,error)
         END IF

         DEALLOCATE(mcharge,STAT=istat)
         CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
         IF(calculate_forces) THEN
            DEALLOCATE(dmcharge,STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
         END IF
      ELSE
         energy%hartree = 0._dp
         energy%core_self = 0._dp
      END IF

      energy%total = energy%core + energy%hartree + energy%qmmm_el + energy%repulsive + &
                     energy%core_self + energy%dispersion

      output_unit=cp_print_key_unit_nr(logger,scf_section,"PRINT%DETAILED_ENERGY",&
         extension=".scfLog",error=error)
      IF (output_unit>0) THEN
          WRITE (UNIT=output_unit,FMT="(/,(T9,A,T60,F20.10))")&
               "Repulsive pair potential energy:               ",energy%repulsive,&
               "Zeroth order Hamiltonian energy:               ",energy%core,&
               "Total kinetic energy:                          ",energy%kinetic,&
               "Charge fluctuation (SCP) energy:               ",energy%hartree,&
               "SCP self energy:                               ",energy%core_self,&
               "London dispersion energy:                      ",energy%dispersion
          IF (qs_env%qmmm) THEN
             WRITE (UNIT=output_unit,FMT="(T3,A,T60,F20.10)")&
                  "QM/MM Electrostatic energy:                    ",energy%qmmm_el
          END IF
      END IF
      CALL cp_print_key_finished_output(output_unit,logger,scf_section,&
           "PRINT%DETAILED_ENERGY", error=error)
       ! here we compute dE/dC if needed. Assumes dE/dC is H_{ks}C (plus occupation numbers)
      IF (qs_env%requires_mo_derivs .AND. .NOT. just_energy) THEN
         CALL get_qs_env(qs_env,mo_derivs=mo_derivs,mos=mo_array,error=error)
         DO ispin=1,SIZE(mo_derivs)
            CALL get_mo_set(mo_set=mo_array(ispin)%mo_set,&
                 mo_coeff_b=mo_coeff, occupation_numbers=occupation_numbers )
            IF(.NOT.mo_array(ispin)%mo_set%use_mo_coeff_b) THEN
               CPPrecondition(.FALSE.,cp_failure_level,routineP,error,failure)
            ENDIF
            CALL cp_dbcsr_multiply('n','n',1.0_dp,ks_matrix(ispin)%matrix,mo_coeff,&
                 0.0_dp,mo_derivs(ispin)%matrix, error=error)
         ENDDO
      ENDIF

    END IF

    CALL timestop(handle)

  END SUBROUTINE build_scptb_ks_matrix

! *****************************************************************************
  SUBROUTINE tb_coulomb(qs_env,ks_matrix,matrix_s,rho,mcharge,dmcharge,&
             calculate_forces,just_energy,error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: ks_matrix, matrix_s
    TYPE(qs_rho_type), POINTER               :: rho
    REAL(KIND=dp), DIMENSION(:), &
      INTENT(inout)                          :: mcharge
    REAL(KIND=dp), DIMENSION(:, :), &
      INTENT(inout)                          :: dmcharge
    LOGICAL, INTENT(in)                      :: calculate_forces, just_energy
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'tb_coulomb', &
      routineP = moduleN//':'//routineN

    INTEGER :: blk, ewald_type, i, ia, iat, iatom, ikind, is, istat, ja, jat, &
      jatom, jkind, lmaxscp, nai, naj, natom, ndim, nkind, nsize
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: atom_of_kind, kind_of
    INTEGER, DIMENSION(3)                    :: periodic
    INTEGER, DIMENSION(:), POINTER           :: atomi_list, atomj_list
    LOGICAL                                  :: defined, failure, found, &
                                                use_virial
    REAL(KIND=dp)                            :: alpha, beta, chabs, deth, dq, &
                                                dr, dr2, ehartree, eta, f0, &
                                                ff, fi, gmij, noa, nob, t
    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: qcharge
    REAL(KIND=dp), ALLOCATABLE, &
      DIMENSION(:, :)                        :: drcharge, gmcharge
    REAL(KIND=dp), DIMENSION(0:1)            :: f
    REAL(KIND=dp), DIMENSION(3)              :: fij, rij
    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: dsblock, ksblock, pblock, &
                                                sblock
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cell_type), POINTER                 :: cell
    TYPE(cp_dbcsr_iterator)                  :: iter
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: matrix_p
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(distribution_1d_type), POINTER      :: local_particles
    TYPE(ewald_environment_type), POINTER    :: ewald_env
    TYPE(ewald_pw_type), POINTER             :: ewald_pw
    TYPE(neighbor_list_iterator_p_type), &
      DIMENSION(:), POINTER                  :: nl_iterator
    TYPE(neighbor_list_set_p_type), &
      DIMENSION(:), POINTER                  :: n_list
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(qs_energy_type), POINTER            :: energy
    TYPE(qs_force_type), DIMENSION(:), &
      POINTER                                :: force
    TYPE(scptb_control_type), POINTER        :: scptb_control
    TYPE(scptb_parameter_type), POINTER      :: scptb_kind
    TYPE(virial_type), POINTER               :: virial

    CALL get_qs_env(qs_env=qs_env,dft_control=dft_control,&
         energy=energy,para_env=para_env,&
         particle_set=particle_set,cell=cell,error=error)
    CALL get_qs_env(qs_env=qs_env,atomic_kind_set=atomic_kind_set,&
                    local_particles=local_particles,natom=natom,error=error)
    ndim = 1
    IF (calculate_forces) THEN
       CALL get_qs_env(qs_env=qs_env,force=force,error=error)
       ndim = 4
    END IF
    use_virial=.FALSE.

    energy%hartree = 0._dp
    energy%core_self = 0._dp

    chabs = SUM(ABS(mcharge))
    CALL mp_sum(chabs,para_env%group)
    IF ( chabs > 1.e-8_dp ) THEN
       scptb_control => dft_control%qs_control%scptb_control
       IF(scptb_control%do_ewald) THEN
          ALLOCATE(gmcharge(natom,ndim),STAT=istat)
          CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
          gmcharge = 0._dp
          ! Ewald sum
          NULLIFY(ewald_env,ewald_pw)
          CALL get_qs_env(qs_env=qs_env,ewald_env=ewald_env,ewald_pw=ewald_pw,error=error)
          CALL get_cell(cell=cell,periodic=periodic,deth=deth)
          CALL ewald_env_get(ewald_env,alpha=alpha,ewald_type=ewald_type,error=error)
          CALL get_qs_env(qs_env=qs_env,sab_tbe=n_list,error=error)
          CALL dftb_ewald_overlap(gmcharge,mcharge,alpha,n_list,&
                                  virial,use_virial,qs_env%atprop,error=error)
          SELECT CASE(ewald_type)
          CASE DEFAULT
            CALL cp_unimplemented_error(routineP,"Invalid Ewald type",error)
          CASE(do_ewald_none)
            CPErrorMessage(cp_failure_level,routineP,"Not allowed with SCPTB",error)
            CPPostcondition(.FALSE.,cp_failure_level,routineP,error,failure)
          CASE(do_ewald_ewald)
            CALL cp_unimplemented_error(routineP,&
                 "Standard Ewald not implemented in SCPTB",error)
          CASE(do_ewald_pme)
            CALL cp_unimplemented_error(routineP,&
                 "PME not implemented in SCPTB",error)
          CASE(do_ewald_spme)
            CALL dftb_spme_evaluate(ewald_env,ewald_pw,particle_set,cell,&
              gmcharge,mcharge,calculate_forces,virial,use_virial,qs_env%atprop,error)
          END SELECT

          ! add self charge interaction and background charge contribution
          CALL mp_sum(gmcharge(:,1),para_env%group)
          gmcharge(:,1) = gmcharge(:,1) - 2._dp*alpha*oorootpi*mcharge(:)
          IF ( ANY (periodic(:)==1) ) THEN
            gmcharge(:,1) = gmcharge(:,1) - pi / alpha**2 / deth
          END IF
          energy%hartree = energy%hartree + 0.5_dp*SUM(mcharge(:)*gmcharge(:,1))
          IF ( calculate_forces ) THEN
            ALLOCATE (atom_of_kind(natom),kind_of(natom),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)

            CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set,&
                                     kind_of=kind_of,&
                                     atom_of_kind=atom_of_kind)

            gmcharge(:,2)=gmcharge(:,2)*mcharge(:)
            gmcharge(:,3)=gmcharge(:,3)*mcharge(:)
            gmcharge(:,4)=gmcharge(:,4)*mcharge(:)
            DO iatom=1,natom
              ikind  = kind_of(iatom)
              iat = atom_of_kind(iatom)
              force(ikind)%rho_elec(1,iat) = force(ikind)%rho_elec(1,iat) - gmcharge(iatom,2)
              force(ikind)%rho_elec(2,iat) = force(ikind)%rho_elec(2,iat) - gmcharge(iatom,3)
              force(ikind)%rho_elec(3,iat) = force(ikind)%rho_elec(3,iat) - gmcharge(iatom,4)
            END DO
          END IF
          IF ( .NOT. just_energy ) THEN
            CALL get_qs_env(qs_env=qs_env,matrix_s=matrix_s,error=error)
            matrix_p => rho%rho_ao
            IF ( calculate_forces .AND. SIZE(matrix_p) == 2) THEN
              CALL cp_dbcsr_add(matrix_p(1)%matrix,matrix_p(2)%matrix,&
                   alpha_scalar=1.0_dp,beta_scalar=1.0_dp,error=error)
            END IF

            nsize = SIZE(ks_matrix)
            CALL cp_dbcsr_iterator_start(iter,matrix_s(1)%matrix)
            DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
               CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sblock, blk)
               gmij = 0.5_dp*(gmcharge(iatom,1)+gmcharge(jatom,1))
               DO is=1,nsize
                  NULLIFY(ksblock)
                  CALL cp_dbcsr_get_block_p(matrix=ks_matrix(is)%matrix,&
                       row=iatom,col=jatom,block=ksblock,found=found)
                  CPPostcondition(found,cp_failure_level,routineP,error,failure)
                  ksblock = ksblock - gmij*sblock
               END DO
               IF ( calculate_forces ) THEN
                  ikind  = kind_of(iatom)
                  iat = atom_of_kind(iatom)
                  jkind  = kind_of(jatom)
                  jat = atom_of_kind(jatom)
                  NULLIFY(pblock)
                  CALL cp_dbcsr_get_block_p(matrix=matrix_p(1)%matrix,&
                       row=iatom,col=jatom,block=pblock,found=found)
                  DO i=1,3
                     NULLIFY(dsblock)
                     CALL cp_dbcsr_get_block_p(matrix=matrix_s(1+i)%matrix,&
                          row=iatom,col=jatom,block=dsblock,found=found)
                     fi = -gmij*SUM(pblock*dsblock)
                     force(ikind)%rho_elec(i,iat) = force(ikind)%rho_elec(i,iat) + fi
                     force(jkind)%rho_elec(i,jat) = force(jkind)%rho_elec(i,jat) - fi
                     fij(i) = fi
                  END DO
                  IF (use_virial) THEN
                     rij = particle_set(iatom)%r - particle_set(jatom)%r
                     rij = pbc(rij,cell)
                     CALL virial_pair_force ( virial%pv_virial, -1._dp, fij, rij, error)
                     IF (qs_env%atprop%stress) THEN
                       CALL virial_pair_force ( qs_env%atprop%atstress(:,:,iatom), -0.5_dp, fij, rij, error)
                       CALL virial_pair_force ( qs_env%atprop%atstress(:,:,jatom), -0.5_dp, fij, rij, error)
                     END IF
                  END IF
               END IF
            END DO
            CALL cp_dbcsr_iterator_stop(iter)
            IF ( calculate_forces .AND. SIZE(matrix_p) == 2) THEN
               CALL cp_dbcsr_add(matrix_p(1)%matrix,matrix_p(2)%matrix,&
                              alpha_scalar=1.0_dp,beta_scalar=-1.0_dp,error=error)
            END IF
          END IF
          ! direct sum correction for Gaussians
          ehartree = 0._dp
          IF(.NOT.just_energy .OR. calculate_forces) THEN
            ALLOCATE(qcharge(natom),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            qcharge = 0._dp
          END IF
          IF (calculate_forces) THEN
            ALLOCATE(drcharge(3,natom),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            drcharge = 0._dp
          END IF
          NULLIFY(n_list)
          CALL get_qs_env(qs_env=qs_env,sab_scp=n_list,error=error)
          CALL neighbor_list_iterator_create(nl_iterator,n_list)
          DO WHILE (neighbor_list_iterate(nl_iterator)==0)
             CALL get_iterator_info(nl_iterator,ikind=ikind,jkind=jkind,iatom=iatom,jatom=jatom,r=rij)

             dr2 = SUM(rij(:)**2)
             dr = SQRT(dr2)
             IF (dr > 1.e-10) THEN
                atomic_kind => atomic_kind_set(ikind)
                CALL get_atomic_kind(atomic_kind=atomic_kind,scptb_parameter=scptb_kind)
                CALL get_scptb_parameter(scptb_kind,lmaxscp=lmaxscp,ag=alpha)
                IF (lmaxscp < 0) CYCLE
                noa = (alpha/pi)**1.5_dp
                atomic_kind => atomic_kind_set(jkind)
                CALL get_atomic_kind(atomic_kind=atomic_kind,scptb_parameter=scptb_kind)
                CALL get_scptb_parameter(scptb_kind,lmaxscp=lmaxscp,ag=beta)
                IF (lmaxscp < 0) CYCLE
                eta = alpha*beta/(alpha+beta)
                f0 = 2.0_dp*SQRT(pi**5*(alpha+beta))/(alpha*beta)
                nob = (beta/pi)**1.5_dp
                t = eta*dr*dr
                CALL fgamma_0(0,t,f)
                ff = noa*nob*f(0)*f0
                ehartree = ehartree + mcharge(iatom)*mcharge(jatom)*ff
                ehartree = ehartree - mcharge(iatom)*mcharge(jatom)/dr
                IF (.NOT.just_energy .OR. calculate_forces) THEN
                   qcharge(iatom) = qcharge(iatom) + mcharge(jatom)*ff
                   qcharge(iatom) = qcharge(iatom) - mcharge(jatom)/dr
                   qcharge(jatom) = qcharge(jatom) + mcharge(iatom)*ff
                   qcharge(jatom) = qcharge(jatom) - mcharge(iatom)/dr
                END IF
                IF ( calculate_forces ) THEN
                   ff = noa*nob*f0*(EXP(-t)-f(0))/dr2
                   drcharge(:,iatom) = drcharge(:,iatom) + ff*rij(:)*mcharge(iatom)*mcharge(jatom)
                   drcharge(:,jatom) = drcharge(:,jatom) - ff*rij(:)*mcharge(iatom)*mcharge(jatom)
                   drcharge(:,iatom) = drcharge(:,iatom) - rij(:)/(dr*dr2)*mcharge(iatom)*mcharge(jatom)
                   drcharge(:,jatom) = drcharge(:,jatom) + rij(:)/(dr*dr2)*mcharge(iatom)*mcharge(jatom)
                END IF

             END IF

          END DO
          CALL neighbor_list_iterator_release(nl_iterator)
          CALL mp_sum(ehartree,para_env%group)
          energy%hartree = energy%hartree + ehartree

          IF(.NOT.just_energy.OR.calculate_forces) THEN
            IF ( calculate_forces ) THEN
               matrix_p => rho%rho_ao
               IF (SIZE(matrix_p) == 2) THEN
                  CALL cp_dbcsr_add(matrix_p(1)%matrix,matrix_p(2)%matrix,&
                       alpha_scalar=1.0_dp,beta_scalar=1.0_dp,error=error)
               END IF
            END IF
            ! calculate KS matrix
            CALL mp_sum(qcharge,para_env%group)
            nsize = SIZE(ks_matrix)
            CALL cp_dbcsr_iterator_start(iter,matrix_s(1)%matrix)
            DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
               CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sblock, blk)
               dq = qcharge(iatom)+qcharge(jatom)
               IF(.NOT.just_energy) THEN
                  DO is=1,nsize
                     NULLIFY(ksblock)
                     CALL cp_dbcsr_get_block_p(matrix=ks_matrix(is)%matrix,&
                          row=iatom,col=jatom,block=ksblock,found=found)
                     CPPostcondition(found,cp_failure_level,routineP,error,failure)
                     ksblock = ksblock - 0.5_dp*dq*sblock
                  END DO
               END IF
               IF ( calculate_forces ) THEN
                  ikind = kind_of(iatom)
                  iat   = atom_of_kind(iatom)
                  jkind = kind_of(jatom)
                  jat   = atom_of_kind(jatom)
                  NULLIFY(pblock)
                  CALL cp_dbcsr_get_block_p(matrix=matrix_p(1)%matrix,&
                       row=iatom,col=jatom,block=pblock,found=found)
                  CPPostcondition(found,cp_failure_level,routineP,error,failure)
                  DO i=1,3
                     NULLIFY(dsblock)
                     CALL cp_dbcsr_get_block_p(matrix=matrix_s(1+i)%matrix,&
                          row=iatom,col=jatom,block=dsblock,found=found)
                     CPPostcondition(found,cp_failure_level,routineP,error,failure)
                     fi = dq*SUM(pblock*dsblock)
                     force(ikind)%rho_elec(i,iat) = force(ikind)%rho_elec(i,iat) + fi
                     force(jkind)%rho_elec(i,jat) = force(jkind)%rho_elec(i,jat) - fi
                  END DO
               END IF
            END DO
            CALL cp_dbcsr_iterator_stop(iter)

            IF ( calculate_forces ) THEN
               DO iatom=1,natom
                  ikind  = kind_of(iatom)
                  iat = atom_of_kind(iatom)
                  force(ikind)%rho_elec(1,iat) = force(ikind)%rho_elec(1,iat) + drcharge(1,iatom)
                  force(ikind)%rho_elec(2,iat) = force(ikind)%rho_elec(2,iat) + drcharge(2,iatom)
                  force(ikind)%rho_elec(3,iat) = force(ikind)%rho_elec(3,iat) + drcharge(3,iatom)
               END DO
               IF (SIZE(matrix_p) == 2) THEN
                  CALL cp_dbcsr_add(matrix_p(1)%matrix,matrix_p(2)%matrix,&
                                 alpha_scalar=1.0_dp,beta_scalar=-1.0_dp,error=error)
               END IF
            END IF
          END IF

          DEALLOCATE(gmcharge,STAT=istat)
          CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
          IF(.NOT.just_energy .OR. calculate_forces) THEN
            DEALLOCATE(qcharge,STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
          END IF
          IF ( calculate_forces ) THEN
            DEALLOCATE(drcharge,STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            DEALLOCATE (atom_of_kind,kind_of,STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
          END IF
       ELSE
         ! direct sum
         IF(.NOT.just_energy .OR. calculate_forces) THEN
            ALLOCATE(qcharge(natom),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            qcharge = 0._dp
         END IF
         IF (calculate_forces) THEN
            ALLOCATE(drcharge(3,natom),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            drcharge = 0._dp
         END IF
         nkind = SIZE(atomic_kind_set)
         DO ikind=1,nkind
           atomic_kind => atomic_kind_set(ikind)
           CALL get_atomic_kind(atomic_kind=atomic_kind,natom=nai,atom_list=atomi_list,&
                scptb_parameter=scptb_kind)
           CALL get_scptb_parameter(scptb_kind,defined=defined,lmaxscp=lmaxscp,ag=alpha)
           IF (.NOT.defined) CYCLE
           IF (lmaxscp < 0) CYCLE
           noa = (alpha/pi)**1.5_dp
           DO jkind=1,ikind
             atomic_kind => atomic_kind_set(jkind)
             CALL get_atomic_kind(atomic_kind=atomic_kind,natom=naj,atom_list=atomj_list,&
                  scptb_parameter=scptb_kind)
             CALL get_scptb_parameter(scptb_kind,defined=defined,lmaxscp=lmaxscp,ag=beta)
             eta = alpha*beta/(alpha+beta)
             f0 = 2.0_dp*SQRT(pi**5*(alpha+beta))/(alpha*beta)
             IF (.NOT.defined) CYCLE
             IF (lmaxscp < 0) CYCLE
             nob = (beta/pi)**1.5_dp
             DO ia=1,nai
               iatom=atomi_list(ia)
               DO ja=1,local_particles%n_el(jkind)
                 jatom=local_particles%list(jkind)%array(ja)
                 IF(ikind==jkind .AND. jatom >= iatom) CYCLE
                 rij = particle_set(iatom)%r - particle_set(jatom)%r
                 rij = pbc(rij,cell)
                 dr2 = SUM(rij(:)**2)
                 t = eta*dr2
                 CALL fgamma_0(0,t,f)
                 ff = noa*nob*f(0)*f0
                 energy%hartree = energy%hartree + mcharge(iatom)*mcharge(jatom)*ff
                 IF (.NOT.just_energy .OR. calculate_forces) THEN
                    qcharge(iatom) = qcharge(iatom) + mcharge(jatom)*ff
                    qcharge(jatom) = qcharge(jatom) + mcharge(iatom)*ff
                 END IF
                 IF ( calculate_forces ) THEN
                    ff = noa*nob*f0*(EXP(-t)-f(0))/dr2
                    drcharge(:,iatom) = drcharge(:,iatom) + ff*rij(:)*mcharge(iatom)*mcharge(jatom)
                    drcharge(:,jatom) = drcharge(:,jatom) - ff*rij(:)*mcharge(iatom)*mcharge(jatom)
                 END IF
               END DO
             END DO
           END DO
         END DO
         CALL mp_sum(energy%hartree,para_env%group)
         IF(.NOT.just_energy.OR.calculate_forces) THEN
            CALL mp_sum(qcharge,para_env%group)
            ALLOCATE (atom_of_kind(natom),kind_of(natom),STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set, &
                                     kind_of=kind_of, atom_of_kind=atom_of_kind)
            IF ( calculate_forces ) THEN
               matrix_p => rho%rho_ao
               IF (SIZE(matrix_p) == 2) THEN
                  CALL cp_dbcsr_add(matrix_p(1)%matrix,matrix_p(2)%matrix,&
                       alpha_scalar=1.0_dp,beta_scalar=1.0_dp,error=error)
               END IF
            END IF

            ! calculate KS matrix
            nsize = SIZE(ks_matrix)
            CALL cp_dbcsr_iterator_start(iter,matrix_s(1)%matrix)
            DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
               CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sblock, blk)
               dq = qcharge(iatom)+qcharge(jatom)
               IF(.NOT.just_energy) THEN
                  DO is=1,nsize
                     NULLIFY(ksblock)
                     CALL cp_dbcsr_get_block_p(matrix=ks_matrix(is)%matrix,&
                          row=iatom,col=jatom,block=ksblock,found=found)
                     CPPostcondition(found,cp_failure_level,routineP,error,failure)
                     ksblock = ksblock - 0.5_dp*dq*sblock
                  END DO
               END IF
               IF ( calculate_forces ) THEN
                  ikind = kind_of(iatom)
                  iat   = atom_of_kind(iatom)
                  jkind = kind_of(jatom)
                  jat   = atom_of_kind(jatom)
                  NULLIFY(pblock)
                  CALL cp_dbcsr_get_block_p(matrix=matrix_p(1)%matrix,&
                       row=iatom,col=jatom,block=pblock,found=found)
                  CPPostcondition(found,cp_failure_level,routineP,error,failure)
                  DO i=1,3
                     NULLIFY(dsblock)
                     CALL cp_dbcsr_get_block_p(matrix=matrix_s(1+i)%matrix,&
                          row=iatom,col=jatom,block=dsblock,found=found)
                     CPPostcondition(found,cp_failure_level,routineP,error,failure)
                     fi = dq*SUM(pblock*dsblock)
                     force(ikind)%rho_elec(i,iat) = force(ikind)%rho_elec(i,iat) + fi
                     force(jkind)%rho_elec(i,jat) = force(jkind)%rho_elec(i,jat) - fi
                  END DO
               END IF
            END DO
            CALL cp_dbcsr_iterator_stop(iter)

            IF ( calculate_forces ) THEN
               DO iatom=1,natom
                  ikind  = kind_of(iatom)
                  iat = atom_of_kind(iatom)
                  force(ikind)%rho_elec(1,iat) = force(ikind)%rho_elec(1,iat) + drcharge(1,iatom)
                  force(ikind)%rho_elec(2,iat) = force(ikind)%rho_elec(2,iat) + drcharge(2,iatom)
                  force(ikind)%rho_elec(3,iat) = force(ikind)%rho_elec(3,iat) + drcharge(3,iatom)
               END DO
               DEALLOCATE(drcharge,STAT=istat)
               CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
               IF (SIZE(matrix_p) == 2) THEN
                  CALL cp_dbcsr_add(matrix_p(1)%matrix,matrix_p(2)%matrix,&
                                 alpha_scalar=1.0_dp,beta_scalar=-1.0_dp,error=error)
               END IF
            END IF
 
            DEALLOCATE (atom_of_kind,kind_of,STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
            DEALLOCATE(qcharge,STAT=istat)
            CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
         END IF

       END IF
    END IF

  END SUBROUTINE tb_coulomb

! *****************************************************************************
  SUBROUTINE scp_coulomb(qs_env,ks_matrix,matrix_s,rho,mcharge,dmcharge,&
             calculate_forces,just_energy,error)

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(cp_dbcsr_p_type), DIMENSION(:), &
      POINTER                                :: ks_matrix, matrix_s
    TYPE(qs_rho_type), POINTER               :: rho
    REAL(KIND=dp), DIMENSION(:), INTENT(in)  :: mcharge
    REAL(KIND=dp), DIMENSION(:, :), &
      INTENT(in)                             :: dmcharge
    LOGICAL, INTENT(in)                      :: calculate_forces, just_energy
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'scp_coulomb', &
      routineP = moduleN//':'//routineN

    INTEGER :: blk, iat, iatom, ibas, ikind, is, istat, jat, jatom, jkind, &
      kint, kmax, lmaxscp, nat, natom, nkind, norb, nsize
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: atom_of_kind, kind_of, lscp, &
                                                natoms, nbasis
    LOGICAL                                  :: defined, failure, found
    LOGICAL, ALLOCATABLE, DIMENSION(:)       :: adef
    REAL(KIND=dp)                            :: ak, alpha, bk, chabs, dq, &
                                                epsabs, epsrel, ff, rhom1, &
                                                rhom2
    REAL(KIND=dp), ALLOCATABLE, DIMENSION(:) :: zeta
    REAL(KIND=dp), DIMENSION(0:3)            :: pol
    REAL(KIND=dp), DIMENSION(:, :), POINTER  :: ksblock, sblock
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_dbcsr_iterator)                  :: iter
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(qs_energy_type), POINTER            :: energy
    TYPE(scp_vector_type), POINTER           :: cp, cres, crhs, cvec, cw
    TYPE(scptb_control_type), POINTER        :: scptb_control
    TYPE(scptb_parameter_type), POINTER      :: scptb_kind

    CALL get_qs_env(qs_env=qs_env,dft_control=dft_control,&
         energy=energy,para_env=para_env,error=error)

    energy%hartree = 0._dp
    energy%core_self = 0._dp

    chabs = SUM(ABS(mcharge))
    IF ( chabs > 1.e-8_dp ) THEN

       scptb_control => dft_control%qs_control%scptb_control

       NULLIFY(cvec,crhs,cp,cw,cres)

       epsrel = 1.e-8_dp

       ! Create scp vectors
       CALL get_qs_env(qs_env=qs_env,atomic_kind_set=atomic_kind_set,error=error)
       nkind = SIZE(atomic_kind_set)
       ALLOCATE(nbasis(nkind),natoms(nkind),lscp(nkind),zeta(nkind),adef(nkind),stat=istat)
       CPPrecondition(istat==0,cp_failure_level,routineP,error,failure)
       DO ikind=1,nkind
          atomic_kind => atomic_kind_set(ikind)
          CALL get_atomic_kind(atomic_kind=atomic_kind,natom=nat,scptb_parameter=scptb_kind)
          CALL get_scptb_parameter(scptb_kind,defined=defined,lmaxscp=lmaxscp,ag=alpha)
          IF(defined) THEN
            norb = (lmaxscp+1)**2
          ELSE
            norb = 0
          END IF
          natoms(ikind) = nat
          nbasis(ikind) = norb
          lscp(ikind)   = lmaxscp
          zeta(ikind)   = alpha
          adef(ikind)   = defined
       END DO
       CALL scp_vector_create(cvec, nkind, natoms, nbasis, error)
       CALL scp_vector_set(cvec, 0._dp, error)
       ! set charge
       CALL scp_set_charge(cvec,mcharge,adef,natoms,atomic_kind_set)
       ! Calclulate scp vector
       IF (scptb_control%do_ewald) THEN
          kmax = MIN(SUM(nbasis),100) * 10
          CALL scp_vector_create(crhs, nkind, natoms, nbasis, error)
          CALL scp_vector_set(crhs, 0._dp, error)
          ! for ci=0, this creates the RHS of (Ax=b)
          CALL apply_scp_vector(cvec,crhs,qs_env,calculate_forces=.FALSE.,error=error)
          CALL scp_vector_scale(-1._dp, crhs, error)
          ! conjugate gradient optimization
          CALL scp_vector_create(cres, nkind, natoms, nbasis, error)
          CALL scp_vector_copy(crhs, cres, error)
          CALL scp_vector_create(cp, nkind, natoms, nbasis, error)
          CALL scp_vector_create(cw, nkind, natoms, nbasis, error)
          ! scp_dot is not using the c0 (charge) term
          rhom1 = scp_dot(cres,cres)
          epsabs = epsrel*SQRT(rhom1)
          DO kint=1,kmax
             IF(kint==1) THEN
                CALL scp_vector_copy(cres, cp, error)
             ELSE
                bk = rhom1/rhom2
                CALL scp_vector_scale(bk, cp, error)
                CALL scp_vector_add(1._dp, cres, cp, error)
             END IF
             ! charge term
             CALL scp_set_charge(cp,mcharge,adef,natoms,atomic_kind_set)
             ! Ax - b
             CALL scp_vector_set(cw, 0._dp, error)
             CALL apply_scp_vector(cp,cw,qs_env,calculate_forces=.FALSE.,error=error)
             ! add b to get Ax
             CALL scp_vector_add(1._dp, crhs, cw, error)
             ! add force from self term ci/ai
             DO ikind=1,nkind
               IF(adef(ikind)) THEN
                 atomic_kind => atomic_kind_set(ikind)
                 CALL get_atomic_kind(atomic_kind=atomic_kind,natom=nat,scptb_parameter=scptb_kind)
                 CALL get_scptb_parameter(scptb_kind,pol=pol,lmaxscp=lmaxscp)
                 DO iat=1,natoms(ikind)
                   DO ibas=1,nbasis(ikind)
                      ! this assumes 1 basis function per l qm!!
                      IF(indso(1,ibas) > 0) THEN
                         cw%vector(ikind)%vmat(ibas,iat) = cw%vector(ikind)%vmat(ibas,iat) &
                            + cp%vector(ikind)%vmat(ibas,iat)/pol(indso(1,ibas))
                      END IF
                   END DO
                 END DO
               END IF
             END DO
             !
             ak = rhom1/scp_dot(cp,cw)
             CALL scp_vector_add(ak, cp, cvec, error)
             CALL scp_vector_add(-ak, cw, cres, error)
             rhom2 = rhom1
             rhom1 = scp_dot(cres,cres)
             IF ( SQRT(rhom1) < epsabs ) EXIT
          END DO
          ! Coulomb energy
          CALL scp_set_charge(cvec,mcharge,adef,natoms,atomic_kind_set)
          CALL scp_vector_set(cw, 0._dp, error)
          CALL apply_scp_vector(cvec,cw,qs_env,calculate_forces=.FALSE.,error=error)
          CALL scp_vector_dot(ak, cw, cvec, error)
          energy%hartree = 0.5_dp*ak
          ! release scratch vectors
          CALL scp_vector_release(crhs, error)
          CALL scp_vector_release(cres, error)
          CALL scp_vector_release(cp, error)
          CALL scp_vector_release(cw, error)
       ELSE
          !debug: do nothing for now
          ! Coulomb energy
          energy%hartree = 0._dp
       END IF
       ! Calculate self energy
       DO ikind=1,nkind
          IF(adef(ikind)) THEN
            atomic_kind => atomic_kind_set(ikind)
            CALL get_atomic_kind(atomic_kind=atomic_kind,natom=nat,scptb_parameter=scptb_kind)
            CALL get_scptb_parameter(scptb_kind,pol=pol)
            DO iat=1,natoms(ikind)
               DO ibas=1,nbasis(ikind)
                  ! this assumes 1 basis function per l qm!!
                  IF(indso(1,ibas) > 0) THEN
                     energy%core_self = energy%core_self + &
                        0.5_dp*(cvec%vector(ikind)%vmat(ibas,iat))**2/pol(indso(1,ibas))
                  END IF
               END DO
            END DO
          END IF
       END DO

       IF (.NOT.just_energy) THEN

          natom = SIZE(mcharge,1)
          ALLOCATE (atom_of_kind(natom),kind_of(natom),STAT=istat)
          CPPostcondition(istat==0,cp_failure_level,routineP,error,failure)
          CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set, kind_of=kind_of, atom_of_kind=atom_of_kind)

          ! calculate KS matrix
          IF (scptb_control%do_ewald) THEN
             CALL scp_vector_create(cw, nkind, natoms, nbasis, error)
             CALL scp_set_charge(cvec,mcharge,adef,natoms,atomic_kind_set)
             CALL scp_vector_set(cw, 0._dp, error)
             CALL apply_scp_vector(cvec,cw,qs_env,calculate_forces=.FALSE.,error=error)

             nsize = SIZE(ks_matrix)
             CALL cp_dbcsr_iterator_start(iter,matrix_s(1)%matrix)
             DO WHILE (cp_dbcsr_iterator_blocks_left(iter))
                CALL cp_dbcsr_iterator_next_block(iter, iatom, jatom, sblock, blk)
                ikind = kind_of(iatom)
                iat   = atom_of_kind(iatom)
                jkind = kind_of(jatom)
                jat   = atom_of_kind(jatom)
                IF (iatom==jatom) THEN
                  ff = 0.5_dp
                ELSE
                  ff = 1.0_dp
                END IF
                dq = (cw%vector(ikind)%vmat(1,iat) + cw%vector(jkind)%vmat(1,jat))*ff
                DO is=1,nsize
                   NULLIFY(ksblock)
                   CALL cp_dbcsr_get_block_p(matrix=ks_matrix(is)%matrix,&
                        row=iatom,col=jatom,block=ksblock,found=found)
                   ksblock = ksblock + dq*sblock
                END DO
             END DO
             CALL cp_dbcsr_iterator_stop(iter)

             CALL scp_vector_release(cw, error)
          ELSE
             ! explicit integrals
          END IF
          IF (calculate_forces) THEN
             ! forces on atoms
          END IF
       END IF

       CALL scp_vector_release(cvec, error)
       DEALLOCATE(nbasis,natoms,lscp,zeta,adef,stat=istat)
       CPPrecondition(istat==0,cp_failure_level,routineP,error,failure)

    END IF

  END SUBROUTINE scp_coulomb

  FUNCTION scp_dot(vec1,vec2) RESULT(res)
    TYPE(scp_vector_type)                    :: vec1, vec2
    REAL(KIND=dp)                            :: res

    INTEGER                                  :: i

    res = 0._dp
    DO i=1,SIZE(vec1%vector)
      res = res + SUM(vec1%vector(i)%vmat(2:,:)*vec2%vector(i)%vmat(2:,:))
    END DO

  END FUNCTION scp_dot

  SUBROUTINE scp_set_charge(vec,mcharge,adef,natoms,atomic_kind_set)
    TYPE(scp_vector_type)                    :: vec
    REAL(KIND=dp), DIMENSION(:), INTENT(IN)  :: mcharge
    LOGICAL, DIMENSION(:), INTENT(IN)        :: adef
    INTEGER, DIMENSION(:), INTENT(IN)        :: natoms
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set

    INTEGER                                  :: iat, iatom, ikind, nkind
    INTEGER, DIMENSION(:), POINTER           :: atom_list
    TYPE(atomic_kind_type), POINTER          :: atomic_kind

! set charge

    nkind = SIZE(adef)
    DO ikind=1,nkind
       IF(adef(ikind)) THEN
         atomic_kind => atomic_kind_set(ikind)
         CALL get_atomic_kind(atomic_kind=atomic_kind,atom_list=atom_list)
         DO iat=1,natoms(ikind)
            iatom = atom_list(iat)
            vec%vector(ikind)%vmat(1,iat) = mcharge(iatom)
         END DO
       END IF
    END DO

  END SUBROUTINE scp_set_charge

! *****************************************************************************

  SUBROUTINE apply_scp_vector(cin,cout,qs_env,calculate_forces,error)

    TYPE(scp_vector_type), POINTER           :: cin, cout
    TYPE(qs_environment_type), POINTER       :: qs_env
    LOGICAL, INTENT(in)                      :: calculate_forces
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'apply_scp_vector', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: use_virial
    REAL(KIND=dp)                            :: ehartree
    REAL(KIND=dp), DIMENSION(3, 3)           :: h_stress
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(pw_env_type), POINTER               :: pw_env
    TYPE(pw_p_type)                          :: scp_pot, scp_rho, scp_rho_g
    TYPE(pw_poisson_type), POINTER           :: poisson_env
    TYPE(pw_pool_p_type), DIMENSION(:), &
      POINTER                                :: pw_pools
    TYPE(pw_pool_type), POINTER              :: auxbas_pw_pool
    TYPE(virial_type), POINTER               :: virial

    CALL get_qs_env(qs_env=qs_env,pw_env=pw_env,virial=virial,para_env=para_env,error=error)
    use_virial = virial%pv_availability.AND.(.NOT.virial%pv_numer)

    CALL pw_env_get(pw_env,auxbas_pw_pool=auxbas_pw_pool,&
                    pw_pools=pw_pools,poisson_env=poisson_env,error=error)
    CALL pw_pool_create_pw(auxbas_pw_pool,&
                           scp_rho%pw,&
                           use_data=REALDATA3D,&
                           in_space=REALSPACE,&
                           error=error)
    CALL pw_pool_create_pw(auxbas_pw_pool,&
                           scp_pot%pw, &
                           use_data=COMPLEXDATA1D,&
                           in_space=RECIPROCALSPACE,&
                           error=error)
    CALL pw_pool_create_pw(auxbas_pw_pool,&
                           scp_rho_g%pw, &
                           use_data=COMPLEXDATA1D,&
                           in_space=RECIPROCALSPACE,&
                           error=error)

    CALL calculate_scp_charge(scp_rho,qs_env,cin,error)
    CALL pw_transfer(scp_rho%pw, scp_rho_g%pw, error=error)

    ! Getting the Hartree energy and Hartree potential.  Also getting the stress tensor
    ! from the Hartree term if needed.
    IF (use_virial .AND. calculate_forces) THEN
       h_stress(:,:) = 0.0_dp
       CALL pw_poisson_solve(poisson_env,scp_rho_g%pw,ehartree,scp_pot%pw,h_stress=h_stress,error=error)
       virial%pv_virial = virial%pv_virial + h_stress/REAL(para_env%num_pe,dp)
    ELSE
       CALL pw_poisson_solve(poisson_env,scp_rho_g%pw,ehartree,scp_pot%pw,error=error)
    END IF
    CALL pw_pool_give_back_pw(auxbas_pw_pool,scp_rho_g%pw,error=error)

    CALL pw_transfer(scp_pot%pw, scp_rho%pw, error=error)
    CALL integrate_scp_rspace(scp_rho,qs_env,cout,calculate_forces,error)

    CALL pw_pool_give_back_pw(auxbas_pw_pool,scp_rho%pw,error=error)
    CALL pw_pool_give_back_pw(auxbas_pw_pool,scp_pot%pw,error=error)

  END SUBROUTINE apply_scp_vector

! *****************************************************************************

END MODULE scptb_ks_matrix

