!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations
!   Copyright (C) 2001 - 2002  CP2K developers group
!-----------------------------------------------------------------------------!

#include "cp_prep_globals.h"

!!****h* cp2k/cp_fm_basic_linalg [1.0] *
!!
!!   NAME
!!     cp_fm_basic_linalg
!!
!!   FUNCTION
!!     basic linear algebra operations for full matrixes
!!
!!   NOTES
!!     -
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 splitted out of qs_blacs [fawzi]
!!
!!   SOURCE
!****************************************************************************
MODULE cp_fm_basic_linalg
  USE cp_error_handling,               ONLY: cp_a_l,&
                                             cp_assert,&
                                             cp_assertion_failed,&
                                             cp_debug,&
                                             cp_error_dealloc_ref,&
                                             cp_error_get_logger,&
                                             cp_error_init,&
                                             cp_error_message,&
                                             cp_error_type,&
                                             cp_internal_error,&
                                             cp_unimplemented_error
  USE cp_fm_struct,                    ONLY: cp_fm_struct_create,&
                                             cp_fm_struct_equivalent,&
                                             cp_fm_struct_release,&
                                             cp_fm_struct_retain,&
                                             cp_fm_struct_type
  USE cp_fm_types,                     ONLY: cp_fm_create,&
                                             cp_fm_get_element,&
                                             cp_fm_get_info,&
                                             cp_fm_init_random,&
                                             cp_fm_release,&
                                             cp_fm_retain,&
                                             cp_fm_set_all,&
                                             cp_fm_set_element,&
                                             cp_fm_p_type,&
                                             cp_fm_type
  USE cp_log_handling,                 ONLY: cp_failure_level,&
                                             cp_fatal_level,&
                                             cp_log,&
                                             cp_note_level,&
                                             cp_to_string,&
                                             cp_warning_level
  USE cp_matrix_utils,                 ONLY: cp_dealloc_ref,&
                                             cp_get,&
                                             cp_init,&
                                             cp_matrix_block_iterator,&
                                             cp_next
  USE cp_para_types,                   ONLY: cp_blacs_env_type,&
                                             cp_para_env_type
  USE global_types,                    ONLY: global_environment_type
  USE kinds,                           ONLY: wp=>dp
  USE mathlib,                         ONLY: symmetrize_matrix
  USE message_passing,                 ONLY: mp_bcast,&
                                             mp_max,&
                                             mp_shift,&
                                             mp_sum,&
                                             mp_sync
  USE parallel,                        ONLY: cp2k_is_parallel
  USE string_utilities,                ONLY: compress
  USE timings,                         ONLY: timeset,&
                                             timestop
  USE util,                            ONLY: sort
  IMPLICIT NONE
  PRIVATE

  LOGICAL, PRIVATE, PARAMETER :: debug_this_module=.TRUE.
  CHARACTER(len=*), PRIVATE, PARAMETER :: moduleN='cp_fm_basic_linalg'

  PUBLIC :: cp_fm_scale, &
            cp_fm_scale_and_add, &
            cp_fm_trace, &
            cp_fm_schur_product, &
            cp_fm_transpose, &
            cp_fm_upper_to_full, &
            cp_fm_syrk, &
            cp_fm_triangular_multiply, &
            cp_fm_symm, &
            cp_fm_gemm, &
            cp_fm_lu_decompose

!****************************************************************************
CONTAINS

!!****f* cp2k/cp_fm_basic_linalg/cp_fm_scale_and_add *
!!
!!   NAME
!!     cp_fm_scale_and_add
!!
!!   FUNCTION
!!     calc A <- alpha*A + beta*B
!!     optimized for alpha == 1.0 (just add beta*B) and beta == 0.0 (just
!!     scale A)
!!
!!   SYNOPSIS
!!     cp_fm_scale_and_add(alpha, matrix_a, beta, matrix_b, error)
!!
!!   ARGUMENTS
!!      TYPE(cp_fm_type), POINTER           :: matrix_a
!!      REAL(wp), INTENT(IN)                         :: alpha
!!      REAL(wp), INTENT(in), OPTIONAL               :: beta
!!      TYPE(cp_fm_type), POINTER, OPTIONAL :: matrix_b
!!      TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error
!!
!!****
  SUBROUTINE cp_fm_scale_and_add(alpha,matrix_a,beta,matrix_b,error)

    IMPLICIT NONE

    TYPE(cp_fm_type), POINTER           :: matrix_a
    REAL(wp), INTENT(IN)                         :: alpha
    REAL(wp), INTENT(in), OPTIONAL               :: beta
    TYPE(cp_fm_type), POINTER, OPTIONAL :: matrix_b
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

    !   *** Local variables ***

    INTEGER :: handle, mypcol, myprow, npcol, nprow, source, size_a

    REAL(wp), DIMENSION(:,:), POINTER :: a,b
    CHARACTER(len=*), PARAMETER :: routineN='cp_fm_scale_and_add',&
         routineP=moduleN//':'//routineN
    LOGICAL :: failure
    REAL(wp) :: my_beta

    !   ---------------------------------------------------------------------------

    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.
    my_beta=0.0_wp
    IF(PRESENT(beta)) my_beta=beta
    NULLIFY(a,b)

    CPPrecondition(ASSOCIATED(matrix_a),cp_failure_level,routineP,error,failure)
    CPPrecondition(matrix_a%ref_count>0,cp_failure_level,routineP,error,failure)

    IF (PRESENT(beta)) THEN
       CPPrecondition(PRESENT(matrix_b),cp_failure_level,routineP,error,failure)
       CPPrecondition(ASSOCIATED(matrix_b),cp_failure_level,routineP,error,failure)
       CPPrecondition(matrix_b%ref_count>0,cp_failure_level,routineP,error,failure)
       IF (matrix_a%id_nr==matrix_b%id_nr) THEN
          CALL cp_assert(matrix_a%id_nr/=matrix_b%id_nr, &
                         cp_warning_level, cp_assertion_failed, &
                         fromWhere=routineP, &
                         message="Bad use of routine. Call cp_fm_scale instead: "// &
                         CPSourceFileRef, &
                         error=error, failure=failure)
          CALL cp_fm_scale(alpha+beta, matrix_a, error=error)
          CALL timestop(0.0_wp,handle)
          RETURN
       END IF
    END IF

    a => matrix_a%local_data
    size_a = size(a,1)*size(a,2)

    IF (alpha /= 1.0_wp) CALL dscal ( size_a, alpha, a, 1)

    IF (my_beta /= 0.0_wp) THEN
       CALL cp_assert(matrix_a%matrix_struct%context%group==&
            matrix_b%matrix_struct%context%group,cp_failure_level,&
            cp_assertion_failed,fromWhere=routineP,&
            message="matrixes must be in the same blacs context"//&
            CPSourceFileRef,&
            error=error,failure=failure)

       IF (cp_fm_struct_equivalent(matrix_a%matrix_struct,&
            matrix_b%matrix_struct,error=error)) THEN

          b => matrix_b%local_data

          CALL daxpy ( size_a, my_beta, b, 1, a, 1 )

       ELSE
#ifdef __SCALAPACK
          CALL cp_unimplemented_error(fromWhere=routineP, &
               message="to do (pdscal,pdcopy,pdaxpy)", error=error)
#else
          CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
#endif
       END IF

    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_scale_and_add

! *****************************************************************************
! computes the LU decomposition of a given matrix
! the actual purpose right now is to compute the determinant of a given matrix
! which is most efficiently done this way, but, indeed, destroys the matrix
! SERIOUS WARNING (KNOWN BUG) : the sign of the determinant depends on ipivot
! one should be able to find out if ipivot is an even or an odd permutation...
! *****************************************************************************
  SUBROUTINE cp_fm_lu_decompose(matrix_a,almost_determinant)
    TYPE(cp_fm_type), POINTER :: matrix_a
    REAL(wp), INTENT(OUT)              :: almost_determinant

! *** locals ***
    INTEGER :: handle,lda,i,n,istat,info,npe
    INTEGER, DIMENSION(9) :: desca
    REAL(wp), DIMENSION(:,:), POINTER :: a
    INTEGER, ALLOCATABLE, DIMENSION(:) :: ipivot
    CHARACTER(LEN=*), PARAMETER :: routine =&
         "SUBROUTINE cp_fm_lu_decompose"
    REAL(wp), DIMENSION(:), POINTER :: diag
    REAL(wp) :: determinant

    CALL timeset("cp_fm_lu_decompose","I","",handle)

    a => matrix_a%local_data
    n = matrix_a%matrix_struct%nrow_global
    ALLOCATE(ipivot(n))

#if defined(__SCALAPACK)
    desca(:) = matrix_a%matrix_struct%descriptor(:)
    CALL pdgetrf(n,n,a(1,1),1,1,desca,ipivot,info)
    ALLOCATE(diag(n))
    diag(:)=0.0_wp
    DO i=1,n
       CALL cp_fm_get_element(matrix_a,i,i,diag(i)) !  not completely optimal in speed i would say
    ENDDO
    determinant=1.0_wp
    DO i=1,n
       determinant=determinant*diag(i)
    ENDDO
    DEALLOCATE(diag)
#else
    lda=SIZE(a,1)
    CALL dgetrf(n,n,a(1,1),lda,ipivot,info)
    determinant=1.0_wp
    DO i=1,n
       determinant=determinant*a(i,i)
    ENDDO
#endif
    ! info is allowed to be zero
    ! this does just signal a zero diagonal element
    DEALLOCATE(ipivot)
    almost_determinant=determinant ! notice that the sign is random
    CALL timestop(0.0_wp,handle)
  END SUBROUTINE


! *****************************************************************************

  SUBROUTINE cp_fm_gemm(transa,transb,m,n,k,alpha,matrix_a,matrix_b,beta,&
       matrix_c,error,b_first_col)

!   Purpose: BLACS interface to the BLAS routine dgemm.

!   History: - Creation (07.06.2001, Matthias Krack)

!   ***************************************************************************

    TYPE(cp_fm_type), POINTER          :: matrix_a,matrix_b,matrix_c
    CHARACTER(LEN=1), INTENT(IN)              :: transa,transb
    REAL(wp), INTENT(IN)                      :: alpha,beta
    INTEGER, INTENT(IN)                       :: k,m,n
    INTEGER, OPTIONAL, INTENT(IN)             :: b_first_col
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: handle,j,lda,ldb,ldc

    INTEGER, DIMENSION(9) :: desca,descb,descc

    REAL(wp), DIMENSION(:,:), POINTER :: a,b,c
    REAL(wp) :: flops

!   ---------------------------------------------------------------------------

    CALL timeset("cp_fm_gemm","I","Gflops",handle)

    a => matrix_a%local_data
    b => matrix_b%local_data
    c => matrix_c%local_data

    IF (PRESENT(b_first_col)) THEN
      j = b_first_col
    ELSE
      j = 1
    END IF

#if defined(__SCALAPACK)

    desca(:) = matrix_a%matrix_struct%descriptor(:)
    descb(:) = matrix_b%matrix_struct%descriptor(:)
    descc(:) = matrix_c%matrix_struct%descriptor(:)

    flops=2.0_wp*(1E-9_wp*m*n*k)/(matrix_a%matrix_struct%context%num_pe(1)*&
         matrix_a%matrix_struct%context%num_pe(2))
    CALL pdgemm(transa,transb,m,n,k,alpha,a(1,1),1,1,desca,b(1,1),1,j,&
                descb,beta,c(1,1),1,j,descc)
#else

    lda = SIZE(a,1)
    ldb = SIZE(b,1)
    ldc = SIZE(c,1)

    flops=2.0_wp*(1E-9_wp*m*n*k)
    CALL dgemm(transa,transb,m,n,k,alpha,a(1,1),lda,b(1,j),ldb,beta,c(1,j),ldc)

#endif
    CALL timestop(flops,handle)

  END SUBROUTINE cp_fm_gemm

  SUBROUTINE cp_fm_symm(side,uplo,m,n,alpha,matrix_a,matrix_b,beta,matrix_c,&
       error)

!   Purpose: BLACS interface to the BLAS routine dsymm.

!   History: - Creation (07.06.2001, Matthias Krack)

!   ***************************************************************************

    TYPE(cp_fm_type), POINTER          :: matrix_a,matrix_b,matrix_c
    CHARACTER(LEN=1), INTENT(IN)              :: side,uplo
    REAL(wp), INTENT(IN)                      :: alpha,beta
    INTEGER, INTENT(IN)                       :: m,n
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: handle,lda,ldb,ldc,mypcol,myprow,npcol,nprow
    REAL(kind=wp) :: flops

    INTEGER, DIMENSION(9) :: desca,descb,descc

    REAL(wp), DIMENSION(:,:), POINTER :: a,b,c
    TYPE(cp_blacs_env_type), POINTER    :: context

!   ---------------------------------------------------------------------------

    CALL timeset("cp_fm_symm","I","Gflops",handle)

    context => matrix_a%matrix_struct%context
    myprow=context%mepos(1)
    mypcol=context%mepos(2)
    nprow=context%num_pe(1)
    npcol=context%num_pe(2)

    a => matrix_a%local_data
    b => matrix_b%local_data
    c => matrix_c%local_data

    flops=(2.0E-9_wp*m*m*n)/(nprow*npcol)
#if defined(__SCALAPACK)

    desca(:) = matrix_a%matrix_struct%descriptor(:)
    descb(:) = matrix_b%matrix_struct%descriptor(:)
    descc(:) = matrix_c%matrix_struct%descriptor(:)

    CALL pdsymm(side,uplo,m,n,alpha,a(1,1),1,1,desca,b(1,1),1,1,descb,beta,c(1,1),1,1,descc)

#else

    lda = matrix_a%matrix_struct%local_leading_dimension
    ldb = matrix_b%matrix_struct%local_leading_dimension
    ldc = matrix_c%matrix_struct%local_leading_dimension

    CALL dsymm(side,uplo,m,n,alpha,a(1,1),lda,b(1,1),ldb,beta,c(1,1),ldc)

#endif
    CALL timestop(flops,handle)

  END SUBROUTINE cp_fm_symm

! *****************************************************************************

  SUBROUTINE cp_fm_syrk(uplo,trans,k,alpha,matrix_a,ia,ja,beta,matrix_c,&
       error)

!   Purpose: BLACS interface to the BLAS routine dsyrk.

!   History: - Creation (07.06.2001, Matthias Krack)

!   ***************************************************************************

    TYPE(cp_fm_type), POINTER          :: matrix_a,matrix_c
    CHARACTER(LEN=1), INTENT(IN)              :: trans,uplo
    REAL(wp), INTENT(IN)                      :: alpha,beta
    INTEGER, INTENT(IN)                       :: ia,ja,k
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: handle,lda,ldc,mypcol,myprow,n,npcol,nprow

    INTEGER, DIMENSION(9) :: desca,descc

    REAL(wp), DIMENSION(:,:), POINTER :: a,c
    TYPE(cp_blacs_env_type), POINTER    :: context

!   ---------------------------------------------------------------------------

    CALL timeset("cp_fm_syrk","I","",handle)

    context => matrix_a%matrix_struct%context
    myprow=context%mepos(1)
    mypcol=context%mepos(2)
    nprow=context%num_pe(1)
    npcol=context%num_pe(2)
    n = matrix_a%matrix_struct%nrow_global

    a => matrix_a%local_data
    c => matrix_c%local_data

#if defined(__SCALAPACK)

    desca(:) = matrix_a%matrix_struct%descriptor(:)
    descc(:) = matrix_c%matrix_struct%descriptor(:)

    CALL pdsyrk(uplo,trans,n,k,alpha,a(1,1),ia,ja,desca,beta,c(1,1),1,1,descc)

#else

    lda = SIZE(a,1)
    ldc = SIZE(c,1)

    CALL dsyrk(uplo,trans,n,k,alpha,a(ia,ja),lda,beta,c(1,1),ldc)

#endif
    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_syrk

! *****************************************************************************

  SUBROUTINE cp_fm_schur_product(matrix_a,matrix_b,matrix_c,error)

!   Purpose: Calculate the schur product of two matrices

!   ***************************************************************************

    TYPE(cp_fm_type), POINTER          :: matrix_a,matrix_b,matrix_c
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: handle,icol_local,irow_local,mypcol,myprow,&
         ncol_local,npcol,nprow,nrow_local

    REAL(wp), DIMENSION(:,:), POINTER :: a,b,c
    TYPE(cp_blacs_env_type), POINTER    :: context

!   ---------------------------------------------------------------------------

    CALL timeset("cp_fm_schur_product","I","",handle)

    context => matrix_a%matrix_struct%context
    myprow=context%mepos(1)
    mypcol=context%mepos(2)
    nprow=context%num_pe(1)
    npcol=context%num_pe(2)

    a => matrix_a%local_data
    b => matrix_b%local_data
    c => matrix_c%local_data

    nrow_local = matrix_a%matrix_struct%nrow_locals(myprow)
    ncol_local = matrix_a%matrix_struct%ncol_locals(mypcol)

    DO icol_local=1,ncol_local
       DO irow_local=1,nrow_local
          c(irow_local,icol_local) = a(irow_local,icol_local)*b(irow_local,icol_local)
       END DO
    END DO

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_schur_product

! *****************************************************************************
!!****f* cp_fm_basic_linalg/cp_fm_trace [1.0] *
!!
!!   NAME
!!     cp_fm_trace
!!
!!   SYNOPSIS
!!     Subroutine cp_fm_trace(matrix_a, matrix_b, trace, error)
!!       Type(cp_fm_type), Pointer:: matrix_a, matrix_b
!!       Real(Kind=wp), Intent (OUT):: trace
!!       Type(cp_error_type), Intent (INOUT), Optional:: error
!!     End Subroutine cp_fm_trace
!!
!!   FUNCTION
!!     returns the trace of matrix_a^T matrix_b, i.e 
!!     sum_{i,j}(matrix_a(i,j)*matrix_b(i,j))
!!
!!   NOTES
!!     note the transposition of matrix_a!
!!
!!   ARGUMENTS
!!     - matrix_a: a matrix
!!     - matrix_b: another matrix
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Matthias Krack
!!
!!   MODIFICATION HISTORY
!!     11.06.2001 Creation (Matthias Krack)
!!     12.2002 added doc [fawzi]
!!
!!*** *********************************************************************
  SUBROUTINE cp_fm_trace(matrix_a,matrix_b,trace,error)

    TYPE(cp_fm_type), POINTER           :: matrix_a,matrix_b
    REAL(wp), INTENT(OUT)                        :: trace
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: group,handle,icol_local,irow_local,mypcol,myprow,&
         ncol_local,npcol,nprow,nrow_local

    REAL(wp), DIMENSION(:,:), POINTER :: a,b
    TYPE(cp_blacs_env_type), POINTER    :: context

!   ---------------------------------------------------------------------------

    CALL timeset("cp_fm_trace","I","",handle)

    context => matrix_a%matrix_struct%context
    myprow=context%mepos(1)
    mypcol=context%mepos(2)
    nprow=context%num_pe(1)
    npcol=context%num_pe(2)

    group = matrix_a%matrix_struct%para_env%group

    a => matrix_a%local_data
    b => matrix_b%local_data

    nrow_local = matrix_a%matrix_struct%nrow_locals(myprow)
    ncol_local = matrix_b%matrix_struct%ncol_locals(mypcol)

    trace = 0.0_wp

    DO icol_local=1,ncol_local
       DO irow_local=1,nrow_local
          trace = trace + a(irow_local,icol_local)*b(irow_local,icol_local)
       END DO
    END DO

    CALL mp_sum(trace,group)

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_trace

! *****************************************************************************


!!****f* cp_fm_basic_linalg/cp_fm_triangular_multiply [1.0] *
!!
!!   NAME
!!     cp_fm_triangular_multiply
!!
!!   SYNOPSIS
!!     Subroutine cp_fm_triangular_multiply(triangular_matrix, matrix_b,&
!!         side, transpose_tr, invert_tr, uplo_tr, unit_diag_tr, n_rows,&
!!         n_cols, alpha, error)
!!       Type(cp_fm_type), Pointer:: triangular_matrix, matrix_b
!!       Character, Intent (IN), Optional:: side, uplo_tr
!!       Logical, Intent (IN), Optional:: transpose_tr, invert_tr,&
!!         unit_diag_tr
!!       Integer, Intent (IN), Optional:: n_rows, n_cols
!!       Real(Kind=wp), Intent (IN), Optional:: alpha
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine cp_fm_triangular_multiply
!!
!!   FUNCTION
!!     multiplies in place by a triangular matrix:
!!      matrix_b = alpha op(triangular_matrix) matrix_b
!!     or (if side='R')
!!      matrix_b = alpha matrix_b op(triangular_matrix)
!!     op(triangular_matrix) is:
!!      triangular_matrix (if transpose_tr=.false. and invert_tr=.false.)
!!      triangular_matrix^T (if transpose_tr=.true. and invert_tr=.false.)
!!      triangular_matrix^(-1) (if transpose_tr=.false. and invert_tr=.true.)
!!      triangular_matrix^(-T) (if transpose_tr=.true. and invert_tr=.true.)
!!
!!   NOTES
!!     needs an mpi env
!!
!!   INPUTS
!!     - triangular_matrix: the triangular matrix that multiplies the other
!!     - matrix_b: the matrix that gets multiplied and stores the result
!!     - side: on which side of matrix_b stays op(triangular_matrix)
!!       (defaults to 'L')
!!     - transpose_tr: if the triangular matrix should be transposed
!!       (defaults to false)
!!     - invert_tr: if the triangular matrix should be inverted
!!       (defaults to false)
!!     - uplo_tr: if triangular_matrix is stored in the upper ('U') or
!!       lower ('L') triangle (defaults to 'U')
!!     - unit_diag_tr: if the diagonal elements of triangular_matrix should
!!       be assumed to be 1 (defaults to false)
!!     - n_rows: the number of rows of the result (defaults to 
!!       size(matrix_b,1))
!!     - n_cols: the number of columns of the result (defaults to
!!       size(matrix_b,2))
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     08.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE cp_fm_triangular_multiply(triangular_matrix,matrix_b,side,&
     transpose_tr, invert_tr, uplo_tr,unit_diag_tr, n_rows, n_cols, &
     alpha,error)
  TYPE(cp_fm_type), POINTER :: triangular_matrix, matrix_b
  CHARACTER, INTENT(in), OPTIONAL :: side, uplo_tr
  LOGICAL, INTENT(in), OPTIONAL :: transpose_tr, invert_tr, unit_diag_tr
  INTEGER, INTENT(in), OPTIONAL :: n_rows, n_cols
  REAL(kind=wp), INTENT(in), OPTIONAL :: alpha
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure, invert
  CHARACTER(len=*), PARAMETER :: routineN='cp_fm_triangular_multiply',&
        routineP=moduleN//':'//routineN
  CHARACTER :: side_char, unit_diag,uplo, transa
  INTEGER :: handle, m,n
  REAL(kind=wp) :: al
  failure=.FALSE.
  
  CALL timeset(routineN//','//moduleN,"I","",handle)
  side_char='L'
  unit_diag='N'
  uplo='U'
  transa='N'
  invert=.FALSE.
  al=1.0_wp
  CALL cp_fm_get_info(matrix_b, nrow_global=m, ncol_global=n, error=error)
  IF (PRESENT(side)) side_char=side
  IF (PRESENT(invert_tr)) invert=invert_tr
  IF (PRESENT(uplo_tr)) uplo=uplo_tr
  IF (PRESENT(unit_diag_tr)) THEN
     IF (unit_diag_tr) THEN
        unit_diag='U'
     ELSE
        unit_diag='N'
     END IF
  END IF
  IF (PRESENT(transpose_tr)) THEN
     IF (transpose_tr) THEN
        transa='T'
     ELSE
        transa='N'
     END IF
  END IF
  IF (PRESENT(alpha)) al=alpha
  IF (PRESENT(n_rows)) m=n_rows
  IF (PRESENT(n_cols)) n=n_cols

  IF (invert) THEN

#if defined(__SCALAPACK)
     CALL pdtrsm(side_char,uplo,transa,unit_diag,m,n,al,&
          triangular_matrix%local_data(1,1),1,1,&
          triangular_matrix%matrix_struct%descriptor,&
          matrix_b%local_data(1,1),1,1,&
          matrix_b%matrix_struct%descriptor(1))
#else     
     CALL dtrsm(side_char,uplo,transa,unit_diag,m,n,al,&
          triangular_matrix%local_data(1,1),&
          SIZE(triangular_matrix%local_data,1),&
          matrix_b%local_data(1,1),SIZE(matrix_b%local_data,1))
#endif

  ELSE

#if defined(__SCALAPACK)
     CALL pdtrmm(side_char,uplo,transa,unit_diag,m,n,al,&
          triangular_matrix%local_data(1,1),1,1,&
          triangular_matrix%matrix_struct%descriptor,&
          matrix_b%local_data(1,1),1,1,&
          matrix_b%matrix_struct%descriptor(1))
#else     
     CALL dtrmm(side_char,uplo,transa,unit_diag,m,n,al,&
          triangular_matrix%local_data(1,1),&
          SIZE(triangular_matrix%local_data,1),&
          matrix_b%local_data(1,1),SIZE(matrix_b%local_data,1))
#endif

  END IF

  CALL timestop(0.0_wp,handle)     
  END SUBROUTINE cp_fm_triangular_multiply
!***************************************************************************

  SUBROUTINE cp_fm_scale(alpha, matrix_a, error)

    TYPE(cp_fm_type), POINTER           :: matrix_a
    REAL(wp), INTENT(IN)                         :: alpha
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

    !   *** Local variables ***

    INTEGER                           :: size_a, handle
    REAL(wp), DIMENSION(:,:), POINTER :: a

    CHARACTER(len=*), PARAMETER :: routineN='cp_fm_scale',&
                                   routineP=moduleN//':'//routineN
    LOGICAL :: failure

    !   ---------------------------------------------------------------------------

    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.
    NULLIFY(a)

    CPPrecondition(ASSOCIATED(matrix_a),cp_failure_level,routineP,error,failure)
    CPPrecondition(matrix_a%ref_count>0,cp_failure_level,routineP,error,failure)

    a => matrix_a%local_data
    size_a = SIZE(a,1)*SIZE(a,2)

    CALL DSCAL(size_a, alpha, a, 1)

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_scale

! *****************************************************************************

! *****************************************************************************
  SUBROUTINE cp_fm_transpose(matrix,matrixt,error)
! matrixt=matrix^T ! assumes no symmetry
!***************************************************************************

    TYPE(cp_fm_type), POINTER          :: matrix,matrixt
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: handle,icol_global,icol_local,ipcol,iprow,irow_global,&
               irow_local,mypcol,myprow,ncol_block,ncol_global,ncol_local,&
               npcol,nprow,nrow_block,nrow_global,nrow_local

    INTEGER, DIMENSION(9) :: desca,descc

    REAL(wp), DIMENSION(:,:), POINTER :: a,c
    INTEGER :: i,j
    TYPE(cp_blacs_env_type), POINTER :: context
    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineN='cp_fm_transpose',&
         routineP=moduleN//':'//routineN

!   ---------------------------------------------------------------------------
    failure = .FALSE.
    CPPrecondition(ASSOCIATED(matrix),cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(matrixt),cp_failure_level,routineP,error,failure)
    IF (failure) return
    nrow_global = matrix%matrix_struct%nrow_global
    ncol_global = matrix%matrix_struct%ncol_global
    CPPrecondition(nrow_global==ncol_global,cp_failure_level,routineP,error,failure)
    IF (failure) return

    CALL timeset("cp_fm_transpose","I","",handle)

    context => matrix%matrix_struct%context
    myprow=context%mepos(1)
    mypcol=context%mepos(2)
    nprow=context%num_pe(1)
    npcol=context%num_pe(2)


    a => matrix%local_data
    c => matrixt%local_data

#if defined(__SCALAPACK)
    desca(:) = matrix%matrix_struct%descriptor(:)
    descc(:) = matrixt%matrix_struct%descriptor(:)
    CALL pdtran(nrow_global,ncol_global,1.0_wp,a(1,1),1,1,desca,0.0_wp,c(1,1),1,1,descc)
#else
    DO j=1,ncol_global
     DO i=1,nrow_global
        c(j,i)=a(i,j)
     ENDDO
    ENDDO
#endif
    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_transpose

! *****************************************************************************

  SUBROUTINE cp_fm_upper_to_full(matrix,work,error)

!   Purpose: given an upper triangular matrix computes the corresponding full matrix
!            the lower triangular part is irrelevant
!   History: - Creation (12.06.2001, Matthias Krack)

!   ***************************************************************************

    TYPE(cp_fm_type), POINTER          :: matrix,work
    TYPE(cp_error_type), INTENT(inout), OPTIONAL :: error

!   *** Local variables ***

    INTEGER :: handle,icol_global,icol_local,ipcol,iprow,irow_global,&
               irow_local,mypcol,myprow,ncol_block,ncol_global,ncol_local,&
               npcol,nprow,nrow_block,nrow_global,nrow_local

    INTEGER, DIMENSION(9) :: desca,descc

    REAL(wp), DIMENSION(:,:), POINTER :: a,c
    TYPE(cp_blacs_env_type), POINTER :: context
    CHARACTER(len=*), PARAMETER :: routineN='cp_fm_upper_to_full',&
         routineP=moduleN//':'//routineN 
    logical :: failure

#if defined(__SCALAPACK)
    INTEGER, EXTERNAL :: indxl2g

#endif
!   ---------------------------------------------------------------------------

    failure = .FALSE.
    CPPrecondition(ASSOCIATED(matrix),cp_failure_level,routineP,error,failure)
    CPPrecondition(ASSOCIATED(work),cp_failure_level,routineP,error,failure)
    IF (failure) RETURN
    nrow_global = matrix%matrix_struct%nrow_global
    ncol_global = matrix%matrix_struct%ncol_global
    CPPrecondition(nrow_global==ncol_global,cp_failure_level,routineP,error,failure)
    nrow_global = work%matrix_struct%nrow_global
    ncol_global = work%matrix_struct%ncol_global
    CPPrecondition(nrow_global==ncol_global,cp_failure_level,routineP,error,failure)
    IF (failure) RETURN

    CALL timeset("cp_fm_upper_to_full","I","",handle)

    context => matrix%matrix_struct%context
    myprow=context%mepos(1)
    mypcol=context%mepos(2)
    nprow=context%num_pe(1)
    npcol=context%num_pe(2)

#if defined(__SCALAPACK)


    nrow_block = matrix%matrix_struct%nrow_block
    ncol_block = matrix%matrix_struct%ncol_block

    nrow_local = matrix%matrix_struct%nrow_locals(myprow)
    ncol_local = matrix%matrix_struct%ncol_locals(mypcol)

    a => work%local_data
    desca(:) = work%matrix_struct%descriptor(:)
    c => matrix%local_data
    descc(:) = matrix%matrix_struct%descriptor(:)

    DO icol_local=1,ncol_local
      icol_global = indxl2g(icol_local,ncol_block,mypcol,&
           matrix%matrix_struct%first_p_pos(2),npcol)
      DO irow_local=1,nrow_local
        irow_global = indxl2g(irow_local,nrow_block,myprow,&
             matrix%matrix_struct%first_p_pos(1),nprow)
        IF (irow_global > icol_global) THEN
          c(irow_local,icol_local) = 0.0_wp
        ELSE IF (irow_global == icol_global) THEN
          c(irow_local,icol_local) = 0.5_wp*c(irow_local,icol_local)
        END IF
      END DO
    END DO

    a(:,:) = c(:,:)

    CALL pdtran(nrow_global,ncol_global,1.0_wp,a(1,1),1,1,desca,1.0_wp,c(1,1),1,1,descc)

#else

    a => matrix%local_data
    DO irow_global=1,nrow_global
     DO icol_global=irow_global+1,ncol_global
      a(icol_global,irow_global)=a(irow_global,icol_global)
     ENDDO
    ENDDO

#endif
    CALL timestop(0.0_wp,handle)

  END SUBROUTINE cp_fm_upper_to_full

END MODULE cp_fm_basic_linalg
