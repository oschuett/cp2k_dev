!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2006  CP2K developers group                                 !
!-----------------------------------------------------------------------------!

!!****** cp2k/topology_psf [1.0] *
!!
!!   NAME
!!     topology_psf
!!
!!   FUNCTION
!!     Functionality to read in PSF topologies and convert it into local
!!     data structures
!!
!!   AUTHOR
!!
!!   MODIFICATION HISTORY
!!
!!   SOURCE
!******************************************************************************

MODULE topology_psf
  USE cp_files,                        ONLY: open_file
  USE cp_output_handling,              ONLY: cp_print_key_finished_output,&
                                             cp_print_key_unit_nr
  USE cp_parser,                       ONLY: cp_parser_type,&
                                             parser_create,&
                                             parser_get_next_line,&
                                             parser_get_object,&
                                             parser_release,&
                                             parser_search_string
  USE global_types,                    ONLY: global_environment_type
  USE input_section_types,             ONLY: section_vals_type
  USE kinds,                           ONLY: default_string_length,&
                                             dp
  USE memory_utilities,                ONLY: reallocate
  USE qmmm_ff_fist,                    ONLY: qmmm_ff_precond_only_qm
  USE string_utilities,                ONLY: uppercase
  USE timings,                         ONLY: timeset,&
                                             timestop
  USE topology_types,                  ONLY: atom_info_type,&
                                             connectivity_info_type,&
                                             topology_parameters_type
  USE topology_util,                   ONLY: reorder_structure,&
                                             atom_bond_list_type
  USE input_constants,                 ONLY: do_skip_14

#include "cp_common_uses.h"

  IMPLICIT NONE

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'topology_psf'

  PRIVATE
  PUBLIC :: pre_read_topology_psf, read_topology_psf, write_topology_psf

!!*****
!******************************************************************************

CONTAINS

!!*****
!******************************************************************************
!!****** topology/pre_read_topology_psf [1.0] *
!!
!!   NAME
!!     pre_read_topology_psf
!!
!!   FUNCTION
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE pre_read_topology_psf (topology,subsys_section, error)
    TYPE(topology_parameters_type), &
      INTENT(INOUT)                          :: topology
    TYPE(section_vals_type), POINTER         :: subsys_section
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'pre_read_topology_psf', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: handle, iw, stat
    LOGICAL                                  :: failure
    TYPE(atom_info_type), POINTER            :: atom_info
    TYPE(cp_logger_type), POINTER            :: logger

    failure = .FALSE.
    NULLIFY(logger)
    logger => cp_error_get_logger(error)
    iw = cp_print_key_unit_nr(logger,subsys_section,"PRINT%TOPOLOGY_INFO/PSF_INFO",&
         extension=".subsysLog",error=error)    
    CALL timeset(routineN,'I','',handle)
    
    atom_info => topology%atom_info

    IF (ASSOCIATED(atom_info%label_molname)) &
      DEALLOCATE(atom_info%label_molname,STAT=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    NULLIFY(atom_info%label_molname)
  
    IF (ASSOCIATED(atom_info%label_resid)) &
      DEALLOCATE(atom_info%label_resid,STAT=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    NULLIFY(atom_info%label_resid)
  
    IF (ASSOCIATED(atom_info%label_resname)) &
      DEALLOCATE(atom_info%label_resname,STAT=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    NULLIFY(atom_info%label_resname)
    
    IF (ASSOCIATED(atom_info%label_atmname)) &
      DEALLOCATE(atom_info%label_atmname,STAT=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    NULLIFY(atom_info%label_atmname)
  
    IF (ASSOCIATED(atom_info%atm_charge)) &
      DEALLOCATE(atom_info%atm_charge,STAT=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    NULLIFY(atom_info%atm_charge)
  
    IF (ASSOCIATED(atom_info%atm_mass)) &
      DEALLOCATE(atom_info%atm_mass,STAT=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    NULLIFY(atom_info%atm_mass)

    CALL timestop(0.0_dp,handle)
    CALL cp_print_key_finished_output(iw,logger,subsys_section,&
         "PRINT%TOPOLOGY_INFO/PSF_INFO",error=error)

  END SUBROUTINE pre_read_topology_psf

!!*****
!******************************************************************************
!!****** topology/read_topology_psf [1.0] *
!!
!!   NAME
!!     read_topology_psf
!!
!!   FUNCTION
!!     Read PSF topology file
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE read_topology_psf (filename,topology,globenv,subsys_section, error)
    CHARACTER(LEN=default_string_length), &
      INTENT(IN)                             :: filename
    TYPE(topology_parameters_type), &
      INTENT(INOUT)                          :: topology
    TYPE(global_environment_type), &
      OPTIONAL, POINTER                      :: globenv
    TYPE(section_vals_type), POINTER         :: subsys_section
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'read_topology_psf', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_string_length)     :: dummy_field, label
    INTEGER :: handle, i, iatom, ibond, index_now, iphi, itheta, iw, jatom, &
      natom, natom_prev, nbond, nbond_prev, nphi, nphi_prev, ntheta, &
      ntheta_prev, nonfo, ionfo, nonfo_prev, stat, N
    LOGICAL                                  :: failure, found
    TYPE(atom_info_type), POINTER            :: atom_info
    TYPE(connectivity_info_type), POINTER    :: conn_info
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(cp_parser_type), POINTER            :: parser
    TYPE(atom_bond_list_type), DIMENSION(:), POINTER   :: ex_bond_list,&
                                                          ex_bend_list
    LOGICAL                                  :: do_onfo

    NULLIFY(parser, logger)
    logger => cp_error_get_logger(error)
    iw = cp_print_key_unit_nr(logger,subsys_section,"PRINT%TOPOLOGY_INFO/PSF_INFO",&
         extension=".subsysLog",error=error)    
    CALL timeset(routineN,'I','',handle)
    CALL parser_create(parser,filename,para_env=globenv%para_env)
    
    atom_info => topology%atom_info
    conn_info => topology%conn_info
    do_onfo = (topology%exclude_vdw/=do_skip_14).OR.(topology%exclude_ei/=do_skip_14)

    natom_prev = 0
    IF(ASSOCIATED(atom_info%label_molname)) natom_prev = SIZE(atom_info%label_molname)

    IF(iw>0) WRITE(iw,'(T2,A)') 'PSF_INFO| Parsing the NATOM section'    
    !
    ! ATOM section
    !
    label = '!NATOM'
    CALL parser_search_string(parser,label,.TRUE.,found,begin_line=.TRUE.)
    IF ( .NOT. found ) THEN
       IF(iw>0) WRITE (iw,'(T2,A)') 'PSF_INFO| No NATOM section '
       natom = 0
    ELSE
       CALL parser_get_object  (parser,natom)
       IF(iw>0) WRITE(iw,'(T2,A,I8)') 'PSF_INFO| NATOM = ',natom
       !malloc the memory that we need
       CALL reallocate(atom_info%label_molname,1,natom_prev+natom)
       CALL reallocate(atom_info%label_resid,1,natom_prev+natom)
       CALL reallocate(atom_info%label_resname,1,natom_prev+natom)
       CALL reallocate(atom_info%label_atmname,1,natom_prev+natom)
       CALL reallocate(atom_info%atm_charge,1,natom_prev+natom)
       CALL reallocate(atom_info%atm_mass,1,natom_prev+natom)
       !Read in the atom info
       DO iatom=1,natom
          index_now=iatom+natom_prev
          CALL parser_get_next_line(parser,1,error=error)
          READ(parser%input_line,*)i,&
                                   atom_info%label_molname(index_now),&
                                   atom_info%label_resid(index_now),&
                                   atom_info%label_resname(index_now),&
                                   dummy_field,&
                                   atom_info%label_atmname(index_now),&                      
                                   atom_info%atm_charge(index_now),&
                                   atom_info%atm_mass(index_now)
          CALL uppercase ( atom_info%label_atmname(index_now) )
       END DO
    END IF
    !
    ! BOND section
    !
    nbond_prev = 0
    IF(ASSOCIATED(conn_info%bond_a)) nbond_prev = SIZE(conn_info%bond_a)

    IF(iw>0) WRITE(iw,'(T2,A)') 'PSF_INFO| Parsing the NBOND section'
    label = '!NBOND'
    CALL parser_search_string(parser,label,.TRUE.,found,begin_line=.TRUE.)
    IF ( .NOT. found ) THEN
       IF(iw>0) WRITE (iw,'(T2,A)')'PSF_INFO| No NBOND section '
       nbond = 0
    ELSE
       CALL parser_get_object  (parser,nbond)       
       IF(iw>0) WRITE(iw,'(T2,A,I8)')'PSF_INFO| NBOND = ',nbond
       !malloc the memory that we need
       CALL reallocate(conn_info%bond_a,1,nbond_prev+nbond)
       CALL reallocate(conn_info%bond_b,1,nbond_prev+nbond)
       !Read in the bond info
       DO ibond=1,nbond,4
          CALL parser_get_next_line(parser,1,error=error)
          index_now=nbond_prev+ibond-1
          READ(parser%input_line,*)(conn_info%bond_a(index_now+i),&
                                    conn_info%bond_b(index_now+i),&
                                    i=1,MIN(4,(nbond-ibond+1)))
       END DO
       conn_info%bond_a=conn_info%bond_a+natom_prev
       conn_info%bond_b=conn_info%bond_b+natom_prev
    END IF
    !
    ! PARA_RES structure
    !    
    i = 0
    IF(ASSOCIATED(conn_info%c_bond_a)) i = SIZE(conn_info%c_bond_a)
    DO ibond=1+nbond_prev,nbond+nbond_prev
       iatom = conn_info%bond_a(ibond)
       jatom = conn_info%bond_b(ibond)
       IF(topology%para_res) THEN
          IF((atom_info%label_molname(iatom)/=atom_info%label_molname(jatom)).OR.&
               (atom_info%label_resid(iatom)/=atom_info%label_resid(jatom)).OR.&
               (atom_info%label_resname(iatom)/=atom_info%label_resname(jatom)))THEN
             IF(iw>0) WRITE(iw,'(T2,A)') "PSF_INFO| PARA_RES, bond between molecules atom ",&
                  iatom,jatom
             i = i + 1
             CALL reallocate(conn_info%c_bond_a,1,i+1)
             CALL reallocate(conn_info%c_bond_b,1,i+1)
             conn_info%c_bond_a(i) = iatom
             conn_info%c_bond_b(i) = jatom
          END IF
       ELSE
          IF(atom_info%label_molname(iatom)/=atom_info%label_molname(jatom)) THEN
             CPPostcondition(.FALSE.,cp_failure_level,routineP,error,failure)
          END IF
       END IF
    END DO
    !
    ! THETA section
    !    
    ntheta_prev = 0
    IF(ASSOCIATED(conn_info%theta_a)) ntheta_prev = SIZE(conn_info%theta_a)

    IF(iw>0) WRITE(iw,'(T2,A)')'PSF_INFO| Parsing the NTHETA section'
    label = '!NTHETA'
    CALL parser_search_string(parser,label,.TRUE.,found,begin_line=.TRUE.)
    IF ( .NOT. found ) THEN
       IF(iw>0) WRITE (iw,'(T2,A)')'PSF_INFO| No NTHETA section '
       ntheta = 0
    ELSE
       CALL parser_get_object  (parser,ntheta)
       IF(iw>0) WRITE(iw,'(T2,A,I8)')'PSF_INFO| NTHETA = ',ntheta
       !malloc the memory that we need
       CALL reallocate(conn_info%theta_a,1,ntheta_prev+ntheta)
       CALL reallocate(conn_info%theta_b,1,ntheta_prev+ntheta)
       CALL reallocate(conn_info%theta_c,1,ntheta_prev+ntheta)
       CALL reallocate(conn_info%ub_a,1,ntheta_prev+ntheta)
       CALL reallocate(conn_info%ub_b,1,ntheta_prev+ntheta)
       CALL reallocate(conn_info%ub_c,1,ntheta_prev+ntheta)
       !Read in the bend info
       DO itheta=1,ntheta,3
          CALL parser_get_next_line(parser,1,error=error)
          index_now=ntheta_prev+itheta-1
          READ(parser%input_line,*)(conn_info%theta_a(index_now+i),&
                                    conn_info%theta_b(index_now+i),&
                                    conn_info%theta_c(index_now+i),&
                                    i=1,MIN(3,(ntheta-itheta+1)))
       END DO
       conn_info%theta_a=conn_info%theta_a+natom_prev
       conn_info%theta_b=conn_info%theta_b+natom_prev
       conn_info%theta_c=conn_info%theta_c+natom_prev
    END IF
    !
    ! UB structure
    !    
    conn_info%ub_a(:) = conn_info%theta_a(:)
    conn_info%ub_b(:) = conn_info%theta_b(:)
    conn_info%ub_c(:) = conn_info%theta_c(:)
    !
    ! PHI section
    !
    nphi_prev  = 0
    nonfo_prev = 0
    IF(ASSOCIATED(conn_info%phi_a))   nphi_prev = SIZE(conn_info%phi_a)
    IF(do_onfo.AND.ASSOCIATED(conn_info%onfo_a)) nonfo_prev = SIZE(conn_info%onfo_a)
    IF(iw>0) WRITE(iw,'(T2,A)') 'PSF_INFO| Parsing the NPHI section'
    label = '!NPHI'
    CALL parser_search_string(parser,label,.TRUE.,found,begin_line=.TRUE.)
    IF ( .NOT. found ) THEN
       IF(iw>0) WRITE (iw,'(T2,A)') 'PSF_INFO| No NPHI section '
       nphi = 0       
    ELSE
       CALL parser_get_object  (parser,nphi)
       IF(iw>0) WRITE(iw,'(T2,A,I8)') 'PSF_INFO| NPHI = ',nphi
       !malloc the memory that we need
       CALL reallocate(conn_info%phi_a,1,nphi_prev+nphi)
       CALL reallocate(conn_info%phi_b,1,nphi_prev+nphi)
       CALL reallocate(conn_info%phi_c,1,nphi_prev+nphi)
       CALL reallocate(conn_info%phi_d,1,nphi_prev+nphi)
       IF (do_onfo) THEN 
          CALL reallocate(conn_info%onfo_a,1,nonfo_prev+nphi)
          CALL reallocate(conn_info%onfo_b,1,nonfo_prev+nphi)
       END IF
       !Read in the torsion info
       DO iphi=1,nphi,2
          CALL parser_get_next_line(parser,1,error=error)
          index_now=nphi_prev+iphi-1
          READ(parser%input_line,*)(conn_info%phi_a(index_now+i),&
                                    conn_info%phi_b(index_now+i),&
                                    conn_info%phi_c(index_now+i),&
                                    conn_info%phi_d(index_now+i),&
                                    i=1,MIN(2,(nphi-iphi+1)))
       END DO
       conn_info%phi_a=conn_info%phi_a+natom_prev
       conn_info%phi_b=conn_info%phi_b+natom_prev
       conn_info%phi_c=conn_info%phi_c+natom_prev
       conn_info%phi_d=conn_info%phi_d+natom_prev
    END IF
    !
    ! ONFO structure
    !
    IF (do_onfo) THEN
       conn_info%onfo_a(:) = conn_info%phi_a(:)
       conn_info%onfo_b(:) = conn_info%phi_d(:)
       ! Reorder bonds
       ALLOCATE(ex_bond_list(natom),stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       DO I=1,natom
          ALLOCATE(ex_bond_list(I)%bonds(0),stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ENDDO
       N = 0
       IF(ASSOCIATED(conn_info%bond_a)) N = SIZE(conn_info%bond_a)
       CALL reorder_structure(ex_bond_list, conn_info%bond_a, conn_info%bond_b, N, error)
       ! Reorder bends
       ALLOCATE(ex_bend_list(natom),stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       DO I=1,natom
          ALLOCATE(ex_bend_list(I)%bonds(0),stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ENDDO
       N = 0
       IF(ASSOCIATED(conn_info%theta_a)) N = SIZE(conn_info%theta_a)
       CALL reorder_structure(ex_bend_list, conn_info%theta_a, conn_info%theta_c, N, error)    
       nonfo = 0
       DO ionfo=1, nphi
       ! Check if the torsion is not shared between angles or bonds
          IF ( ANY(ex_bond_list(conn_info%onfo_a(ionfo))%bonds==conn_info%onfo_b(ionfo)).OR.&
               ANY(ex_bend_list(conn_info%onfo_a(ionfo))%bonds==conn_info%onfo_b(ionfo))) CYCLE
          nonfo = nonfo + 1
          conn_info%onfo_a(nonfo) = conn_info%onfo_a(ionfo)
          conn_info%onfo_b(nonfo) = conn_info%onfo_b(ionfo)
       END DO
       ! deallocate bends
       DO I=1,natom
          DEALLOCATE(ex_bend_list(I)%bonds,stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ENDDO
       DEALLOCATE(ex_bend_list,stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ! deallocate bonds
       DO I=1,natom
          DEALLOCATE(ex_bond_list(I)%bonds,stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ENDDO
       DEALLOCATE(ex_bond_list,stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ! Get unique onfo
       ALLOCATE(ex_bond_list(natom),stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       DO I=1,natom
          ALLOCATE(ex_bond_list(I)%bonds(0),stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ENDDO
       N = 0
       IF(ASSOCIATED(conn_info%onfo_a)) N = nonfo_prev+nonfo
       CALL reorder_structure(ex_bond_list, conn_info%onfo_a, conn_info%onfo_b, N, error)
       nonfo = 0
       DO I=1,natom
          DO ionfo = 1, SIZE(ex_bond_list(I)%bonds)
             IF (COUNT(ex_bond_list(I)%bonds==ex_bond_list(I)%bonds(ionfo))/=1) THEN
                ex_bond_list(I)%bonds(ionfo) = 0
             ELSE
                IF (ex_bond_list(I)%bonds(ionfo)<=I) CYCLE
                nonfo = nonfo + 1
                conn_info%onfo_a(nonfo_prev+nonfo) = I
                conn_info%onfo_b(nonfo_prev+nonfo) = ex_bond_list(I)%bonds(ionfo)
             END IF
          END DO
       END DO
       CALL reallocate(conn_info%onfo_a,1,nonfo_prev+nonfo)
       CALL reallocate(conn_info%onfo_b,1,nonfo_prev+nonfo)   
       DO I=1,natom
          DEALLOCATE(ex_bond_list(I)%bonds,stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       ENDDO
       DEALLOCATE(ex_bond_list,stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    END IF
    !
    ! IMPHI section
    !
    nphi_prev = 0
    IF(ASSOCIATED(conn_info%impr_a)) nphi_prev = SIZE(conn_info%impr_a)

    IF(iw>0) WRITE(iw,'(T2,A)')'PSF_INFO| Parsing the NIMPHI section'
    label = '!NIMPHI'
    CALL parser_search_string(parser,label,.TRUE.,found,begin_line=.TRUE.)
    IF ( .NOT. found ) THEN
       IF(iw>0) WRITE (iw,'(T2,A)')'PSF_INFO| No NIMPHI section '
       nphi = 0
    ELSE
       CALL parser_get_object  (parser,nphi)
       IF(iw>0) WRITE(iw,'(T2,A,I8)')'PSF_INFO| NIMPR = ',nphi
       !malloc the memory that we need
       CALL reallocate(conn_info%impr_a,1,nphi_prev+nphi)
       CALL reallocate(conn_info%impr_b,1,nphi_prev+nphi)
       CALL reallocate(conn_info%impr_c,1,nphi_prev+nphi)
       CALL reallocate(conn_info%impr_d,1,nphi_prev+nphi)
       !Read in the improper torsion info
       DO iphi=1,nphi,2
          CALL parser_get_next_line(parser,1,error=error)
          index_now=nphi_prev+iphi-1
          READ(parser%input_line,*)(conn_info%impr_a(index_now+i),&
                                    conn_info%impr_b(index_now+i),&
                                    conn_info%impr_c(index_now+i),&
                                    conn_info%impr_d(index_now+i),&
                                    i=1,MIN(2,(nphi-iphi+1)))
       END DO
       conn_info%impr_a=conn_info%impr_a+natom_prev
       conn_info%impr_b=conn_info%impr_b+natom_prev
       conn_info%impr_c=conn_info%impr_c+natom_prev
       conn_info%impr_d=conn_info%impr_d+natom_prev
    END IF

    CALL parser_release(parser,error=error)
    CALL timestop(0.0_dp,handle)
    CALL cp_print_key_finished_output(iw,logger,subsys_section,&
         "PRINT%TOPOLOGY_INFO/PSF_INFO",error=error)

  END SUBROUTINE read_topology_psf

!!*****
!******************************************************************************
!!****** topology/write_topology_psf [1.0] *
!!
!!   NAME
!!     write_topology_psf
!!
!!   FUNCTION
!!     Write PSF topology file
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE write_topology_psf (topology,globenv,subsys_section,error)
    TYPE(topology_parameters_type), &
      INTENT(INOUT)                          :: topology
    TYPE(global_environment_type), &
      OPTIONAL, POINTER                      :: globenv
    TYPE(section_vals_type), POINTER         :: subsys_section
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'write_topology_psf', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_string_length)     :: my_tag1, my_tag2, my_tag3, &
                                                record
    INTEGER                                  :: file_unit, handle, i, iw, j, &
                                                natom, nbond, nphi, ntheta
    LOGICAL                                  :: failure, ldum
    TYPE(atom_info_type), POINTER            :: atom_info
    TYPE(connectivity_info_type), POINTER    :: conn_info
    TYPE(cp_logger_type), POINTER            :: logger

    failure = .FALSE.
    NULLIFY(logger)
    logger => cp_error_get_logger(error)
    iw = cp_print_key_unit_nr(logger,subsys_section,"PRINT%TOPOLOGY_INFO/PSF_INFO",&
         extension=".subsysLog",error=error)    
    CALL timeset(routineN,'I','',handle)

    atom_info => topology%atom_info
    conn_info => topology%conn_info
    
    record = "topology_dump.psf"

    IF(iw>0) WRITE(iw,*) "    Writing out PSF file ",TRIM(record)

    CALL open_file(file_name=record,&
         file_status="REPLACE",&
         file_action="WRITE",&
         unit_number=file_unit)

    WRITE(file_unit,*) "PSF"
    WRITE(file_unit,*) ""
    WRITE(file_unit,*) " 1 !NTITLE"
    WRITE(file_unit,*) "   CP2K generated DUMP of connectivity"
    WRITE(file_unit,*) ""
    
    WRITE(file_unit,*) " ",topology%natoms," !NATOM"
    DO i=1,topology%natoms
       my_tag1 = atom_info%label_molname(i)
       my_tag2 = atom_info%label_resname(i)
       my_tag3 = atom_info%label_atmname(i)
       ldum = qmmm_ff_precond_only_qm(my_tag1)
       ldum = qmmm_ff_precond_only_qm(my_tag2)
       ldum = qmmm_ff_precond_only_qm(my_tag3)
       WRITE(file_unit,'(I7,1X,A5,I7,1X,A5,A5,A5,F10.5,F10.5,I7)')&
            i,&
            TRIM(my_tag1),&
            atom_info%map_mol_num(i),&
            TRIM(my_tag2),&
            TRIM(my_tag3),&
            TRIM(my_tag3),&
            atom_info%atm_charge(i),&
            atom_info%atm_mass(i),0
    END DO
    WRITE(file_unit,*) ""
    
    WRITE(file_unit,*) " ",SIZE(conn_info%bond_a)," !NBOND"
    DO i=1,SIZE(conn_info%bond_a),4
       j=0
       DO WHILE ((j<4).AND.((i+j)<=SIZE(conn_info%bond_a)))
          WRITE(file_unit,'(I8,I8)',ADVANCE="NO") &
               conn_info%bond_a(i+j),conn_info%bond_b(i+j)
          j=j+1
       END DO
       WRITE(file_unit,*) ""
    END DO
    WRITE(file_unit,*) ""
    
    WRITE(file_unit,*) " ",SIZE(conn_info%theta_a)," !NTHETA"
    DO i=1,SIZE(conn_info%theta_a),3
       j=0
       DO WHILE ((j<3).AND.((i+j)<=SIZE(conn_info%theta_a)))
          WRITE(file_unit,'(I8,I8,I8)',ADVANCE="NO") &
               conn_info%theta_a(i+j),conn_info%theta_b(i+j),&
               conn_info%theta_c(i+j)
          j=j+1
       END DO
       WRITE(file_unit,*) ""
    END DO
    WRITE(file_unit,*) ""
    
    WRITE(file_unit,*) " ",SIZE(conn_info%phi_a)," !NPHI"
    DO i=1,SIZE(conn_info%phi_a),2
       j=0
       DO WHILE ((j<2).AND.((i+j)<=SIZE(conn_info%phi_a)))
          WRITE(file_unit,'(I8,I8,I8,I8)',ADVANCE="NO") &
               conn_info%phi_a(i+j),conn_info%phi_b(i+j),&
               conn_info%phi_c(i+j),conn_info%phi_d(i+j)
          j=j+1
       END DO
       WRITE(file_unit,*) ""
    END DO
    WRITE(file_unit,*) ""
    
    WRITE(file_unit,*) " ",SIZE(conn_info%impr_a)," !NIMPHI"
    DO i=1,SIZE(conn_info%impr_a),2
       j=0
       DO WHILE ((j<2).AND.((i+j)<=SIZE(conn_info%impr_a)))
          WRITE(file_unit,'(I8,I8,I8,I8)',ADVANCE="NO") &
               conn_info%impr_a(i+j),conn_info%impr_b(i+j),&
               conn_info%impr_c(i+j),conn_info%impr_d(i+j)
          j=j+1
       END DO
       WRITE(file_unit,*) ""
    END DO
    WRITE(file_unit,*) ""
    
    WRITE(file_unit,*) " 0 !NDON"
    WRITE(file_unit,*) ""
    WRITE(file_unit,*) " 0 !NACC"
    WRITE(file_unit,*) ""
    WRITE(file_unit,*) " 0 !NNB"
    WRITE(file_unit,*) ""

    CALL timestop(0.0_dp,handle)
    CALL cp_print_key_finished_output(iw,logger,subsys_section,&
         "PRINT%TOPOLOGY_INFO/PSF_INFO",error=error)  
    
  END SUBROUTINE write_topology_psf

END MODULE topology_psf

!******************************************************************************
