!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2008  CP2K developers group                          !
!-----------------------------------------------------------------------------!
!!****** cp2k/termination [1.0] *
!!
!!   NAME
!!     termination
!!
!!   FUNCTION
!!     Perform an abnormal program termination.
!!
!!   AUTHOR
!!     Matthias Krack (12.02.2001)
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   INDEX
!!     SUBROUTINE set_error_unit(lunit)
!!     SUBROUTINE stop_allocate(routine,array,memory)
!!     SUBROUTINE stop_deallocate(routine,array)
!!     SUBROUTINE stop_program(routine,message)
!!
!!   SOURCE
!******************************************************************************

MODULE termination

  USE cp_files,                        ONLY: close_file,&
                                             open_file
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE f77_blas
  USE global_types,                    ONLY: global_environment_type
  USE kinds,                           ONLY: dp
  USE machine,                         ONLY: default_output_unit,&
                                             m_flush,&
                                             m_walltime
  USE message_passing,                 ONLY: mp_abort,&
                                             mp_bcast
  USE string_utilities,                ONLY: compress
  USE timings,                         ONLY: print_stack
#include "cp_common_uses.h"

  IMPLICIT NONE

  PRIVATE

! *** Global parameters ***

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'termination'

  INTEGER :: error_unit

  PUBLIC :: external_control,&
            set_error_unit,&
            stop_memory,&
            stop_program

! *****************************************************************************

  INTERFACE stop_memory
    MODULE PROCEDURE stop_allocate,stop_allocate_new,&
                     stop_deallocate,stop_deallocate_new
  END INTERFACE

  INTERFACE stop_program
    MODULE PROCEDURE stop_program_new,stop_program_old
  END INTERFACE

!!*****
!******************************************************************************

CONTAINS

!******************************************************************************
!!****** termination/set_error_unit [1.0] *
!!
!!   NAME
!!     set_error_unit
!!
!!   FUNCTION
!!     Initialise the output unit number for error messages.
!!
!!   AUTHOR
!!     JGH
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE set_error_unit(lunit)

    INTEGER, INTENT(IN)                      :: lunit

!   ---------------------------------------------------------------------------

    error_unit = lunit

  END SUBROUTINE set_error_unit

!!*****
!******************************************************************************
!!****** termination/stop_allocate [1.0] *
!!
!!   NAME
!!     stop_allocate
!!
!!   FUNCTION
!!     The memory allocation for an array failed. Print an error message and
!!     stop the program execution.
!!
!!   AUTHOR
!!     Matthias Krack (12.10.1999)
!!
!!   MODIFICATION HISTORY
!!     CP2K by JGH 21.08.2000
!!
!!   NOTES
!!     array  : Name of the array.
!!     memory : Size of array in bytes.
!!     routine: Name of the calling routine.
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE stop_allocate(routine,array,memory)

    CHARACTER(LEN=*), INTENT(IN)             :: routine, array
    INTEGER, INTENT(IN)                      :: memory

    CHARACTER(LEN=240)                       :: message

!   ---------------------------------------------------------------------------
! just in case there is not enough memory do even trim... and fail with
! with a mystery core dump

    WRITE(default_output_unit,*) "Out of memory ..."
    CALL m_flush(default_output_unit)
    IF (memory == 0) THEN
      WRITE (message,"(A)")&
        "The memory allocation for the data object <"//TRIM(array)//"> failed"
    ELSE
      WRITE (message,"(A,I12,A)")&
        "The memory allocation for the data object <"//TRIM(array)//&
        "> failed. The requested memory size is ",memory/1024," Kbytes"
    END IF

    CALL compress(message)

    CALL stop_program(routine,message)

  END SUBROUTINE stop_allocate

! *****************************************************************************

  SUBROUTINE stop_allocate_new(routineN,moduleN,line_number,object,&
                               memory)

    CHARACTER(LEN=*), INTENT(IN)             :: routineN, moduleN
    INTEGER, INTENT(IN)                      :: line_number
    CHARACTER(LEN=*), INTENT(IN)             :: object
    INTEGER, INTENT(IN)                      :: memory

    CHARACTER(LEN=240)                       :: message

!   ---------------------------------------------------------------------------

    IF (memory == 0) THEN
      message = "The memory allocation for the data object <"//TRIM(object)//&
                "> failed"
    ELSE
      WRITE (message,"(A,I12,A)")&
        "The memory allocation for the data object <"//TRIM(object)//&
        "> failed. The requested memory size is ",memory/1024," Kbytes"
      CALL compress(message)
    END IF

    CALL stop_program(routineN,moduleN,line_number,message)

  END SUBROUTINE stop_allocate_new

!!*****
!******************************************************************************
!!****** termination/stop_deallocate [1.0] *
!!
!!   NAME
!!     stop_deallocate
!!
!!   FUNCTION
!!     The memory deallocation for an array failed. Print an error message and
!!     stop the program execution.
!!
!!   AUTHOR
!!     Matthias Krack (20.10.1999)
!!
!!   MODIFICATION HISTORY
!!     CP2K by JGH 21.08.2000
!!
!!   NOTES
!!     array  : Name of the array.
!!     routine: Name of the calling routine.
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE stop_deallocate(routine,array)

    CHARACTER(LEN=*), INTENT(IN)             :: routine, array

    CHARACTER(LEN=240)                       :: message

!   ---------------------------------------------------------------------------

    WRITE (message,"(A)")&
      "The memory deallocation for the data object <"//TRIM(array)//"> failed"

    CALL stop_program(routine,message)

  END SUBROUTINE stop_deallocate

! *****************************************************************************

  SUBROUTINE stop_deallocate_new(routineN,moduleN,line_number,object)

    CHARACTER(LEN=*), INTENT(IN)             :: routineN, moduleN
    INTEGER, INTENT(IN)                      :: line_number
    CHARACTER(LEN=*), INTENT(IN)             :: object

    CHARACTER(LEN=240)                       :: message

!   ---------------------------------------------------------------------------

    message = "The memory deallocation for the data object <"//TRIM(object)//&
              "> failed"

    CALL stop_program(routineN,moduleN,line_number,message)

  END SUBROUTINE stop_deallocate_new

!!*****
!******************************************************************************
!!****** termination/stop_program [1.0] *
!!
!!   NAME
!!     stop_program
!!
!!   FUNCTION
!!     Stop the program run and write an error message.
!!
!!   AUTHOR
!!     Matthias Krack (28.08.1996)
!!
!!   MODIFICATION HISTORY
!!     Translated to Fortran 90 (07.10.99, MK)
!!
!!   NOTES
!!     routine: Name of the calling routine
!!
!!   SOURCE
!******************************************************************************

  SUBROUTINE stop_program_old(routine,error_message,para_env)

    CHARACTER(LEN=*), INTENT(IN)             :: routine, error_message
    TYPE(cp_para_env_type), OPTIONAL, &
      POINTER                                :: para_env

    LOGICAL                                  :: ionode

!   ---------------------------------------------------------------------------

    IF (PRESENT(para_env)) THEN
      ionode = para_env%ionode
    ELSE
      ionode = .TRUE.
    END IF

!   *** Print the error message ***

    IF (ionode) THEN
      CALL print_message("ERROR in "//TRIM(routine),error_unit,2,2,0)
      CALL print_message(error_message,error_unit,1,1,1)
      CALL print_stack(error_unit)
      CALL m_flush(error_unit)
      CALL mp_abort()
    END IF


  END SUBROUTINE stop_program_old

! *****************************************************************************

  SUBROUTINE stop_program_new(routineN,moduleN,line_number,&
                              error_message,para_env)

    CHARACTER(LEN=*), INTENT(IN)             :: routineN, moduleN
    INTEGER, INTENT(IN)                      :: line_number
    CHARACTER(LEN=*), INTENT(IN)             :: error_message
    TYPE(cp_para_env_type), OPTIONAL, &
      POINTER                                :: para_env

    CHARACTER(LEN=80)                        :: message
    LOGICAL                                  :: ionode

!   ---------------------------------------------------------------------------

    IF (PRESENT(para_env)) THEN
      ionode = para_env%ionode
    ELSE
      ionode = .TRUE.
    END IF

!   *** Print the error message ***

    IF (ionode) THEN
      message = "ERROR in "//TRIM(routineN)//&
                " (MODULE "//TRIM(moduleN)//")"
      CALL print_message(message,error_unit,2,2,0)
      CALL print_message(error_message,error_unit,1,1,0)
      WRITE (UNIT=message,FMT="(A,I6,A)")&
        "Program stopped at line number ",line_number,&
        " of MODULE "//TRIM(moduleN)
      CALL compress(message)
      CALL print_message(message,error_unit,1,1,0)
      CALL print_stack(error_unit)
      CALL m_flush(error_unit)
      CALL mp_abort()
    END IF

  END SUBROUTINE stop_program_new

!*****
!******************************************************************************
!!****** termination/external_control [1.0] *
!!
!!   NAME
!!     external_control
!!
!!   FUNCTION
!!     External manipulations during a run : when the EXIT_$runtype
!!     command is sent the program stops at the level of $runtype
!!     when a general EXIT command is sent the program is stopped
!!     at all levels (at least those that call this function)
!!     if the file WAIT exists, the program waits here till it disappears
!!
!!   INPUTS
!!
!!   AUTHOR
!!     MI (10.03.2005)
!!
!!   MODIFICATION HISTORY
!!
!******************************************************************************

  SUBROUTINE external_control(should_stop,flag,globenv,error)

    LOGICAL, INTENT(OUT)                     :: should_stop
    CHARACTER(LEN=*), INTENT(IN)             :: flag
    TYPE(global_environment_type), &
      OPTIONAL, POINTER                      :: globenv
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: exit_fname = "EXIT", &
      routineN = 'external_control', routineP = moduleN//':'//routineN

    CHARACTER(LEN=10)                        :: exit_fname_level
    INTEGER                                  :: i, unit_number
    LOGICAL                                  :: failure, should_wait
    REAL(KIND=dp)                            :: t1, t2, time_check
    TYPE(cp_logger_type), POINTER            :: logger

!   ---------------------------------------------------------------------------

    failure=.FALSE.
    logger => cp_error_get_logger(error)
    should_stop = .FALSE.

    exit_fname_level = exit_fname//"_"//TRIM(flag)

    IF (logger%para_env%source==logger%para_env%mepos) THEN
       ! allows for halting execution for a while
       ! this is useful to copy a consistent snapshot of the output
       ! while a simulation is running
       INQUIRE (FILE="WAIT",EXIST=should_wait)
       IF (should_wait) THEN
          CALL open_file(file_name="WAITING",file_status="UNKNOWN",&
             file_form="FORMATTED",file_action="WRITE",&
             unit_number=unit_number)
          WRITE (UNIT=cp_logger_get_default_unit_nr(logger),FMT="(/,T2,A,/)")&
               "*** waiting till the file WAIT has been removed ***"
          DO
             ! sleep a bit (to save the file system)
             t1=m_walltime()
             DO I=1,100000000
                t2=m_walltime()
                IF (t2-t1>1.0_dp) EXIT
             ENDDO
             ! and ask again
             INQUIRE (FILE="WAIT",EXIST=should_wait)
             IF (.NOT.should_wait) EXIT
          ENDDO
          CALL close_file(unit_number=unit_number,file_status="DELETE")
       ENDIF

       ! EXIT control
       INQUIRE (FILE=exit_fname_level,EXIST=should_stop)
       IF (should_stop) THEN
          CALL open_file(file_name=exit_fname_level,unit_number=unit_number)
          CALL close_file(unit_number=unit_number,file_status="DELETE")
          WRITE (UNIT=cp_logger_get_default_unit_nr(logger),FMT="(/,T2,A,/)")&
               "*** "//flag//" run terminated by external request ***"
       ELSE
          INQUIRE (FILE=exit_fname,EXIST=should_stop)
          IF(should_stop) THEN
            WRITE (UNIT=cp_logger_get_default_unit_nr(logger),FMT="(/,T2,A,/)")&
               "*** "//TRIM(flag)//" run terminated by external request ***"
          ENDIF
       END IF
       IF ((.NOT.should_stop).AND.(globenv%cp2k_target_time > 0.0_dp)) THEN
          ! Check for execution time
          time_check  = m_walltime() - globenv%cp2k_start_time
          IF (time_check .GT. globenv%cp2k_target_time) THEN
             should_stop = .TRUE.
             WRITE (UNIT=cp_logger_get_default_unit_nr(logger),FMT="(/,T2,A,f12.3,A)")&
                  "*** "//TRIM(flag)//" run terminated - exceeded requested execution time:",&
                  globenv%cp2k_target_time," seconds.",&
                  "*** Execution time now: ",time_check," seconds."
          END IF
       END IF
    END IF
    CALL mp_bcast(should_stop,logger%para_env%source,logger%para_env%group)

  END SUBROUTINE external_control

!!*****
!******************************************************************************
END MODULE termination

!******************************************************************************
