!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000  CP2K developers group                                 !
!-----------------------------------------------------------------------------!

#include "cp_prep_globals.h"

!!****m* cp2k/qs_p_env_methods *
!!
!!   NAME
!!     qs_p_env_methods
!!
!!   NOTES
!!     - routines are programmed with spins in mind
!!       but are as of now not tested with them
!!   
!!   FUNCTION
!!     Utility functions for the perturbation calculations.
!!
!!   SYNOPSIS
!!     
!!
!!   MODIFICATION HISTORY
!!     22-08-2002, TCH, started development
!!
!!****
MODULE qs_p_env_methods
  USE atomic_kind_types,               ONLY: atomic_kind_type,&
                                             get_atomic_kind_set
  USE cp_b_matrix_structure,           ONLY: cp_b_matrix_struct_type
  USE cp_block_matrix,                 ONLY: cp_block_matrix_p_type,&
                                             cp_block_matrix_type,&
                                             cp_sp_array_create,&
                                             cp_sp_array_dealloc,&
                                             cp_sp_create,&
                                             cp_sp_multiplies_blacs,&
                                             cp_sp_set_to
  USE cp_error_handling,               ONLY: cp_a_l,&
                                             cp_assert,&
                                             cp_assertion_failed,&
                                             cp_debug,&
                                             cp_error_dealloc_ref,&
                                             cp_error_get_logger,&
                                             cp_error_init,&
                                             cp_error_message,&
                                             cp_error_type,&
                                             cp_internal_error,&
                                             cp_unimplemented_error
  USE cp_fm_basic_linalg,              ONLY: cp_fm_triangular_multiply
  USE cp_fm_cholesky,                  ONLY: cp_fm_cholesky_decompose,&
                                             cp_fm_cholesky_invert
  USE cp_fm_pool_types,                ONLY: cp_fm_pool_p_type,&
                                             cp_fm_pool_type,&
                                             fm_pool_create_fm,&
                                             fm_pool_get_el_struct,&
                                             fm_pool_give_back_fm,&
                                             fm_pools_create_fm_vect,&
                                             fm_pools_give_back_fm_vect
  USE cp_fm_struct,                    ONLY: cp_fm_struct_create,&
                                             cp_fm_struct_get,&
                                             cp_fm_struct_release,&
                                             cp_fm_struct_type
  USE cp_fm_types,                     ONLY: cp_fm_create,&
                                             cp_fm_create2,&
                                             cp_fm_get_info,&
                                             cp_full_matrix_p_type,&
                                             cp_full_matrix_type
  USE cp_fm_vect,                      ONLY: cp_fm_vect_copy,&
                                             cp_fm_vect_create2,&
                                             cp_fm_vect_dealloc
  USE cp_log_handling,                 ONLY: cp_failure_level,&
                                             cp_fatal_level,&
                                             cp_log,&
                                             cp_logger_get_default_unit_nr,&
                                             cp_logger_type,&
                                             cp_note_level,&
                                             cp_to_string,&
                                             cp_warning_level
  USE cp_matrix_utils,                 ONLY: cp_sm_output
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE cp_sm_pool_types,                ONLY: cp_sm_pool_p_type,&
                                             cp_sm_pool_type,&
                                             sm_pool_create,&
                                             sm_pool_get_mstruct,&
                                             sm_pools_create_matrix_vect,&
                                             sm_pools_give_back_matrix_vect
  USE dft_types,                       ONLY: dft_control_type
  USE global_types,                    ONLY: global_environment_type
  USE kinds,                           ONLY: dbl,&
                                             wp=>dp
  USE qs_blacs,                        ONLY: blacs_scale_and_d,&
                                             copy_blacs_to_blacs_matrix,&
                                             cp_fm_cholesky_decompose,&
                                             cp_fm_cholesky_restore,&
                                             cp_fm_gemm,&
                                             cp_fm_release,&
                                             cp_fm_scale_and_add,&
                                             cp_fm_symm,&
                                             cp_fm_syrk,&
                                             cp_fm_triangular_multiply,&
                                             cp_sm_fm_multiply,&
                                             cp_sm_plus_fm_fm_t,&
                                             optimal_blacs_col_block_size,&
                                             optimal_blacs_row_block_size,&
                                             replicate_blacs_matrix
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_environment_type
  USE qs_kpp1_env_methods,             ONLY: kpp1_calc_k_p_p1,&
                                             kpp1_calc_k_p_p1_fdiff,&
                                             kpp1_calc_k_p_p1_tddfpt,&
                                             kpp1_create,&
                                             kpp1_did_change
  USE qs_kpp1_env_types,               ONLY: kpp1_release,&
                                             kpp1_retain,&
                                             qs_kpp1_env_type
  USE qs_ks_methods,                   ONLY: qs_ks_did_change,&
                                             qs_ks_update_qs_env
  USE qs_ks_types,                     ONLY: qs_ks_env_type
  USE qs_matrix_pools,                 ONLY: mpools_get,&
                                             qs_matrix_pools_type
  USE qs_mo_types,                     ONLY: get_mo_set,&
                                             mo_set_p_type,&
                                             mo_set_type
  USE qs_p_env_types,                  ONLY: p_env_release,&
                                             p_env_retain,&
                                             qs_p_env_type
  USE qs_rho_methods,                  ONLY: qs_rho_rebuild,&
                                             qs_rho_update_rho
  USE qs_rho_types,                    ONLY: qs_rho_release,&
                                             qs_rho_type
  USE qs_tddfpt_types,                 ONLY: tddfpt_env_type
  USE sparse_matrix_types,             ONLY: cp_sm_scale_and_add,&
                                             deallocate_matrix_set,&
                                             get_matrix_info,&
                                             real_matrix_p_type,&
                                             real_matrix_type,&
                                             replicate_matrix_structure,&
                                             set_matrix
  USE string_utilities,                ONLY: compress_all
  USE timings,                         ONLY: timeset,&
                                             timestop
  IMPLICIT NONE

  CHARACTER(len=*), PRIVATE, PARAMETER :: moduleN='qs_p_env_methods'
  INTEGER, PRIVATE, SAVE :: last_p_env_id=0
  LOGICAL, PRIVATE, PARAMETER :: debug_this_module=.FALSE.

  PRIVATE
  PUBLIC :: p_env_create, p_env_psi0_changed, p_op_l2_fawzi
  PUBLIC :: p_op_l1, p_op_l1_spin, p_op_l2, p_preortho, p_postortho

CONTAINS

! *****************************************************************************

!!****f* qs_p_types/p_env_create [1.0] *
!!
!!   NAME
!!     p_env_create
!!
!!   SYNOPSIS
!!     Subroutine p_env_create(p_env, qs_env, kpp1_env, p1_option, psi0d,&
!!         orthogonal_orbitals, error)
!!       Implicit None
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (INOUT), Target:: qs_env
!!       Type(qs_kpp1_env_type), Intent (IN), Target, Optional:: kpp1_env
!!       Type(real_matrix_p_type), Dimension(:), Pointer, Optional::&
!!         p1_option
!!       Type(cp_full_matrix_p_type), Dimension(:), Pointer, Optional::&
!!         psi0d
!!       Logical, Intent (IN), Optional:: orthogonal_orbitals
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_env_create
!!
!!   FUNCTION
!!     allocates and initializes the perturbation environment (no setup)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - p_env: the environment to initialize
!!     - qs_env: the qs_environment for the system
!!     - kpp1_env: the environment that builds the second order
!!       perturbation kernel.
!!     - orthogonal_orbitals: if the orbitals are orthogonal 
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE p_env_create(p_env, qs_env, kpp1_env, p1_option, &
       psi0d, orthogonal_orbitals, error)

    IMPLICIT NONE

    ! arguments
    TYPE(qs_p_env_type), POINTER                     :: p_env
    TYPE(qs_environment_type), INTENT(inout), TARGET :: qs_env
    TYPE(qs_kpp1_env_type), INTENT(in),&
         TARGET, OPTIONAL                            :: kpp1_env
    TYPE(real_matrix_p_type), DIMENSION(:), POINTER, &
         OPTIONAL                                    :: p1_option
    TYPE(cp_full_matrix_p_type), DIMENSION(:),&
         POINTER, OPTIONAL                           :: psi0d
    LOGICAL, INTENT(in), OPTIONAL                    :: orthogonal_orbitals
    TYPE(cp_error_type), OPTIONAL, INTENT(inout)     :: error

    ! locals
    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER      :: routineN='p_env_create',&
                                        routineP=moduleN//':'//routineN
    INTEGER                          :: n_ao, n_mo, n_spins, spin, stat,handle
    TYPE(atomic_kind_type), DIMENSION(:), POINTER :: atomic_kind_set
    TYPE(dft_control_type), POINTER  :: dft_control
    TYPE(cp_full_matrix_type), POINTER :: qs_env_c
    TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER :: ao_mo_fm_pools,&
         mo_mo_fm_pools

    ! code

    CALL timeset(routineN,"I","",handle)

    n_spins = qs_env%dft_control%nspins

    failure=.FALSE.
    NULLIFY(atomic_kind_set, dft_control, ao_mo_fm_pools,&
         mo_mo_fm_pools)
    
    ALLOCATE(p_env,stat=stat)
    CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
    IF (.not.failure) THEN
       NULLIFY(p_env%kpp1, &
            p_env%p1, &
            p_env%m_epsilon, &
            p_env%psi0d, &
            p_env%S_psi0, &
            p_env%kpp1_env,&
            p_env%rho1,&
            p_env%Smo_inv)

       p_env%ref_count=1
       last_p_env_id=last_p_env_id+1
       p_env%id_nr=last_p_env_id
       p_env%iter=0

       IF (PRESENT(kpp1_env)) THEN
          p_env%kpp1_env => kpp1_env
       ELSE
          CALL kpp1_create(p_env%kpp1_env, qs_env=qs_env, error=error)
       END IF

       IF (PRESENT(p1_option)) THEN
          p_env%p1 => p1_option
       ELSE
          ALLOCATE(p_env%p1(n_spins), stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
          DO spin=1, n_spins
             NULLIFY(p_env%p1(spin)%matrix)
             CALL replicate_matrix_structure(qs_env%s(1)%matrix, p_env%p1(spin)%matrix,&
                  target_name="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//&
                  "%p1-"//TRIM(ADJUSTL(cp_to_string(spin))))
             CALL set_matrix(p_env%p1(spin)%matrix, value=0.0_wp)
          END DO
       END IF

       CALL mpools_get(qs_env%mpools, ao_mo_fm_pools=ao_mo_fm_pools,&
            mo_mo_fm_pools=mo_mo_fm_pools,&
            error=error)

       p_env%n_mo=0
       p_env%n_ao=0
       DO spin=1, n_spins
          IF (PRESENT(psi0d)) THEN
             CALL cp_fm_get_info(psi0d(spin)%matrix, &
                  ncol_global=n_mo, nrow_global=n_ao)
          ELSE
             CALL get_mo_set(qs_env%c(spin)%mo_set, eigenvectors=qs_env_c)
             CALL cp_fm_get_info(qs_env_c, &
                  ncol_global=n_mo, nrow_global=n_ao)
          END IF
          p_env%n_mo(spin) = n_mo
          p_env%n_ao(spin) = n_ao
       END DO
       
       p_env%orthogonal_orbitals=.FALSE.
       IF (PRESENT(orthogonal_orbitals)) &
            p_env%orthogonal_orbitals=orthogonal_orbitals
       
       CALL fm_pools_create_fm_vect(ao_mo_fm_pools,elements=p_env%S_psi0,&
            name="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//"%S_psi0",&
            error=error)
       
       ! alloc m_epsilon
       CALL fm_pools_create_fm_vect(mo_mo_fm_pools,elements=p_env%S_psi0,&
            name="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//&
            "%m_epsilon",&
            error=error)

       ! alloc Smo_inv
       IF (.NOT. p_env%orthogonal_orbitals) THEN
          CALL fm_pools_create_fm_vect(mo_mo_fm_pools,elements=p_env%S_psi0,&
               name="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//&
               "%Smo_inv",&
               error=error)
       END IF

       IF (PRESENT(psi0d)) THEN
          IF (ASSOCIATED(psi0d)) THEN
             CALL cp_fm_vect_copy(psi0d,p_env%psi0d,error=error)
          END IF
       ELSE IF (.NOT.p_env%orthogonal_orbitals) THEN
          CALL fm_pools_create_fm_vect(ao_mo_fm_pools,&
               elements=p_env%psi0d,&
               name="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//&
               "%psi0d", &
               error=error)
       END IF
       
    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_env_create
!***************************************************************************

!!****f* qs_p_env_methods/p_env_check_i_alloc [1.0] *
!!
!!   NAME
!!     p_env_check_i_alloc
!!
!!   FUNCTION
!!     checks that the intenal storage is allocated, and allocs it if needed
!!
!!   NOTES
!!     private routine
!!
!!   INPUTS
!!     - p_env: the environment to check
!!     - qs_env: the qs environment this p_env lives in
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     12.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE p_env_check_i_alloc(p_env, qs_env, error)
    TYPE(qs_p_env_type), POINTER :: p_env
    TYPE(qs_environment_type), INTENT(in), TARGET :: qs_env
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    INTEGER :: stat, ispin, nspins, handle
    CHARACTER(len=*), PARAMETER :: routineN='p_env_check_i_alloc',&
         routineP=moduleN//':'//routineN
    CHARACTER(len=25) :: name
    TYPE(dft_control_type), POINTER :: dft_control
    TYPE(real_matrix_p_type), DIMENSION(:), POINTER :: s

    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.
    NULLIFY(dft_control,s)

    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)
    IF (.NOT. failure) THEN
       IF (.not.ASSOCIATED(p_env%kpp1)) THEN
          CALL get_qs_env(qs_env,dft_control=dft_control, s=s,error=error)
          nspins=dft_control%nspins
          
          ALLOCATE(p_env%kpp1(nspins),stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
          IF (.NOT. failure) THEN
             name="p_env"//cp_to_string(p_env%id_nr)//"%kpp1-"
             CALL compress_all(name)
             DO ispin=1,nspins
                NULLIFY(p_env%kpp1(ispin)%matrix)
                CALL replicate_matrix_structure(s(1)%matrix,&
                     p_env%kpp1(ispin)%matrix,&
                     TRIM(name)//ADJUSTL(cp_to_string(ispin)))
             END DO
          END IF

          CALL qs_rho_rebuild(p_env%rho1, qs_env=qs_env, error=error)
       END IF
       
       IF (.not.ASSOCIATED(p_env%rho1)) THEN
          CALL qs_rho_rebuild(p_env%rho1, qs_env=qs_env, error=error)
       END IF
    END IF
    CALL timestop(0.0_wp,handle)
  END SUBROUTINE p_env_check_i_alloc
!***************************************************************************

!!****f* qs_p_build_kernel/p_env_did_change [1.0] *
!!
!!   NAME
!!     p_env_did_change
!!
!!   FUNCTION
!!     function to advise of changes either in the grids or in the the
!!     matrix structure (to update p_env's internal cache)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - p_env: the p_env to inform of the changes
!!     - grid_changed: true if the grids have changed and have to be rebuilt
!!     - s_struct_changed: true if the structure of the s matrix has changed
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     12.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE p_env_did_change(p_env, s_struct_changed, grid_changed,error)
  TYPE(qs_p_env_type), POINTER :: p_env
  LOGICAL, INTENT(in), OPTIONAL :: s_struct_changed, grid_changed
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure
  CHARACTER(len=*), PARAMETER :: routineN='p_env_did_change',&
        routineP=moduleN//':'//routineN
  INTEGER :: i, stat

  failure=.FALSE.
  
  CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
     CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)
  END IF
  IF (.not.failure) THEN
     IF (PRESENT(s_struct_changed)) THEN
        IF (s_struct_changed) THEN
           IF (ASSOCIATED(p_env%kpp1)) THEN
              CALL deallocate_matrix_set(p_env%kpp1)
           END IF
        END IF
     END IF

     IF (PRESENT(grid_changed)) THEN
        IF (grid_changed) THEN
           CALL qs_rho_release(p_env%rho1,error=error)
        END IF
     END IF

     CPPrecondition(ASSOCIATED(p_env%kpp1_env),cp_failure_level,routineP,error,failure)
  END IF
  IF (.not.failure) THEN
     CALL kpp1_did_change(p_env%kpp1_env,s_struct_changed=s_struct_changed,&
          grid_changed=grid_changed,error=error)
  END IF
END SUBROUTINE p_env_did_change
!***************************************************************************

!!****f* qs_p_types/p_env_psi0_changed [1.0] *
!!
!!   NAME
!!     p_env_psi0_changed
!!
!!   SYNOPSIS
!!     Subroutine p_env_psi0_changed(p_env, qs_env, psi0, hrho_psi0d,&
!!         error)
!!       Implicit None
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (INOUT), Target:: qs_env
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (IN), Target,&
!!         Optional:: psi0
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (INOUT),&
!!         Optional:: hrho_psi0d
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_env_psi0_changed
!!
!!   FUNCTION
!!     To be called after the value of psi0 has changed.
!!     Recalculates the quantities S_psi0 and m_epsilon.
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - p_env: the perturbation environment to set
!!     - psi0: the value of psi0, if not given defaults to the qs_env mos
!!     - Hrho_psi0d: is given, then the partial result Hrho_psi0d is stored in
!!       that vector
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
  SUBROUTINE p_env_psi0_changed(p_env, qs_env, psi0, Hrho_psi0d, error)

    IMPLICIT NONE

    ! arguments
    TYPE(qs_p_env_type), POINTER                 :: p_env
    TYPE(qs_environment_type), INTENT(inout), &
         TARGET                                  :: qs_env
    TYPE(cp_full_matrix_p_type), DIMENSION(:), &
         INTENT(in), TARGET, OPTIONAL            :: psi0
    TYPE(cp_full_matrix_p_type), DIMENSION(:), &
         INTENT(inout), OPTIONAL                 :: Hrho_psi0d
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    ! locals
    LOGICAL                                :: failure
    INTEGER                                :: n_spins, spin, stat, handle,&
         lfomo,nmo
    CHARACTER(len=*), PARAMETER            :: routineN = 'p_env_psi0_changed',&
                                              routineP = moduleN//':'//routineN
    REAL(kind=wp) :: maxocc
    TYPE(cp_full_matrix_type), POINTER                 :: tmp
    TYPE(cp_fm_pool_p_type), DIMENSION(:), POINTER     :: ao_mo_fm_pools
    TYPE(cp_full_matrix_p_type), DIMENSION(:), POINTER :: my_psi0
    TYPE(real_matrix_p_type), DIMENSION(:), POINTER    :: S,p_new
    TYPE(mo_set_p_type), DIMENSION(:), POINTER         :: c
    TYPE(cp_para_env_type), POINTER                    :: para_env
    TYPE(qs_ks_env_type), POINTER                      :: ks_env
    TYPE(qs_rho_type), POINTER                         :: rho
    TYPE(cp_sm_pool_p_type), DIMENSION(:), POINTER     :: S_sm_pools

    ! code
    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.
    NULLIFY(tmp, ao_mo_fm_pools,c,my_psi0,S,p_new,c, para_env,ks_env, rho, &
         S_sm_pools)
    n_spins = qs_env%dft_control%nspins

    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)

    IF (.NOT. failure) THEN
       p_env%iter=p_env%iter+1

       CALL get_qs_env(qs_env,&
            c=c, S=S, para_env=para_env, ks_env=ks_env, rho=rho,&
            error=error)
       CALL mpools_get(qs_env%mpools,S_sm_pools=S_sm_pools,&
            ao_mo_fm_pools=ao_mo_fm_pools, error=error)
       ! def my_psi0
       IF (PRESENT(psi0)) THEN
          CALL cp_fm_vect_copy(psi0,my_psi0,error=error)
       ELSE
          ALLOCATE(my_psi0(n_spins),stat=stat)
          CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
          IF (.NOT.failure) THEN
             DO spin=1,n_spins
                NULLIFY(my_psi0(spin)%matrix)
                CALL get_mo_set(c(spin)%mo_set,&
                     eigenvectors=my_psi0(spin)%matrix)
             END DO
          END IF
       END IF

    END IF

    IF (.NOT.failure) THEN
       
       ! def psi0d
       IF (p_env%orthogonal_orbitals) THEN
          
          p_env%psi0d => my_psi0

       ELSE

          CALL sm_pools_create_matrix_vect(S_sm_pools,p_new,&
               error=error)

          DO spin=1,n_spins
             ! m_epsilon=choleski_decomposition(my_psi0^T S my_psi0)^-1
             ! could be optimized by combining next two calls
             CALL cp_sm_fm_multiply(sparse_matrix=S(1)%matrix,&
                  v_in=my_psi0(spin)%matrix,&
                  v_out=p_env%S_psi0(spin)%matrix,&
                  ncol=p_env%n_mo(spin), para_env=para_env, &
                  alpha=1.0_wp,error=error)
             CALL cp_fm_gemm(transa='T',transb='N',n=p_env%n_mo(spin),&
                  m=p_env%n_mo(spin),k=p_env%n_ao(spin),alpha=1.0_wp,&
                  matrix_a=my_psi0(spin)%matrix, &
                  matrix_b=p_env%S_psi0(spin)%matrix,&
                  beta=0.0_wp,matrix_c=p_env%m_epsilon(spin)%matrix,&
                  error=error)
             CALL cp_fm_cholesky_decompose(p_env%m_epsilon(spin)%matrix,&
                  n=p_env%n_mo(spin),error=error)
             
             ! Smo_inv= (my_psi0^T S my_psi0)^-1
             CALL blacs_scale_and_d(p_env%Smo_inv(spin)%matrix,&
                  scale=0.0_wp, diagonal_add=1.0_wp, error=error)
             ! faster using cp_fm_cholesky_invert ?
             CALL cp_fm_triangular_multiply(&
                  triangular_matrix=p_env%m_epsilon(spin)%matrix,&
                  matrix_b=p_env%Smo_inv(spin)%matrix,side='R',&
                  invert_tr=.TRUE., n_rows=p_env%n_mo(spin),&
                  n_cols=p_env%n_mo(spin),error=error)
             CALL cp_fm_triangular_multiply(&
                  triangular_matrix=p_env%m_epsilon(spin)%matrix,&
                  matrix_b=p_env%Smo_inv(spin)%matrix,side='R',&
                  transpose_tr=.TRUE.,&
                  invert_tr=.TRUE., n_rows=p_env%n_mo(spin),&
                  n_cols=p_env%n_mo(spin),error=error)

             ! psi0d=my_psi0 (my_psi0^T S my_psi0)^-1
             ! faster using cp_fm_cholesky_invert ?
             CALL copy_blacs_to_blacs_matrix(my_psi0(spin)%matrix,&
                  p_env%psi0d(spin)%matrix, error=error)
             CALL cp_fm_triangular_multiply(&
                  triangular_matrix=p_env%m_epsilon(spin)%matrix,&
                  matrix_b=p_env%psi0d(spin)%matrix,side='R',&
                  invert_tr=.TRUE., n_rows=p_env%n_ao(spin),&
                  n_cols=p_env%n_mo(spin),error=error)
             CALL cp_fm_triangular_multiply(&
                  triangular_matrix=p_env%m_epsilon(spin)%matrix,&
                  matrix_b=p_env%psi0d(spin)%matrix,side='R',&
                  transpose_tr=.TRUE.,&
                  invert_tr=.TRUE., n_rows=p_env%n_ao(spin),&
                  n_cols=p_env%n_mo(spin),error=error)
             
             ! updates P
             CALL get_mo_set(c(spin)%mo_set,lfomo=lfomo,&
                  nmo=nmo,maxocc=maxocc)
             IF (lfomo>nmo) THEN
                CALL set_matrix(p_new(spin)%matrix,&
                     value=0.0_wp)
                CALL cp_sm_plus_fm_fm_t(p_new(spin)%matrix,&
                     matrix_v=my_psi0(spin)%matrix,&
                     matrix_g=p_env%psi0d(spin)%matrix,&
                     ncol=p_env%n_mo(spin),error=error)
                CALL cp_sm_scale_and_add(alpha=maxocc,&
                     matrix_a=p_new(spin)%matrix,error=error)
             ELSE
                CALL cp_unimplemented_error(fromWhere=routineP,&
                     message="symmetrized onesided smearing to do",&
                     error=error)
             END IF
          END DO

          ! updates rho
          CALL qs_rho_update_rho(rho_struct=qs_env%rho, &
               rho_ao_new=p_new, qs_env=qs_env,&
               error=error)
          
          CALL sm_pools_give_back_matrix_vect(S_sm_pools,p_new,&
               error=error)

          ! tells ks_env that p changed
          CALL qs_ks_did_change(ks_env=ks_env,qs_env=qs_env,&
               rho_changed=.TRUE., error=error)
          
       END IF

       ! updates K (if necessary)
       CALL qs_ks_update_qs_env(ks_env=ks_env,qs_env=qs_env,&
            error=error)
       
       !-----------------------------------------------------------------------|
       ! calculates                                                            |
       ! m_epsilon = - psi0d^T times K times psi0d                             |
       !           = - [K times psi0d]^T times psi0d (because K is symmetric)  |
       !-----------------------------------------------------------------------|
       DO spin=1, n_spins   
          ! S_psi0 = k times psi0d
          CALL cp_sm_fm_multiply(qs_env%k(spin)%matrix, &
               p_env%psi0d(spin)%matrix, &
               p_env%S_psi0(spin)%matrix, p_env%n_mo(spin), &
               para_env)
          IF (PRESENT(Hrho_psi0d)) THEN
             CALL cp_fm_scale_and_add(alpha=0.0_wp,matrix_a=Hrho_psi0d(spin)%matrix,&
                  beta=1.0_wp,matrix_b=p_env%S_psi0(spin)%matrix,&
                  error=error)
          END IF
          ! m_epsilon = -1 times S_psi0^T times psi0d
          CALL cp_fm_gemm('T', 'N', &
               p_env%n_mo(spin), p_env%n_mo(spin), p_env%n_ao(spin), &
               -1.0_dbl, p_env%S_psi0(spin)%matrix, p_env%psi0d(spin)%matrix, &
               0.0_dbl, p_env%m_epsilon(spin)%matrix)
       END DO

       !----------------------------------|
       ! calculates S_psi0 = S * my_psi0  |
       !----------------------------------|
       ! calculating this reduces the mat mult without storing a full aoxao
       ! matrix (for P). If nspin>1 you might consider calculating it on the
       ! fly to spare some memory
       CALL get_qs_env(qs_env, s=S)
       DO spin=1,n_spins
          CALL cp_sm_fm_multiply(S(1)%matrix, &
               my_psi0(spin)%matrix, &
               p_env%S_psi0(spin)%matrix, &
               p_env%n_mo(spin), para_env=para_env)
       END DO

       ! releases my_psi0
       IF (p_env%orthogonal_orbitals) THEN
          NULLIFY(my_psi0)
       ELSE
          CALL cp_fm_vect_dealloc(my_psi0,error=error)
       END IF

       ! tells kpp1_env about the change of psi0
       CALL kpp1_did_change(p_env%kpp1_env,psi0_changed=.TRUE.,error=error)

    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_env_psi0_changed
!***************************************************************************

!!****f* cp2k/qs_p_env_methods/p_op_l1 *
!!
!!   NAME
!!     p_op_l1
!!
!!   SYNOPSIS
!!     Subroutine p_op_l1(p_env, qs_env, v, res, error)
!!       Implicit None
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (IN), Target:: qs_env
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (IN):: v
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (INOUT):: res
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_op_l1
!!
!!   FUNCTION
!!     Evaluates Fv (S_mo)^-1 - Sv(epsilon) and stores it in res
!!
!!   NOTES
!!     -
!!     
!!   ARGUMENTS
!!     - p_env : perturbation calculation environment
!!     - qs_env: the qs_env that is perturbed by this p_env
!!     - v     : the matrix to operate on
!!     - res   : the result
!!     - error : error handling object (optional)
!!
!!   AUTHOR
!!     Thomas Chassaing
!!
!!   MODIFICATION HISTORY
!!     10.2002, TCH, extracted single spin calculation
!!
!!***
  SUBROUTINE p_op_l1(p_env, qs_env, v, res, error)
 
    IMPLICIT NONE
   
    ! argument
    TYPE(qs_p_env_type), POINTER                             :: p_env
    TYPE(qs_environment_type), INTENT(in), TARGET            :: qs_env
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(in)    :: v
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(inout) :: res
    TYPE(cp_error_type), OPTIONAL, INTENT(inout)             :: error
                                                           
    ! locals                                               
    LOGICAL                          :: failure
    INTEGER                          :: n_spins, spin, ncol
    CHARACTER(len=*), PARAMETER      :: routineN = 'p_op_l1',&
                                        routineP = moduleN//':'//routineN

    ! code
    failure = .FALSE.
    
    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)

    n_spins = qs_env%dft_control%nspins
    DO spin=1, n_spins
       CALL p_op_l1_spin(p_env, qs_env, spin, v(spin)%matrix,&
            res(spin)%matrix,error)
    END DO

  END SUBROUTINE p_op_l1

! *****************************************************************************

!!****f* cp2k/qs_p_env_methods/p_op_l1 *
!!
!!   NAME
!!     p_op_l1_spin
!!
!!   SYNOPSIS
!!     Subroutine p_op_l1_spin(p_env, qs_env, spin, v, res, error)
!!       Implicit None
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (IN), Target:: qs_env
!!       Integer, Intent (IN):: spin
!!       Type(cp_full_matrix_type), Pointer:: v
!!       Type(cp_full_matrix_type), Pointer:: res
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_op_l1_spin
!!
!!   FUNCTION
!!     Evaluates Fv (S_mo)^-1 - Sv(epsilon) and stores it in res
!!     for a given spin
!!
!!   NOTES
!!     Same as p_op_l1 but takes a spin as additional argument.
!!     
!!   ARGUMENTS
!!     - p_env : perturbation calculation environment
!!     - qs_env: the qs_env that is perturbed by this p_env
!!     - spin  : the spin to calculate (1 or 2 normally)
!!     - v     : the matrix to operate on
!!     - res   : the result
!      - error : error handling object (optional)
!!
!!   AUTHOR
!!     Thomas Chassaing
!!
!!   MODIFICATION HISTORY
!!     10.2002, TCH, created
!!
!!***
  SUBROUTINE p_op_l1_spin(p_env, qs_env, spin, v, res, error)
 
    IMPLICIT NONE
   
    ! argument
    TYPE(qs_p_env_type), POINTER                     :: p_env
    TYPE(qs_environment_type), INTENT(in), TARGET    :: qs_env
    INTEGER, INTENT(IN)                              :: spin
    TYPE(cp_full_matrix_type), POINTER               :: v
    TYPE(cp_full_matrix_type), POINTER               :: res
    TYPE(cp_error_type), OPTIONAL, INTENT(inout)     :: error
                                                           
    ! locals                                               
    LOGICAL                            :: failure
    INTEGER                            :: ncol, handle
    TYPE(real_matrix_type), POINTER    :: k_p
    TYPE(cp_full_matrix_type), POINTER :: tmp
    TYPE(cp_para_env_type), POINTER    :: para_env
    TYPE(cp_fm_pool_type),POINTER      :: maxao_maxmo_fm_pool
    TYPE(mo_set_p_type), DIMENSION(:), POINTER :: mos
    CHARACTER(len=*), PARAMETER        :: routineN = 'p_op_l1',&
                                          routineP = moduleN//':'//routineN

    ! code
    CALL timeset(routineN,"I","",handle)

    NULLIFY(tmp,mos)
    failure = .FALSE.
    
    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)
    CPPrecondition(0<spin,cp_failure_level,routineP,error,failure)
    CPPrecondition(spin<=qs_env%dft_control%nspins,cp_failure_level,routineP,error,failure)

    CALL get_qs_env(qs_env, &
                    para_env=para_env, error=error)
    CALL mpools_get(qs_env%mpools, maxao_maxmo_fm_pool=maxao_maxmo_fm_pool,&
         error=error)
    CALL fm_pool_create_fm(maxao_maxmo_fm_pool, tmp, error=error)
    
    k_p => qs_env%k(spin)%matrix
    CALL cp_fm_get_info(v, ncol_global=ncol)
    
    IF (p_env%orthogonal_orbitals) THEN
       CALL cp_sm_fm_multiply(k_p, v, res, ncol, para_env)
    ELSE
       CALL cp_sm_fm_multiply(k_p, v, tmp, ncol, para_env)
       CALL cp_fm_symm('R', 'U', p_env%n_ao(spin), p_env%n_mo(spin), 1._dbl, &
         p_env%Smo_inv(spin)%matrix, tmp, 0._dbl, res)
    END IF

    CALL cp_fm_symm('R', 'U', p_env%n_ao(spin), p_env%n_mo(spin), 1._dbl, &
         p_env%m_epsilon(spin)%matrix, v, 0._dbl, tmp)
    CALL cp_sm_fm_multiply(qs_env%s(spin)%matrix, tmp, &
         res, p_env%n_mo(spin), para_env=para_env, alpha=1.0_dbl,beta=1.0_dbl)    
    CALL fm_pool_give_back_fm(maxao_maxmo_fm_pool,tmp); NULLIFY(tmp)

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_op_l1_spin

! *****************************************************************************

!!****f* qs_p_env_methods/p_op_l2 [1.0] *
!!
!!   NAME
!!     p_op_l2
!!
!!   SYNOPSIS
!!     Subroutine p_op_l2(p_env, qs_env, p1, res, alpha, beta, error)
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (INOUT), Target:: qs_env
!!       Type(real_matrix_p_type), Dimension(:), Pointer:: p1
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (INOUT):: res
!!       Real(Kind=dbl), Intent (IN), Optional:: alpha, beta
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_op_l2
!!
!!   FUNCTION
!!     evaluates res = alpha kpp1(v)*psi0 + beta res
!!     with kpp1 evaluated with p=qs_env%rho%rho_ao, p1=p1
!!
!!   NOTES
!!     qs_env%rho must be up to date
!!     it would be better to pass rho1, not p1
!!
!!   INPUTS
!!     - p_env: the perturbation environment
!!     - qs_env: the qs_env that is perturbed by this p_env
!!     - p1: direction in which evaluate the second derivative 
!!     - res: place where to store the result
!!     - v: values of the coeffs of the correcting orbitals
!!     - alpha: scale factor of the result (defaults to 1.0)
!!     - beta: scale factor of the old values (defaults to 0.0)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     fawzi
!!
!!   MODIFICATION HISTORY
!!     02.09.2002 adapted for new qs_p_env_type (TC)
!!     03.2003 extended for p1 not taken from v (TC)
!!
!!*** **********************************************************************
  SUBROUTINE p_op_l2(p_env, qs_env, p1, res, alpha, beta, error)
    
    ! ARGUMENTS
    TYPE(qs_p_env_type), POINTER                             :: p_env
    TYPE(qs_environment_type), INTENT(inout), TARGET         :: qs_env
    TYPE(real_matrix_p_type), DIMENSION(:), POINTER          :: p1
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(INOUT) :: res
    REAL(kind=dbl), INTENT(in), OPTIONAL                     :: alpha, beta
    TYPE(cp_error_type), OPTIONAL, INTENT(INOUT)             :: error

    ! locals
    LOGICAL                     :: failure
    CHARACTER(len=*), PARAMETER :: routineN = 'p_op_l2',&
                                   routineP = moduleN//':'//routineN
    INTEGER                     :: ispin, n_spins, stat, handle
    REAL(kind=wp) :: my_alpha, my_beta
    TYPE(dft_control_type), POINTER :: dft_control
    TYPE(cp_para_env_type), POINTER :: para_env
    TYPE(qs_rho_type), POINTER :: rho
    TYPE(cp_logger_type), POINTER :: logger
    INTEGER, SAVE :: iter=0
    LOGICAL, PARAMETER :: fdiff=.FALSE.

    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.

    my_alpha=1.0_wp
    IF (PRESENT(alpha)) my_alpha=alpha
    my_beta=0.0_wp
    IF (PRESENT(beta)) my_beta=beta

    iter=iter+1
    NULLIFY(dft_control, para_env, rho)
    logger => cp_error_get_logger(error)

    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)

    IF (.NOT. failure) THEN
       CALL p_env_check_i_alloc(p_env,qs_env=qs_env,error=error)

       CALL get_qs_env(qs_env,dft_control=dft_control,&
            para_env=para_env, rho=rho, error=error)
       n_spins = dft_control%nspins
    END IF

    IF (.not.failure) THEN
       CALL qs_rho_update_rho(rho_struct=p_env%rho1, &
            rho_ao_new=p1, qs_env=qs_env,&
            rebuild=.TRUE., error=error)

       IF (dft_control%do_tddfpt_calculation .AND. .FALSE.) THEN
          CALL kpp1_calc_k_p_p1_tddfpt(kpp1_env=p_env%kpp1_env,qs_env=qs_env,&
                                k_p_p1=p_env%kpp1, rho=rho ,rho1=p_env%rho1,&
                                rebuild=.TRUE., &
                                error=error)
       ELSE
          IF (fdiff) THEN
             CALL kpp1_calc_k_p_p1_fdiff(kpp1_env=p_env%kpp1_env,qs_env=qs_env,&
                  k_p_p1=p_env%kpp1, rho=rho ,rho1=p_env%rho1,&
                  rebuild=.TRUE.,error=error)
          ELSE
             CALL kpp1_calc_k_p_p1(kpp1_env=p_env%kpp1_env,qs_env=qs_env,&
                  k_p_p1=p_env%kpp1, rho=rho ,rho1=p_env%rho1,&
                  rebuild=.TRUE.,error=error)
          END IF
       END IF

       DO ispin=1,n_spins
!!          CALL cp_sm_output(logger=logger, &
!!               outputName="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//&
!!               "%kpp1-"//TRIM(ADJUSTL(cp_to_string(ispin))),&
!!               fromWhere=routineP, iter=iter, matrix=p_env%kpp1(ispin)%matrix,&
!!               para_env=qs_env%para_env, error=error)
          CALL cp_sm_fm_multiply(sparse_matrix=p_env%kpp1(ispin)%matrix,&
               v_in=p_env%psi0d(ispin)%matrix, v_out=res(ispin)%matrix,&
               ncol=p_env%n_mo(ispin),&
               para_env=para_env,&
               alpha=my_alpha,beta=my_beta,error=error)
       END DO
    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_op_l2
!***************************************************************************

!!****f* qs_p_types/p_env_preortho [1.0] *
!!
!!   NAME
!!     p_preortho
!!
!!   SYNOPSIS
!!     Subroutine p_preortho(p_env, qs_env, v, n_cols, error)
!!       Implicit None
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (IN), Target:: qs_env
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (INOUT):: v
!!       Integer, Dimension(:), Intent (IN), Optional:: n_cols
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_preortho
!!
!!   FUNCTION
!!     does a preorthogonalization of the given matrix:
!!     v = (I-PS)v
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - p_env: the perturbation environment
!!     - qs_env: the qs_env that is perturbed by this p_env
!!     - v: matrix to orthogonalize
!!     - n_cols: the number of columns of C to multiply (defaults to size(v,2))
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     02.09.2002 adapted for new qs_p_env_type (TC)
!!
!!*** **********************************************************************
  SUBROUTINE p_preortho(p_env, qs_env, v, n_cols, error)

    IMPLICIT NONE

    ! arguments
    TYPE(qs_p_env_type), POINTER                             :: p_env
    TYPE(qs_environment_type), INTENT(in), TARGET            :: qs_env
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(inout) :: v
    INTEGER, DIMENSION(:), INTENT(in), OPTIONAL              :: n_cols
    TYPE(cp_error_type), OPTIONAL, INTENT(inout)             :: error

    ! locals
    LOGICAL                            :: failure
    CHARACTER(len=*), PARAMETER        :: routineN = 'p_preortho',&
         routineP = moduleN//':'//routineN
    INTEGER                            :: v_rows, v_cols, cols, handle
    INTEGER                            :: n_spins, spin, nmo2,maxnmo, max_cols
    TYPE(cp_full_matrix_type), POINTER :: tmp_matrix
    TYPE(cp_fm_pool_type), POINTER     :: maxmo_maxmo_fm_pool
    TYPE(cp_fm_struct_type), POINTER   :: maxmo_maxmo_fmstruct,&
         tmp_fmstruct
    TYPE(dft_control_type), POINTER    :: dft_control

    ! code
    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.

    NULLIFY(tmp_matrix,maxmo_maxmo_fm_pool, maxmo_maxmo_fmstruct,tmp_fmstruct,&
         dft_control)

    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)

    IF (.NOT. failure) THEN          
       CALL get_qs_env(qs_env, dft_control=dft_control,&
            error=error)
       CALL mpools_get(qs_env%mpools,maxmo_maxmo_fm_pool=maxmo_maxmo_fm_pool,&
            error=error)
       n_spins = qs_env%dft_control%nspins
       maxmo_maxmo_fmstruct => fm_pool_get_el_struct(maxmo_maxmo_fm_pool,error=error)
       CALL cp_fm_struct_get(maxmo_maxmo_fmstruct, nrow_global=nmo2,ncol_global=maxnmo)
       CPPrecondition(SIZE(v)>=n_spins,cp_failure_level,routineP,error,failure)
    END IF
    IF (.not.failure) THEN
       ! alloc tmp storage
       IF (PRESENT(n_cols)) THEN
          max_cols=MAXVAL(n_cols(1:n_spins))
       ELSE
          max_cols=0
          DO spin=1, n_spins
             CALL cp_fm_get_info(v(spin)%matrix, ncol_global=v_cols)
             max_cols = MAX(max_cols, v_cols)
          END DO
       END IF
       IF (max_cols <= nmo2) THEN
          CALL fm_pool_create_fm(maxmo_maxmo_fm_pool,tmp_matrix,error=error)
       ELSE
          CALL cp_fm_struct_create(tmp_fmstruct,nrow_global=max_cols,&
               ncol_global=maxnmo,template_fmstruct=maxmo_maxmo_fmstruct,&
               error=error)
          CALL cp_fm_create(tmp_matrix,matrix_struct=tmp_fmstruct,&
               error=error)
          CALL cp_fm_struct_release(tmp_fmstruct,error=error)
       END IF

       DO spin=1, n_spins

          CALL cp_fm_get_info(v(spin)%matrix, &
               nrow_global=v_rows, ncol_global=v_cols)
          CPPrecondition(v_rows>=p_env%n_ao(spin),cp_failure_level,routineP,error,failure)
          cols = v_cols
          IF (PRESENT(n_cols)) THEN
             CPPrecondition(n_cols(spin)<=cols,cp_failure_level,routineP,error,failure)
             cols=n_cols(spin)
          END IF
          CPPrecondition(cols<=max_cols,cp_failure_level,routineP,error,failure)

          IF (.NOT. failure) THEN          
             ! tmp_matrix = v^T (S psi0)
             CALL cp_fm_gemm(transa='T',transb='N',m=cols,n=p_env%n_mo(spin),&
                  k=p_env%n_ao(spin),alpha=1.0_wp,matrix_a=v(spin)%matrix,&
                  matrix_b=p_env%S_psi0(spin)%matrix,beta=0.0_wp,&
                  matrix_c=tmp_matrix,error=error)
             ! v = v- psi0d tmp_matrix^T = v - psi0d psi0^T S v
             CALL cp_fm_gemm(transa='N',transb='T',m=p_env%n_ao(spin),n=cols,&
                  k=p_env%n_mo(spin),alpha=-1.0_wp,&
                  matrix_a=p_env%psi0d(spin)%matrix,matrix_b=tmp_matrix,&
                  beta=1.0_wp,matrix_c=v(spin)%matrix,error=error)
          END IF

       END DO

       IF (max_cols <= nmo2) THEN
          CALL fm_pool_give_back_fm(maxmo_maxmo_fm_pool,tmp_matrix,&
               error=error)
       ELSE
          CALL cp_fm_release(tmp_matrix,error=error)
       END IF
    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_preortho
!***************************************************************************

!!****f* qs_p_types/p_env_postortho [1.0] *
!!
!!   NAME
!!     p_postortho
!!
!!   SYNOPSIS
!!     Subroutine p_postortho(p_env, qs_env, v, n_cols, error)
!!       Implicit None
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (IN), Target:: qs_env
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (INOUT):: v
!!       Integer, Dimension(:), Intent (IN), Optional:: n_cols
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_postortho
!!
!!   FUNCTION
!!     does a postorthogonalization on the given matrix vector:
!!     v = (I-SP) v
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - p_env: the perturbation environment
!!     - qs_env: the qs_env that is perturbed by this p_env
!!     - v: matrix to orthogonalize
!!     - n_cols: the number of columns of C to multiply (defaults to size(v,2))
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************

  SUBROUTINE p_postortho(p_env, qs_env, v, n_cols, error)

    IMPLICIT NONE

    ! arguments
    TYPE(qs_p_env_type), POINTER                             :: p_env
    TYPE(qs_environment_type), INTENT(in), TARGET            :: qs_env
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(inout) :: v
    INTEGER, DIMENSION(:), INTENT(in), OPTIONAL              :: n_cols
    TYPE(cp_error_type), OPTIONAL, INTENT(inout)             :: error

    ! locals
    LOGICAL                            :: failure
    CHARACTER(len=*), PARAMETER        :: routineN = 'p_postortho',&
         routineP = moduleN//':'//routineN
    INTEGER                            :: v_rows, v_cols, cols, handle
    INTEGER                            :: n_spins, spin, nmo2,maxnmo, max_cols
    TYPE(cp_full_matrix_type), POINTER :: tmp_matrix
    TYPE(cp_fm_pool_type), POINTER     :: maxmo_maxmo_fm_pool
    TYPE(cp_fm_struct_type), POINTER :: maxmo_maxmo_fmstruct,&
         tmp_fmstruct
    TYPE(dft_control_type), POINTER    :: dft_control

    ! code
    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.
    NULLIFY(tmp_matrix,maxmo_maxmo_fm_pool, maxmo_maxmo_fmstruct,tmp_fmstruct,&
         dft_control)

    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)

    IF (.NOT. failure) THEN
       CALL get_qs_env(qs_env, dft_control=dft_control,error=error)
       CALL mpools_get(qs_env%mpools, maxmo_maxmo_fm_pool=maxmo_maxmo_fm_pool,&
            error=error)
       n_spins = dft_control%nspins
       maxmo_maxmo_fmstruct => fm_pool_get_el_struct(maxmo_maxmo_fm_pool,error=error)
       CALL cp_fm_struct_get(maxmo_maxmo_fmstruct, nrow_global=nmo2,ncol_global=maxnmo)
       CPPrecondition(SIZE(v)>=n_spins,cp_failure_level,routineP,error,failure)
    END IF
    IF (.not.failure) THEN
       ! alloc tmp storage
       IF (PRESENT(n_cols)) THEN
          max_cols=MAXVAL(n_cols(1:n_spins))
       ELSE
          max_cols=0
          DO spin=1, n_spins
             CALL cp_fm_get_info(v(spin)%matrix, ncol_global=v_cols)
             max_cols = MAX(max_cols, v_cols)
          END DO
       END IF
       IF (max_cols <= nmo2) THEN
          CALL fm_pool_create_fm(maxmo_maxmo_fm_pool,tmp_matrix,error=error)
       ELSE
          CALL cp_fm_struct_create(tmp_fmstruct,nrow_global=max_cols,&
               ncol_global=maxnmo,template_fmstruct=maxmo_maxmo_fmstruct,&
               error=error)
          CALL cp_fm_create(tmp_matrix,matrix_struct=tmp_fmstruct,&
               error=error)
          CALL cp_fm_struct_release(tmp_fmstruct,error=error)
       END IF

       DO spin=1, n_spins

          CALL cp_fm_get_info(v(spin)%matrix, &
               nrow_global=v_rows, ncol_global=v_cols)
          CPPrecondition(v_rows>=p_env%n_ao(spin),cp_failure_level,routineP,error,failure)
          cols = v_cols
          IF (PRESENT(n_cols)) THEN
             CPPrecondition(n_cols(spin)<=cols,cp_failure_level,routineP,error,failure)
             cols=n_cols(spin)
          END IF
          CPPrecondition(cols<=max_cols,cp_failure_level,routineP,error,failure)

          IF (.NOT. failure) THEN          
             ! tmp_matrix = v^T psi0d
             CALL cp_fm_gemm(transa='T',transb='N',m=cols,n=p_env%n_mo(spin),&
                  k=p_env%n_ao(spin),alpha=1.0_wp,matrix_a=v(spin)%matrix,&
                  matrix_b=p_env%psi0d(spin)%matrix,beta=0.0_wp,&
                  matrix_c=tmp_matrix,error=error)
             ! v = v- (S psi0) tmp_matrix^T = v - S psi0 psi0d^T v
             CALL cp_fm_gemm(transa='N',transb='T',m=p_env%n_ao(spin),n=cols,&
                  k=p_env%n_mo(spin),alpha=-1.0_wp,&
                  matrix_a=p_env%S_psi0(spin)%matrix,matrix_b=tmp_matrix,&
                  beta=1.0_wp,matrix_c=v(spin)%matrix,error=error)
          END IF

       END DO

       IF (max_cols <= nmo2) THEN
          CALL fm_pool_give_back_fm(maxmo_maxmo_fm_pool,tmp_matrix,&
               error=error)
       ELSE
          CALL cp_fm_release(tmp_matrix)
       END IF
    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_postortho

!***************************************************************************


!!****f* qs_p_env_methods/p_op_l2 [1.0] *
!!
!!   NAME
!!     p_op_l2
!!
!!   SYNOPSIS
!!     Subroutine p_op_l2(p_env, qs_env, p1, res, alpha, beta, error)
!!       Type(qs_p_env_type), Pointer:: p_env
!!       Type(qs_environment_type), Intent (INOUT), Target:: qs_env
!!       Type(real_matrix_p_type), Dimension(:), Pointer:: p1
!!       Type(cp_full_matrix_p_type), Dimension(:), Intent (INOUT):: res
!!       Real(Kind=dbl), Intent (IN), Optional:: alpha, beta
!!       Type(cp_error_type), Optional, Intent (INOUT):: error
!!     End Subroutine p_op_l2
!!
!!   FUNCTION
!!     evaluates res = alpha kpp1(v)*psi0 + beta res
!!
!!   NOTES
!!     to be removed
!!
!!   INPUTS
!!     - p_env: the perturbation environment
!!     - qs_env: the qs_env that is perturbed by this p_env
!!     - res: place where to store the result
!!     - v: values of the coeffs of the correcting orbitals
!!     - alpha: scale factor of the result (defaults to 1.0)
!!     - beta: scale factor of the old values (defaults to 0.0)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     02.09.2002 adapted for new qs_p_env_type (TC)
!!
!!*** **********************************************************************
  SUBROUTINE p_op_l2_fawzi(p_env, qs_env, v, res, alpha, beta, error)
    
    ! arguments
    TYPE(qs_p_env_type), POINTER                             :: p_env
    TYPE(qs_environment_type), INTENT(inout), TARGET         :: qs_env
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(in)    :: v
    TYPE(cp_full_matrix_p_type), DIMENSION(:), INTENT(inout) :: res
    REAL(kind=dbl), INTENT(in), OPTIONAL                     :: alpha, beta
    TYPE(cp_error_type), OPTIONAL, INTENT(inout)             :: error

    ! locals
    LOGICAL                     :: failure
    CHARACTER(len=*), PARAMETER :: routineN = 'p_op_l2',&
                                   routineP = moduleN//':'//routineN
    INTEGER                     :: ispin, n_spins, stat, lfomo, nmo, handle
    REAL(kind=wp) :: my_alpha, my_beta, maxocc
    TYPE(real_matrix_p_type), DIMENSION(:), POINTER :: p1_new, s
    TYPE(dft_control_type), POINTER :: dft_control
    TYPE(cp_para_env_type), POINTER :: para_env
    TYPE(qs_rho_type), POINTER :: rho
    TYPE(cp_logger_type), POINTER :: logger
    TYPE(mo_set_p_type), DIMENSION(:), POINTER :: mos
    INTEGER, SAVE :: iter=0

    CALL timeset(routineN,"I","",handle)

    failure=.FALSE.

    my_alpha=1.0_wp
    IF (PRESENT(alpha)) my_alpha=alpha
    my_beta=0.0_wp
    IF (PRESENT(beta)) my_beta=beta

    iter=iter+1
    NULLIFY(p1_new, s, dft_control, para_env, rho, mos)
    logger => cp_error_get_logger(error)

    CPPrecondition(ASSOCIATED(p_env),cp_failure_level,routineP,error,failure)
    CPPrecondition(p_env%ref_count>0,cp_failure_level,routineP,error,failure)

    IF (.NOT. failure) THEN
       CALL p_env_check_i_alloc(p_env,qs_env=qs_env,error=error)

       CALL get_qs_env(qs_env,dft_control=dft_control,&
            para_env=para_env, rho=rho, s=s,c=mos,&
            error=error)
       n_spins=dft_control%nspins

       p1_new => p_env%rho1%rho_ao
    END IF
    IF (.not.failure) THEN
       DO ispin=1,n_spins
          CALL get_mo_set(mos(ispin)%mo_set,lfomo=lfomo,nmo=nmo,&
               maxocc=maxocc)
          IF (lfomo>nmo) THEN
             CALL set_matrix(p1_new(ispin)%matrix,&
                  value=0.0_wp)
             ! optimize?
             CALL cp_sm_plus_fm_fm_t(p1_new(ispin)%matrix,&
                  matrix_v=v(ispin)%matrix,&
                  matrix_g=p_env%psi0d(ispin)%matrix,&
                  ncol=p_env%n_mo(ispin),error=error)
             CALL cp_sm_plus_fm_fm_t(p1_new(ispin)%matrix,&
                  matrix_v=p_env%psi0d(ispin)%matrix,&
                  matrix_g=v(ispin)%matrix,&
                  ncol=p_env%n_mo(ispin),error=error)
             CALL cp_sm_scale_and_add(alpha=maxocc, &
                  matrix_a=p1_new(ispin)%matrix,error=error)
          ELSE
             CALL cp_unimplemented_error(fromWhere=routineP,&
                  message="symmetrized onesided smearing to do",&
                  error=error)
          END IF
          IF (debug_this_module) THEN
             CALL cp_sm_output(logger=logger, &
                  outputName="p_env"//TRIM(ADJUSTL(cp_to_string(p_env%id_nr)))//&
                  "%p1_new-"//TRIM(ADJUSTL(cp_to_string(ispin))),&
                  fromWhere=routineP, iter=iter, matrix=p1_new(ispin)%matrix,&
                  para_env=qs_env%para_env, error=error)
          END IF
       END DO
       CALL p_op_l2(p_env, qs_env, p1_new, res, alpha=my_alpha, beta=my_beta, error=error)
    END IF

    CALL timestop(0.0_wp,handle)

  END SUBROUTINE p_op_l2_fawzi
!***************************************************************************

END MODULE qs_p_env_methods
