!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2001  CP2K developers group                                 !
!-----------------------------------------------------------------------------!

[defines]
!!****h* cp2k/cp_linked_list_[nametype1] [1.0] *
!!
!!   NAME
!!     cp_linked_list_[nametype1]
!!
!!   FUNCTION
!!     describes a generic linked list template.
!!     Linked list are supposed to always use pointers to the nodes for
!!     basically everything: a pointer to the node is a list, an element of
!!     the list, an iterator between the elment of the list.
!!     An empty list is represented by an unassociated pointer.
!!
!!   NOTES
!!    ____              _ _     __  __           _ _  __         _____ _     _       _____ _ _      _ 
!!   |  _ \  ___  _ __ ( ) |_  |  \/  | ___   __| (_)/ _|_   _  |_   _| |__ (_)___  |  ___(_) | ___| |
!!   | | | |/ _ \| '_ \|/| __| | |\/| |/ _ \ / _` | | |_| | | |   | | | '_ \| / __| | |_  | | |/ _ \ |
!!   | |_| | (_) | | | | | |_  | |  | | (_) | (_| | |  _| |_| |   | | | | | | \__ \ |  _| | | |  __/_|
!!   |____/ \___/|_| |_|  \__| |_|  |_|\___/ \__,_|_|_|  \__, |   |_| |_| |_|_|___/ |_|   |_|_|\___(_)
!!                                                       |___/                                        
!!     ____ _                  ___                              _ _       _       _       
!!    / ___| | ___  ___  ___  |_ _|_ __ ___  _ __ ___   ___  __| (_) __ _| |_ ___| |_   _ 
!!   | |   | |/ _ \/ __|/ _ \  | || '_ ` _ \| '_ ` _ \ / _ \/ _` | |/ _` | __/ _ \ | | | |
!!   | |___| | (_) \__ \  __/  | || | | | | | | | | | |  __/ (_| | | (_| | ||  __/ | |_| |
!!    \____|_|\___/|___/\___| |___|_| |_| |_|_| |_| |_|\___|\__,_|_|\__,_|\__\___|_|\__, |
!!                                                                                  |___/ 
!!    _____ _     _       _____ _ _      _ 
!!   |_   _| |__ (_)___  |  ___(_) | ___| |
!!     | | | '_ \| / __| | |_  | | |/ _ \ |
!!     | | | | | | \__ \ |  _| | | |  __/_|
!!     |_| |_| |_|_|___/ |_|   |_|_|\___(_)
!!   
!!     This is a template
!!
!!     **** DO NOT MODIFY THE .F FILES ****
!!     modify the .template and .instantition instead
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     1.2002 created
!!     4.2002 changed most of the methods, by making access to the list 
!!            always through pointers (identifying pointer, list and iterators)
!!     6.2004 removed %initialized from list elements
!!
!!   SOURCE
!*****************************************************************************
MODULE cp_linked_list_[nametype1]
#include "cp_common_uses.h"
  [USE]
  IMPLICIT NONE
  PRIVATE

  LOGICAL, PRIVATE, PARAMETER :: debug_this_module=.TRUE.
  CHARACTER(len=*), PRIVATE, PARAMETER :: moduleN='cp_linked_list_[nametype1]'

! type
  PUBLIC :: cp_sll_[nametype1]_type, cp_sll_[nametype1]_p_type
! common methods
  PUBLIC :: cp_create, cp_dealloc, cp_get, cp_set, cp_next
! special get
  PUBLIC :: cp_get_first_el, cp_get_rest, cp_get_empty, cp_get_length,&
       cp_get_element_at, cp_to_array
! special set
  PUBLIC :: cp_set_element_at
! structure manipulation
  PUBLIC :: cp_insert, cp_remove_first_el, cp_remove_el, cp_remove_all
! low level
  PUBLIC :: cp_dealloc_node

  ! underlying routines
  PUBLIC :: cp_sll_[nametype1]_create, cp_sll_[nametype1]_dealloc,&
       cp_sll_[nametype1]_dealloc_node,cp_sll_[nametype1]_set,&
       cp_sll_[nametype1]_get,cp_sll_[nametype1]_next,&
       cp_sll_[nametype1]_get_first_el, cp_sll_[nametype1]_get_rest,&
       cp_sll_[nametype1]_get_empty, cp_sll_[nametype1]_get_length,&
       cp_sll_[nametype1]_get_el_at, cp_sll_[nametype1]_set_el_at,&
       cp_sll_[nametype1]_insert_el, cp_sll_[nametype1]_insert_el_at,&
       cp_sll_[nametype1]_rm_first_el, cp_sll_[nametype1]_rm_el_at,&
       cp_sll_[nametype1]_rm_all_el, &
       cp_sll_[nametype1]_to_array,&
       cp_sll_[nametype1]_from_array, cp_sll_[nametype1]_insert_ordered,&
       cp_sll_[nametype1]_insert_ordered2

! creation of an object (from a pointer)
  INTERFACE cp_create
     MODULE PROCEDURE cp_sll_[nametype1]_create
  END INTERFACE
! destruction of an object (from a pointer)
  INTERFACE cp_dealloc
     MODULE PROCEDURE cp_sll_[nametype1]_dealloc
  END INTERFACE
! destruction only of the node (low level)
  INTERFACE cp_dealloc_node
     MODULE PROCEDURE cp_sll_[nametype1]_dealloc_node
  END INTERFACE
! modifies attributes of an object
  INTERFACE cp_set
     MODULE PROCEDURE cp_sll_[nametype1]_set
  END INTERFACE
! returns attributes of an object
  INTERFACE cp_get
     MODULE PROCEDURE cp_sll_[nametype1]_get
  END INTERFACE
! iterates to the next element
  INTERFACE cp_next
     MODULE PROCEDURE cp_sll_[nametype1]_next
  END INTERFACE
! returns the first element
  INTERFACE cp_get_first_el
     MODULE PROCEDURE cp_sll_[nametype1]_get_first_el
  END INTERFACE
! returns the rest of the list
  INTERFACE cp_get_rest
     MODULE PROCEDURE cp_sll_[nametype1]_get_rest
  END INTERFACE
! returns if the list is empty
  INTERFACE cp_get_empty
     MODULE PROCEDURE cp_sll_[nametype1]_get_empty
  END INTERFACE
! returns the length of the list
  INTERFACE cp_get_length
     MODULE PROCEDURE cp_sll_[nametype1]_get_length
  END INTERFACE
! returns the element at the given position
  INTERFACE cp_get_element_at
     MODULE PROCEDURE cp_sll_[nametype1]_get_el_at
  END INTERFACE
! sets the element at the given position
  INTERFACE cp_set_element_at
     MODULE PROCEDURE cp_sll_[nametype1]_set_el_at
  END INTERFACE
! inserts one element call cp_insert(list,element,...)
  INTERFACE cp_insert
     MODULE PROCEDURE cp_sll_[nametype1]_insert_el
  END INTERFACE
!MK  INTERFACE cp_insert_ordered
!MK     MODULE PROCEDURE cp_sll_[nametype1]_insert_ordered,&
!MK          cp_sll_[nametype1]_insert_ordered2
!MK  END INTERFACE
  INTERFACE cp_insert_at
     MODULE PROCEDURE cp_sll_[nametype1]_insert_el_at
  END INTERFACE
! removes an element
  INTERFACE cp_remove_el
     MODULE PROCEDURE cp_sll_[nametype1]_rm_first_el, &
          cp_sll_[nametype1]_rm_el_at
  END INTERFACE
! removes the first el
  INTERFACE cp_remove_first_el
     MODULE PROCEDURE cp_sll_[nametype1]_rm_first_el
  END INTERFACE
! remove all the elments
  INTERFACE cp_remove_all
     MODULE PROCEDURE cp_sll_[nametype1]_rm_all_el
  END INTERFACE
! transorms the list in array
  INTERFACE cp_to_array
     module procedure cp_sll_[nametype1]_to_array
  END INTERFACE
!!***
!****************************************************************************

!!****s* cp2k/cp_sll_[nametype1]_type [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_type
!!
!!   FUNCTION
!!     represent a single linked list that stores pointers to the elements
!!
!!   NOTES
!!     List are alway accessed through pointers, so every node of the 
!!     linked list can be seen as a list, its first element
!!     a pointer to the position before itself, in a very natural way:
!!     all the insertions take place before the actual element, and 
!!     you still can insert an element at the end.
!!     This way I could identify nodes, lists and pointers between the
!!     elements of the list.
!!     Indexing is 1 based.
!!
!!   ATTRIBUTES
!!     first_el: the element that is stored in this node. 
!!     rest: the rest of the list
!!
!!     empty: true if the list pointer is not associated, if it points to
!!            to a not it is always false (as there is at least the 
!!            first_el in the list)
!!     length: the number of elements in the list
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   SOURCE
!***************************************************************************
  TYPE cp_sll_[nametype1]_type
     [type1] :: first_el
     TYPE(cp_sll_[nametype1]_type), POINTER :: rest
  END TYPE cp_sll_[nametype1]_type
!!***
!****************************************************************************

!!****s* cp2k/cp_sll_[nametype1]_p_type [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_p_type
!!
!!   FUNCTION
!!     pointer to a linked list (to make arrays of pointers)
!!
!!   NOTES
!!     -
!!
!!   ATTRIBUTES
!!     list: the pointer to the list
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   SOURCE
!***************************************************************************
  TYPE cp_sll_[nametype1]_p_type
     TYPE(cp_sll_[nametype1]_type), POINTER :: list
  END TYPE cp_sll_[nametype1]_p_type
!!***
!****************************************************************************

CONTAINS

[private_routines]
! =========== creation / distruction ========

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_create [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_create
!!
!!   FUNCTION
!!    allocates and initializes a single linked list
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     sll: the single linked list to initialize
!!     first_el: the first element of this list
!!     rest: the following elements (if not given: empty)
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_create(sll,first_el,rest,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    [type1in], OPTIONAL :: first_el
    TYPE(cp_sll_[nametype1]_type), POINTER, OPTIONAL :: rest
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_create'
    INTEGER :: stat
    failure=.FALSE.

    IF (.NOT.PRESENT(first_el)) THEN
       NULLIFY(sll)
       IF (PRESENT(rest)) sll => rest
    ELSE
       ALLOCATE(sll, stat=stat)
       CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
       IF (.NOT.failure) THEN
          sll%first_el [=] first_el
          NULLIFY(sll%rest)
          IF (PRESENT(rest)) sll%rest => rest
       END IF
    END IF
    IF (failure) NULLIFY(sll)
  END SUBROUTINE cp_sll_[nametype1]_create
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_dealloc [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_dealloc
!!
!!   FUNCTION
!!     deallocates the singly linked list starting at sll.
!!     Does not work if loops are present!
!!
!!   NOTES
!!     does not deallocate the elments that are stored in the list
!!     check more?
!!
!!   INPUTS
!!     sll: the list to be deallocated
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_dealloc(sll,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_dealloc'

    CALL cp_sll_[nametype1]_rm_all_el(sll,error)
  END SUBROUTINE cp_sll_[nametype1]_dealloc
!***************************************************************************

! * low-level *

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_dealloc_node [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_dealloc_node
!!
!!   FUNCTION
!!     deallocates a node of a singly linked list (low level)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     sll: the node to be deallocated
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_dealloc_node(sll,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_dealloc_node'
    INTEGER:: stat
    failure=.FALSE.

    DEALLOCATE(sll, stat=stat)
    CPPostcondition(stat==0,cp_warning_level,routineP,error,failure)
  END SUBROUTINE cp_sll_[nametype1]_dealloc_node
!***************************************************************************

! ============= get/set ============

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_set [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_set
!!
!!   FUNCTION
!!     sets tha various attributes of a single linked list
!!     It is an error to set the rest of an empty list without setting 
!!     the first_el (change and make it simply a sll=>rest ?)
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     sll: the single linked list to change
!!     first_el: the element to replace the first element of this list
!!     rest: the rest of the list (can be unassociated)
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_set(sll,first_el,rest,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    [type1in], OPTIONAL :: first_el
    TYPE(cp_sll_[nametype1]_type), POINTER, OPTIONAL :: rest
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_set_sll_[nametype1]'
    failure=.FALSE.

    IF (.NOT.ASSOCIATED(sll)) THEN
       IF (PRESENT(first_el)) THEN
          CALL cp_sll_[nametype1]_create(sll,first_el,rest,error)
       ELSE
          CPAssert(.NOT.PRESENT(rest),cp_failure_level,routineP,error,failure)
       END IF
    ELSE
       IF (PRESENT(first_el)) sll%first_el [=] first_el
       IF (PRESENT(rest)) sll%rest => rest
    END IF
  END SUBROUTINE cp_sll_[nametype1]_set
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_get [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_get
!!
!!   FUNCTION
!!     returns various attributes from the linked list
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     sll: the single linked list to change
!!     first_el: the first element of this list (can be unassociated)
!!     rest: the rest of the list (can be unassociated)
!!     length: the length of the list
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_get(sll,first_el,rest,empty,length,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    [type1out], OPTIONAL :: first_el
    TYPE(cp_sll_[nametype1]_type), OPTIONAL, POINTER :: rest
    LOGICAL, OPTIONAL, INTENT(out) :: empty
    INTEGER, INTENT(out), OPTIONAL :: length
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_get'
    failure=.FALSE.

    IF (.NOT.ASSOCIATED(sll)) THEN
       CPPrecondition(.NOT.PRESENT(first_el),cp_failure_level,routineP,error,failure)
       IF (PRESENT(rest)) NULLIFY(rest)
       IF (PRESENT(empty)) empty=.TRUE.
       IF (PRESENT(length)) length=0
    ELSE
       IF (PRESENT(first_el)) first_el [=] sll%first_el
       IF (PRESENT(rest)) rest => sll%rest
       IF (PRESENT(empty)) empty = .FALSE.
       IF (PRESENT(length)) &
            length = cp_sll_[nametype1]_get_length(sll,error=error)
    END IF
  END SUBROUTINE cp_sll_[nametype1]_get
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_first_el [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_get_first_el
!!
!!   FUNCTION
!!     returns the first element stored in the list
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     sll: the single linked list to get the element from
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  FUNCTION cp_sll_[nametype1]_get_first_el(sll,error) RESULT(res)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
    [type1] :: res

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_get_first'
    failure=.FALSE.

    IF (cp_debug) THEN
       CPPrecondition(ASSOCIATED(sll),cp_failure_level,routineP,error,failure)
    END IF
    IF (.NOT. failure) THEN
       res [=] sll%first_el
    END IF
  END FUNCTION cp_sll_[nametype1]_get_first_el
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_rest [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_get_rest
!!
!!   FUNCTION
!!     returns the rest of the list
!!
!!   NOTES
!!     split the case iter=1 to make it more optimized?
!!
!!   INPUTS
!!     sll: the single linked list to get the rest from
!!     iter: how many times the call to rest should be iterated,
!!           defaults to 1; -1 means till end of the list.
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  FUNCTION cp_sll_[nametype1]_get_rest(sll, iter, error) RESULT(res)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    INTEGER, OPTIONAL :: iter
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
    TYPE(cp_sll_[nametype1]_type), POINTER :: res

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_get_first'
    INTEGER :: i
    failure=.FALSE.

    IF (.NOT.ASSOCIATED(sll)) THEN
       NULLIFY(res)
    ELSE
       IF (.NOT. failure) THEN
          IF (PRESENT(iter)) THEN
             res => sll
             DO i=1,iter
                IF (ASSOCIATED(res%rest)) THEN
                   res => res%rest
                ELSE
                   CALL cp_assert(.FALSE.,cp_warning_level,cp_assertion_failed,&
                        routineP, "tried to go past end in "// &
CPSourceFileRef,&
                        error,failure)
                END IF
             END DO
             IF (iter==-1) THEN
                DO
                   IF (.NOT.ASSOCIATED(res%rest)) EXIT
                   res => res%rest
                END DO
             END IF
          ELSE
             res => sll%rest ! make the common case fast...
          END IF
       ELSE
          NULLIFY(res)
       END IF
    END IF
  END FUNCTION cp_sll_[nametype1]_get_rest
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_empty [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_get_empty
!!
!!   FUNCTION
!!     -
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     sll: the single linked list to get the rest from
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  FUNCTION cp_sll_[nametype1]_get_empty(sll,error) RESULT(res)
    LOGICAL :: res
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_get_empty'
    failure=.FALSE.

    res = .NOT.ASSOCIATED(sll)
  END FUNCTION cp_sll_[nametype1]_get_empty
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_length [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_get_length
!!
!!   FUNCTION
!!     returns the length of the list
!!
!!   NOTES
!!     slow (O(n))
!!
!!   INPUTS
!!     sll: the list you want to know the length of
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  FUNCTION cp_sll_[nametype1]_get_length(sll,error) RESULT(res)
    TYPE(cp_sll_[nametype1]_type), pointer :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
    INTEGER ::res

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_length'
    TYPE(cp_sll_[nametype1]_type), POINTER :: iterator
    failure=.FALSE.

    res=0
    iterator => sll
    DO
       IF (ASSOCIATED(iterator)) THEN
          res=res+1
          iterator => iterator%rest
       ELSE
          EXIT
       END IF
    END DO
  END FUNCTION cp_sll_[nametype1]_get_length
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_el_at [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_get_el_at
!!
!!   FUNCTION
!!     returns the element at the given index
!!
!!   NOTES
!!     slow (O(index))
!!
!!   INPUTS
!!     sll: the list you get the element from
!!     index: the position of the element (stating at 1)
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  FUNCTION cp_sll_[nametype1]_get_el_at(sll,index,error) RESULT(res)
    [type1] :: res
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    INTEGER, INTENT(in) :: index
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_get_el_at'
    TYPE(cp_sll_[nametype1]_type), POINTER :: pos
    failure=.FALSE.

    IF (cp_debug) THEN
       CPPrecondition(index>0.OR.index==-1,cp_failure_level,routineP,error,failure)
    END IF
    IF (index==-1) THEN
       pos => cp_sll_[nametype1]_get_rest(sll, iter=-1,error=error)
    ELSE
       pos => cp_sll_[nametype1]_get_rest(sll, iter=index-1,error=error)
    END IF
    CPPrecondition(ASSOCIATED(pos),cp_failure_level,routineP,error,failure)
    IF (.NOT.failure) THEN
       res [=] pos%first_el
    END IF
  END FUNCTION cp_sll_[nametype1]_get_el_at
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_set_el_at [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_set_el_at
!!
!!   FUNCTION
!!     sets the element at the given index
!!
!!   NOTES
!!     slow (O(index))
!!
!!   INPUTS
!!     sll: the list you get the element from
!!     index: the position of the element (stating at 1)
!!            -1 means at the end
!!     value: the new element
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_set_el_at(sll,index,value,error)
    [type1in] :: value
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    INTEGER, INTENT(in) :: index
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_set_el_at'
    TYPE(cp_sll_[nametype1]_type), POINTER :: pos
    failure=.FALSE.

    IF (index==-1) THEN
       pos => cp_sll_[nametype1]_get_rest(sll, iter=-1,error=error)
    ELSE
       pos => cp_sll_[nametype1]_get_rest(sll, iter=index-1,error=error)
    END IF
    CPPrecondition(ASSOCIATED(pos),cp_failure_level,routineP,error,failure)
    IF (.NOT.failure) THEN
       pos%first_el [=] value
    END IF
  END SUBROUTINE cp_sll_[nametype1]_set_el_at
!***************************************************************************

! * iteration *

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_next [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_next
!!
!!   FUNCTION
!!     returns true if the actual element is valid (i.e. iterator ont at end)
!!     moves the iterator to the next element
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     iterator: iterator that moves along the list
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!     el_att: the actual element (valid only if the function returns true)
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  FUNCTION cp_sll_[nametype1]_next(iterator,el_att,error) RESULT(res)
    TYPE(cp_sll_[nametype1]_type), POINTER :: iterator
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
    [type1out], OPTIONAL :: el_att
    LOGICAL :: res

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_next'
    failure=.FALSE.

    IF (ASSOCIATED(iterator)) THEN
       res=.NOT.failure
       if (present(el_att)) el_att [=] iterator%first_el
       iterator => iterator%rest
    ELSE
       res=.FALSE.
    END IF
  END FUNCTION cp_sll_[nametype1]_next
!***************************************************************************

! ============ structure modifications ============

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_insert_el [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_insert_el
!!
!!   FUNCTION
!!     insert an element at the beginning of the list
!!
!!   NOTES
!!     fast (O(1))
!!
!!   INPUTS
!!     sll: the single linked list point at the beginning of which 
!!          you want to add the element
!!     el: the element to add
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_insert_el(sll,el,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    [type1in]:: el
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]:cp_sll_[nametype1]_add_el'
    TYPE(cp_sll_[nametype1]_type), POINTER :: newSlot

    failure=.FALSE.
    NULLIFY(newSlot)

    CALL cp_sll_[nametype1]_create(newSlot,first_el=el,&
         rest=sll,error=error)
    sll => newSlot
  END SUBROUTINE cp_sll_[nametype1]_insert_el
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_rm_first_el [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_rm_first_el
!!
!!   FUNCTION
!!     remove the first element of the linked list
!!
!!   NOTES
!!     fast (O(1))
!!
!!   INPUTS
!!     sll: the list whose first element has to be removed
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_rm_first_el(sll,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_rm_first_el'
    TYPE(cp_sll_[nametype1]_type), POINTER :: node_to_rm
    failure=.FALSE.
    node_to_rm => sll

    IF (ASSOCIATED(sll)) THEN
       sll => sll%rest
       CALL cp_sll_[nametype1]_dealloc_node(node_to_rm,error=error)
    ELSE
       CALL cp_assert(.FALSE.,cp_warning_level,cp_assertion_failed,&
            routineP,"tried to remove first el of an empty list in "//&
CPSourceFileRef,&
            error,failure)
    END IF
  END SUBROUTINE cp_sll_[nametype1]_rm_first_el
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_insert_el_at [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_insert_el_at
!!
!!   FUNCTION
!!     inserts the element at the given index
!!
!!   NOTES
!!     slow (O(index))
!!
!!   INPUTS
!!     sll: the list you get the element from
!!     index: the position of the element (stating at 1). 
!!            If it is -1, it means at end
!!     el: the new element
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_insert_el_at(sll,el,index,error)
    [type1in] :: el
    INTEGER, INTENT(in) :: index
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_insert_el_at'
    TYPE(cp_sll_[nametype1]_type), POINTER :: pos
    failure=.FALSE.

    IF (index==1) THEN
       CALL cp_sll_[nametype1]_insert_el(sll,el,error=error)
    ELSE
       IF (index==-1) THEN
          pos => cp_sll_[nametype1]_get_rest(sll, iter=-1,error=error)
       ELSE
          pos => cp_sll_[nametype1]_get_rest(sll, iter=index-2,error=error)
       END IF
       CPPrecondition(ASSOCIATED(pos),cp_failure_level,routineP,error,failure)
       IF (.NOT.failure) THEN
          CALL cp_sll_[nametype1]_insert_el(pos%rest,el,error=error)
       END IF
    END IF
  END SUBROUTINE cp_sll_[nametype1]_insert_el_at
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_rm_el_at [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_rm_el_at
!!
!!   FUNCTION
!!     removes the element at the given index
!!
!!   NOTES
!!     slow (O(index))
!!
!!   INPUTS
!!     sll: the list you get the element from
!!     index: the position of the element (stating at 1)
!!     el: the new element
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_rm_el_at(sll,index,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
    INTEGER, INTENT(in)::index

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_remove_el_at'
    TYPE(cp_sll_[nametype1]_type), POINTER :: pos
    failure=.FALSE.
    
    IF (cp_debug) THEN
       CPPrecondition(index>0.OR.index==-1,cp_failure_level,routineP,error,failure)
    END IF
    IF (index==1) THEN
       CALL cp_sll_[nametype1]_rm_first_el(sll,error=error)
    ELSE
       IF (index==-1) THEN
          pos => cp_sll_[nametype1]_get_rest(sll, iter=-1,error=error)
       ELSE
          pos => cp_sll_[nametype1]_get_rest(sll, iter=index-2,error=error)
       END IF
       CPPrecondition(ASSOCIATED(pos),cp_failure_level,routineP,error,failure)
       IF (.NOT.failure) THEN
          CALL cp_sll_[nametype1]_rm_first_el(pos%rest,error=error)
       END IF
    END IF
  END SUBROUTINE cp_sll_[nametype1]_rm_el_at
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_rm_all_el [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_rm_all_el
!!
!!   FUNCTION
!!     removes all the elements from the list
!!
!!   NOTES
!!     check more?
!!
!!   INPUTS
!!     sll: the list that should be removed
!!     error: variable to control error logging, stopping,... 
!!            see module cp_error_handling 
!!
!!   AUTHOR
!!     @author Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!*** **********************************************************************
  SUBROUTINE cp_sll_[nametype1]_rm_all_el(sll,error)
    TYPE(cp_sll_[nametype1]_type), POINTER :: sll
    TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error

    LOGICAL :: failure
    CHARACTER(len=*), PARAMETER :: routineP='cp_linked_list_[nametype1]/cp_sll_[nametype1]_rm_all_el'
    TYPE(cp_sll_[nametype1]_type), POINTER :: next_node, actual_node
    failure=.FALSE.

    actual_node => sll
    DO
       IF (.NOT.ASSOCIATED(actual_node)) EXIT
       next_node => actual_node%rest
       CALL cp_sll_[nametype1]_dealloc_node(actual_node,error=error)
       actual_node => next_node
    END DO
    NULLIFY(sll)
  END SUBROUTINE cp_sll_[nametype1]_rm_all_el
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_to_array [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_to_array
!!
!!   FUNCTION
!!     returns a newly allocated array with the same contents as
!!     the linked list
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - sll: the list to trasform in array
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
FUNCTION cp_sll_[nametype1]_to_array(sll,error) RESULT(res)
  TYPE(cp_sll_[nametype1]_type), POINTER :: sll
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  [type1arrayEl], DIMENSION(:), POINTER :: res
  
  LOGICAL :: failure
  CHARACTER(len=*), PARAMETER :: routineN='cp_sll_[nametype1]_to_array',&
        routineP=moduleN//':'//routineN
  INTEGER :: len,stat,i
  TYPE(cp_sll_[nametype1]_type), POINTER :: iter
  failure=.FALSE.
  
  len=cp_sll_[nametype1]_get_length(sll,error)
  ALLOCATE(res(len),stat=stat)
  CPPostcondition(stat==0,cp_failure_level,routineP,error,failure)
  IF (.NOT. failure) THEN
     iter => sll
     DO i=1,len
        res(i)[arrayEl] [array=] iter%first_el
        IF (.NOT.(cp_sll_[nametype1]_next(iter,error=error).OR.i==len)) THEN
           CPAssert(.FALSE.,cp_failure_level,routineP,error,failure)
        END IF
     END DO
  END IF
END FUNCTION cp_sll_[nametype1]_to_array
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_from_array [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_from_array
!!
!!   FUNCTION
!!     returns a linked list with the same contents as the given array
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - array: the array you want to copy
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
FUNCTION cp_sll_[nametype1]_from_array(array,error) RESULT(res)
  [type1arrayEl], DIMENSION(:), INTENT(in) :: array
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  TYPE(cp_sll_[nametype1]_type), POINTER :: res
  
  LOGICAL :: failure
  CHARACTER(len=*), PARAMETER :: routineN='cp_sll_[nametype1]_from_array',&
        routineP=moduleN//':'//routineN
  INTEGER :: i
  TYPE(cp_sll_[nametype1]_type), POINTER :: last_el
  failure=.FALSE.
  
  NULLIFY(res,last_el)
  IF (SIZE(array)>0) THEN
     CALL cp_sll_[nametype1]_create(res,&
          first_el=array(1)[arrayEl],&
          error=error)
     last_el => res
  END IF
  DO i=2,SIZE(array)
     CALL cp_sll_[nametype1]_create(last_el%rest,&
          first_el=array(i)[arrayEl],&
          error=error)
     last_el => last_el%rest
  END DO
END FUNCTION cp_sll_[nametype1]_from_array
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_insert_ordered [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_insert_ordered
!!
!!   FUNCTION
!!     insert an element mantaining the order
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - sll: the list you want to insert in
!!     - el: the element that you want to insert
!!     - insert_equals: if equal elements should be inserted
!!       (defaults to false)
!!     - did_insert: true if it did insert the element
!!     - pos: node where the element has been inserted (or of the same
!!       element that was already in the list)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE cp_sll_[nametype1]_insert_ordered(sll,el,insert_equals,&
     did_insert,pos,error)
  TYPE(cp_sll_[nametype1]_type), POINTER :: sll
  [type1in] :: el
  LOGICAL, OPTIONAL, INTENT(in) :: insert_equals
  LOGICAL, OPTIONAL, INTENT(out) :: did_insert
  TYPE(cp_sll_[nametype1]_type), POINTER, OPTIONAL :: pos
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure,i_eq
  CHARACTER(len=*), PARAMETER :: routineN='cp_sll_[nametype1]_insert_ordered',&
        routineP=moduleN//':'//routineN
  TYPE(cp_sll_[nametype1]_type), POINTER :: iter
  failure=.FALSE.
  i_eq=.FALSE.
  
  IF (PRESENT(did_insert)) did_insert=.FALSE.
  IF (PRESENT(pos)) NULLIFY(pos)

  IF (PRESENT(insert_equals)) i_eq=insert_equals
  IF (.NOT.ASSOCIATED(sll)) THEN
     CALL cp_sll_[nametype1]_create(sll,first_el=el,error=error)
     IF (PRESENT(did_insert)) did_insert=.TRUE.
     IF (PRESENT(pos)) pos=>sll
  ELSE IF (.NOT.[lessQ](sll%first_el,el)) THEN
     IF (PRESENT(pos)) pos=>sll
     IF (i_eq.OR.[lessQ](el,sll%first_el)) THEN
        CALL cp_sll_[nametype1]_insert_el(sll,el,error=error)
        IF (PRESENT(did_insert)) did_insert=.TRUE.
        IF (PRESENT(pos)) pos=>sll
     END IF
  ELSE
     iter => sll
     DO
        IF (.NOT.ASSOCIATED(iter%rest)) THEN
           CALL cp_sll_[nametype1]_insert_el(iter%rest,el,error=error)
           IF (PRESENT(did_insert)) did_insert=.TRUE.
           IF (PRESENT(pos)) pos=>iter%rest
           EXIT
        ELSE IF (.NOT.[lessQ](iter%rest%first_el,el)) THEN
           IF (PRESENT(pos)) pos=>iter
           IF (i_eq.OR. [lessQ](el,iter%rest%first_el)) THEN
              CALL cp_sll_[nametype1]_insert_el(iter%rest,el,error=error)
              IF (PRESENT(did_insert)) did_insert=.TRUE.
              IF (PRESENT(pos)) pos=>iter%rest
           END IF
           EXIT
        END IF
        CPInvariant(cp_sll_[nametype1]_next(iter),cp_failure_level,routineP,error,failure)
     END DO
     CPAssert(ASSOCIATED(iter),cp_failure_level,routineP,error,failure)
  END IF
END SUBROUTINE cp_sll_[nametype1]_insert_ordered
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_insert_ordered2 [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_insert_ordered2
!!
!!   FUNCTION
!!     insert an element mantaining the order defined by a user given function
!!
!!   NOTES
!!     -
!!
!!   INPUTS
!!     - sll: the list you want to insert in
!!     - el: the element that you want to insert
!!     - compare_function: a function used to compare two elements,
!!       it should return a negative number if the first argument is less
!!       than the second, 0 if they are equal, otherwise a positive number
!!     - insert_equals: if equal elements should be inserted
!!       (defaults to false)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
SUBROUTINE cp_sll_[nametype1]_insert_ordered2(sll,el,compare_function,&
     insert_equals,did_insert,pos,error)
  TYPE(cp_sll_[nametype1]_type), POINTER :: sll
  [type1in] :: el
  INTERFACE
     FUNCTION compare_function(el1,el2)
       [USE]
       INTEGER :: compare_function
       [type1in] :: el1,el2
     END FUNCTION compare_function
  END INTERFACE
  LOGICAL, OPTIONAL, INTENT(in) :: insert_equals
  LOGICAL, OPTIONAL, INTENT(out) :: did_insert
  TYPE(cp_sll_[nametype1]_type), POINTER, OPTIONAL :: pos
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure,i_eq
  CHARACTER(len=*), PARAMETER :: routineN='cp_sll_[nametype1]_insert_ordered2',&
        routineP=moduleN//':'//routineN
  INTEGER :: comp
  TYPE(cp_sll_[nametype1]_type), POINTER :: iter
  failure=.FALSE.
  i_eq=.FALSE.
  
  IF (PRESENT(did_insert)) did_insert=.FALSE.
  IF (PRESENT(pos)) NULLIFY(pos)

  IF (PRESENT(insert_equals)) i_eq=insert_equals
  IF (.NOT.ASSOCIATED(sll)) THEN
     CALL cp_sll_[nametype1]_create(sll,first_el=el,error=error)
     IF (PRESENT(did_insert)) did_insert=.TRUE.
     IF (PRESENT(pos)) pos=>iter%rest
     RETURN
  END IF
  comp=compare_function(sll%first_el,el)
  IF (comp>=0) THEN
     IF (i_eq.OR.comp/=0) THEN
        CALL cp_sll_[nametype1]_insert_el(sll,el,error=error)
        IF (PRESENT(did_insert)) did_insert=.TRUE.
        IF (PRESENT(pos)) pos=>iter%rest
     END IF
  ELSE
     iter => sll
     DO
        IF (.NOT.ASSOCIATED(iter%rest)) THEN
           CALL cp_sll_[nametype1]_insert_el(iter%rest,el,error=error)
           IF (PRESENT(did_insert)) did_insert=.TRUE.
           IF (PRESENT(pos)) pos=>iter%rest
           EXIT
        END IF
        comp=compare_function(iter%rest%first_el,el)
        IF (comp>=0) THEN
           IF (i_eq.OR. comp/=0) THEN
              CALL cp_sll_[nametype1]_insert_el(iter%rest,el,error=error)
              IF (PRESENT(did_insert)) did_insert=.TRUE.
              IF (PRESENT(pos)) pos=>iter%rest
           END IF
           EXIT
        END IF
        CPInvariant(cp_sll_[nametype1]_next(iter),cp_failure_level,routineP,error,failure)
     END DO
     CPAssert(ASSOCIATED(iter),cp_failure_level,routineP,error,failure)
  END IF
END SUBROUTINE cp_sll_[nametype1]_insert_ordered2
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_contains [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_contains
!!
!!   FUNCTION
!!     returns true if the list contains the given element
!!
!!   NOTES
!!     marginally faster if ordered (n/2 instread of n)
!!
!!   INPUTS
!!     - sll: the linked list you want to control
!!     - el: the element to control
!!     - ordered: if true assumes that the list is ordered in growing order.
!!       (defaults to false)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
FUNCTION cp_sll_[nametype1]_contains(sll,el,ordered,error) RESULT(res)
  LOGICAL ::res
  TYPE(cp_sll_[nametype1]_type), POINTER :: sll
  [type1in] :: el
  LOGICAL, INTENT(in), OPTIONAL :: ordered
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure,ord
  CHARACTER(len=*), PARAMETER :: routineN='cp_sll_[nametype1]_contains',&
        routineP=moduleN//':'//routineN
  TYPE(cp_sll_[nametype1]_type), POINTER :: iter
  [type1] :: el_att
  failure=.FALSE.; ord=.FALSE.
  res=.FALSE.
  
  iter => sll
  IF (PRESENT(ordered)) ord=ordered
  IF (ord) THEN
     DO
        IF (.NOT.cp_sll_[nametype1]_next(iter,el_att=el_att,error=error)) EXIT
        IF (.NOT.[lessQ](el_att,el)) THEN
           res=.NOT.[lessQ](el,el_att)
           RETURN
        END IF
     END DO
  ELSE
     DO
        IF (.NOT.cp_sll_[nametype1]_next(iter,el_att=el_att,error=error)) EXIT
        IF (.NOT.[equalQ](el_att,el)) THEN
           res=.TRUE.
           RETURN
        END IF
     END DO
  END IF
END FUNCTION cp_sll_[nametype1]_contains
!***************************************************************************

!!****f* cp_linked_list_[nametype1]/cp_sll_[nametype1]_contains [1.0] *
!!
!!   NAME
!!     cp_sll_[nametype1]_contains
!!
!!   FUNCTION
!!     returns true if the list contains the given element
!!
!!   NOTES
!!     marginally faster if ordered (n/2 instread of n)
!!
!!   INPUTS
!!     - sll: the linked list you want to control
!!     - el: the element to control
!!     - compare_function: a function used to compare two elements,
!!       it should return a negative number if the first argument is less
!!       than the second, 0 if they are equal, otherwise a positive number
!!     - ordered: if true assumes that the list is ordered in growing order.
!!       (defaults to false)
!!     - error: variable to control error logging, stopping,... 
!!       see module cp_error_handling 
!!
!!   AUTHOR
!!     Fawzi Mohamed
!!
!!   MODIFICATION HISTORY
!!     07.2002 created [fawzi]
!!
!!*** **********************************************************************
FUNCTION cp_sll_[nametype1]_contains2(sll,el,compare_function,ordered,error)&
     RESULT(res)
  LOGICAL ::res
  TYPE(cp_sll_[nametype1]_type), POINTER :: sll
  [type1in] :: el
  INTERFACE
     FUNCTION compare_function(el1,el2)
       [USE]
       INTEGER :: compare_function
       [type1in] :: el1,el2
     END FUNCTION compare_function
  END INTERFACE
  LOGICAL, INTENT(in), OPTIONAL :: ordered
  TYPE(cp_error_type), OPTIONAL, INTENT(inout) :: error
  
  LOGICAL :: failure
  INTEGER :: comp
  CHARACTER(len=*), PARAMETER :: routineN='cp_sll_[nametype1]_contains2',&
        routineP=moduleN//':'//routineN
  TYPE(cp_sll_[nametype1]_type), POINTER :: iter
  [type1] :: el_att
  failure=.FALSE.
  res=.FALSE.
  
  iter => sll
  IF (ordered) THEN
     DO
        IF (.NOT.cp_sll_[nametype1]_next(iter,el_att=el_att,error=error)) EXIT
        comp=compare_function(el_att,el)
        IF (comp>=0) THEN
           res= comp==0
           RETURN
        END IF
     END DO
  ELSE
     DO
        IF (.NOT.cp_sll_[nametype1]_next(iter,el_att=el_att,error=error)) EXIT
        IF (compare_function(el_att,el)==0) THEN
           res=.TRUE.
           RETURN
        END IF
     END DO
  END IF
END FUNCTION cp_sll_[nametype1]_contains2
!***************************************************************************

! template def put here so that line numbers in template and derived 
! files are almost the same (multi-line use change it a bit)
! [template(defines,nametype1,type1,type1in,type1out,type1arrayEl,arrayEl,array=,=,USE,write_el,lessQ,equalQ,private_routines)]

END MODULE cp_linked_list_[nametype1]

