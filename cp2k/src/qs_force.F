!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations
!   Copyright (C) 2001 - 2003  CP2K developers group
!-----------------------------------------------------------------------------!
!!****** cp2k/qs_force [1.0] *
!!
!!   NAME
!!     qs_force
!!
!!   FUNCTION
!!     Quickstep force driver routine
!!
!!   AUTHOR
!!     MK (12.06.2002)
!!
!!   MODIFICATION HISTORY
!!
!!   SOURCE
!******************************************************************************

MODULE qs_force

  USE atomic_kind_types,               ONLY: atomic_kind_type,&
                                             get_atomic_kind_set
  USE cp_control_types,                ONLY: dft_control_type
  USE cp_fm_types,                     ONLY: cp_fm_p_type
  USE cp_output_handling,              ONLY: cp_p_file,&
                                             cp_print_key_finished_output,&
                                             cp_print_key_should_output,&
                                             cp_print_key_unit_nr
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE global_types,                    ONLY: MEDIUM,&
                                             global_environment_type
  USE harris_env_types,                ONLY: harris_env_set,&
                                             harris_env_type
  USE harris_force,                    ONLY: harris_force_correction
  USE harris_force_types,              ONLY: harris_force_create,&
                                             harris_force_type
  USE kinds,                           ONLY: dp,&
                                             int_size
  USE message_passing,                 ONLY: mp_sum
  USE mulliken,                        ONLY: mulliken_restraint
  USE particle_types,                  ONLY: particle_type
  USE qs_core_energies,                ONLY: calculate_ecore_overlap,&
                                             calculate_ecore_self
  USE qs_core_hamiltonian,             ONLY: build_core_hamiltonian_matrix
  USE qs_energy,                       ONLY: qs_energies
  USE qs_energy_types,                 ONLY: qs_energy_type
  USE qs_environment_types,            ONLY: get_qs_env,&
                                             qs_environment_type,&
                                             set_qs_env
  USE qs_force_types,                  ONLY: allocate_qs_force,&
                                             qs_force_type,&
                                             zero_qs_force
  USE qs_ks_methods,                   ONLY: calculate_w_matrix,&
                                             qs_ks_update_qs_env
  USE qs_ks_types,                     ONLY: qs_ks_env_type
  USE qs_mo_types,                     ONLY: mo_set_p_type,&
                                             mo_set_type
  USE qs_rho_types,                    ONLY: qs_rho_type
  USE qs_semi_empirical_hamiltonian,   ONLY: build_se_core_matrix
  USE scf_control_types,               ONLY: scf_control_type
  USE sparse_matrix_output,            ONLY: write_sparse_matrix
  USE sparse_matrix_types,             ONLY: allocate_matrix_set,&
                                             deallocate_matrix_set,&
                                             real_matrix_p_type,&
                                             replicate_matrix_structure,&
                                             set_matrix
  USE termination,                     ONLY: stop_memory,&
                                             stop_program
  USE timings,                         ONLY: timeset,&
                                             timestop
  USE virial_types,                    ONLY: virial_get,&
                                             virial_type
#include "cp_common_uses.h"

  IMPLICIT NONE

  PRIVATE

! *** Global parameters ***

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'qs_force'

! *** Public subroutines ***

  PUBLIC :: qs_forces, write_forces

!!***
! *****************************************************************************

CONTAINS

! *****************************************************************************

  SUBROUTINE qs_forces(qs_env,globenv,error)

!   Purpose: Calculate the Quickstep forces.

!   History: - Creation (29.10.2002,MK)

!   ***************************************************************************

    TYPE(qs_environment_type), POINTER       :: qs_env
    TYPE(global_environment_type), POINTER   :: globenv
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'qs_forces', &
      routine = "SUBROUTINE "//routineN//" (MODULE "//moduleN//")"

    INTEGER                                  :: dir, handle, i, iatom, ikind, &
                                                ispin, istat, iw, natom, &
                                                nkind, nspin, output_unit
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: atom_of_kind, kind_of, &
                                                natom_of_kind
    LOGICAL                                  :: failure, gapw, harris_flag, &
                                                obasis
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(cp_fm_p_type), DIMENSION(:), &
      POINTER                                :: mo_derivs
    TYPE(cp_logger_type), POINTER            :: logger
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(dft_control_type), POINTER          :: dft_control
    TYPE(harris_env_type), POINTER           :: harris_env
    TYPE(harris_force_type), POINTER         :: harris_force
    TYPE(mo_set_p_type), DIMENSION(:), &
      POINTER                                :: mos
    TYPE(mo_set_type), POINTER               :: mo_set
    TYPE(particle_type), DIMENSION(:), &
      POINTER                                :: particle_set
    TYPE(qs_energy_type), POINTER            :: energy
    TYPE(qs_force_type), DIMENSION(:), &
      POINTER                                :: force
    TYPE(qs_ks_env_type), POINTER            :: ks_env
    TYPE(qs_rho_type), POINTER               :: rho
    TYPE(real_matrix_p_type), DIMENSION(:), &
      POINTER                                :: matrix_ks, matrix_s, matrix_w
    TYPE(scf_control_type), POINTER          :: scf_control
    TYPE(virial_type), POINTER               :: virial

! -------------------------------------------------------------------------

    CALL timeset(routineN,"I","",handle)
    failure = .FALSE.
    NULLIFY (logger)
    logger => cp_error_get_logger(error)
    para_env=>qs_env%para_env

    NULLIFY (atomic_kind_set)
    NULLIFY (dft_control)
    NULLIFY (force)
    NULLIFY (harris_env)
    NULLIFY (ks_env)
    NULLIFY (mos)
    NULLIFY (matrix_ks)
    NULLIFY (matrix_s)
    NULLIFY (matrix_w)
    NULLIFY (particle_set)
    NULLIFY (rho)
    NULLIFY (scf_control)

    harris_flag = qs_env%use_harris
    CALL get_qs_env(qs_env=qs_env,&
                    atomic_kind_set=atomic_kind_set,&
                    dft_control=dft_control,&
                    force=force,harris_env=harris_env,&
                    particle_set=particle_set,&
                    scf_control=scf_control,&
                    virial=virial,&
                    energy=energy)


    natom = SIZE(particle_set)

    ! zero out the forces
    DO iatom=1,natom
       particle_set(iatom)%f=0.0_dp
    END DO

    gapw = (dft_control%qs_control%method=="GAPW")
    IF(dft_control%qs_control%semi_empirical .AND. &
       dft_control%qs_control%se_control%orthogonal_basis) THEN
       obasis = .TRUE.
    ELSE
       obasis = .FALSE.
    END IF

    ALLOCATE (atom_of_kind(natom),STAT=istat)
    IF (istat /= 0) CALL stop_memory(routine,"atom_of_kind",natom*int_size)

    ALLOCATE (kind_of(natom),STAT=istat)
    IF (istat /= 0) CALL stop_memory(routine,"kind_of",natom*int_size)

    CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set,&
                             atom_of_kind=atom_of_kind,&
                             kind_of=kind_of)

    IF (.NOT.ASSOCIATED(force)) THEN
!   *** Allocate the force data structure ***
       dft_control%forces=.TRUE.
       nkind = SIZE(atomic_kind_set)
       ALLOCATE (natom_of_kind(nkind),STAT=istat)
       CPPostcondition(istat==0,cp_failure_level,routine,error,failure)
       CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set,&
            natom_of_kind=natom_of_kind)
      CALL allocate_qs_force(force,natom_of_kind)
      DEALLOCATE (natom_of_kind,STAT=istat)
      CPPostconditionNoFail(istat==0,cp_warning_level,routine,error)
      CALL set_qs_env(qs_env,force=force,error=error)
      IF (harris_flag) THEN
         NULLIFY(harris_force)
        CALL harris_force_create(harris_force=harris_force,natom=natom,error=error)
        CALL harris_env_set(harris_env=harris_env, &
             harris_force=harris_force, error=error)
      END IF
    END IF
    CALL zero_qs_force(force)

    CALL qs_energies(qs_env,globenv,error=error)

    CALL get_qs_env(qs_env=qs_env,&
                    ks_env=ks_env,&
                    matrix_ks=matrix_ks,&
                    matrix_s=matrix_s,&
                    mo_derivs=mo_derivs,&
                    mos=mos,&
                    rho=rho)

    IF (.NOT.obasis) THEN

      ! Build W matrix (from the orthonormality constraint lambda C^T S C)

      nspin = SIZE(mos)

      CALL allocate_matrix_set(matrix_w,nspin)

      DO ispin=1,nspin

        CALL replicate_matrix_structure(matrix_s(1)%matrix,&
                                        matrix_w(ispin)%matrix,&
                                        "W MATRIX")

        mo_set => mos(ispin)%mo_set

        IF (qs_env%dft_control%roks) THEN
          IF (scf_control%use_ot) THEN
            IF (ispin > 1) THEN
              ! not very elegant, indeed ...
              CALL set_matrix(matrix_w(ispin)%matrix,0.0_dp)
            ELSE
              CALL calculate_w_matrix(mo_set,mo_derivs(ispin)%matrix,&
                                      matrix_w(ispin)%matrix,matrix_s(1)%matrix)
            END IF
          ELSE
            CALL calculate_w_matrix(mo_set=mo_set,&
                                    matrix_ks=matrix_ks(ispin)%matrix,&
                                    matrix_p=rho%rho_ao(ispin)%matrix,&
                                    matrix_w=matrix_w(ispin)%matrix,&
                                    error=error)
          END IF
        ELSE
          IF (scf_control%use_ot) THEN
            CALL calculate_w_matrix(mo_set,mo_derivs(ispin)%matrix,&
                                    matrix_w(ispin)%matrix,matrix_s(1)%matrix)
          ELSE
            CALL calculate_w_matrix(mo_set,matrix_w(ispin)%matrix)
          END IF
        END IF

        IF (BTEST(cp_print_key_should_output(logger%iter_info,&
             qs_env%input,"DFT%PRINT%AO_MATRICES/W_MATRIX",error=error),cp_p_file)) THEN
           iw = cp_print_key_unit_nr(logger,qs_env%input,"DFT%PRINT%AO_MATRICES/W_MATRIX",&
                extension=".Log",error=error)
           CALL write_sparse_matrix(matrix_w(ispin)%matrix,4,6,qs_env,para_env,output_unit=iw)
           CALL cp_print_key_finished_output(iw,logger,qs_env%input,&
                "DFT%PRINT%AO_MATRICES/W_MATRIX", error=error)
        END IF

      END DO

    END IF

!   *** from an eventual mulliken restraint
    IF (dft_control%qs_control%mulliken_restraint) THEN
        CALL mulliken_restraint(dft_control%qs_control%mulliken_restraint_control, &
                                para_env,matrix_s(1)%matrix, rho%rho_ao,w_matrix=matrix_w)
    ENDIF
    CALL set_qs_env(qs_env=qs_env,matrix_w=matrix_w)


    IF (.NOT. harris_flag) THEN ! harris computes the forces differenctly
      !*** compute core forces (also overwrites matrix_w) ***
      IF (dft_control%qs_control%semi_empirical) THEN
        CALL build_se_core_matrix(qs_env=qs_env,para_env=para_env,&
                                  calculate_forces=.TRUE.,error=error)
      ELSE
        CALL build_core_hamiltonian_matrix(qs_env=qs_env,&
                                           globenv=globenv,&
                                           calculate_forces=.TRUE.,error=error)
        CALL calculate_ecore_self(qs_env)
        CALL calculate_ecore_overlap(qs_env, para_env, &
                                             calculate_forces=.TRUE.,&
                                             error=error)
      END IF


      ! *** compute grid-based forces ***
      CALL qs_ks_update_qs_env(ks_env=ks_env,&
                               qs_env=qs_env,&
                               calculate_forces=.TRUE.)


      !  *** replicate forces ***
      DO ikind=1,SIZE(force)
        CALL mp_sum(force(ikind)%overlap,para_env%group)
        CALL mp_sum(force(ikind)%kinetic,para_env%group)
        CALL mp_sum(force(ikind)%gth_ppl,para_env%group)
        CALL mp_sum(force(ikind)%gth_ppnl,para_env%group)
        CALL mp_sum(force(ikind)%all_potential,para_env%group)
        CALL mp_sum(force(ikind)%core_overlap,para_env%group)
        CALL mp_sum(force(ikind)%rho_core,para_env%group)
        CALL mp_sum(force(ikind)%rho_elec,para_env%group)
        CALL mp_sum(force(ikind)%vhxc_atom,para_env%group)
        CALL mp_sum(force(ikind)%g0s_Vh_elec,para_env%group)
        CALL mp_sum(force(ikind)%hartree_2c,para_env%group)
        CALL mp_sum(force(ikind)%hartree_3c,para_env%group)
        force(ikind)%total(:,:) = force(ikind)%total(:,:) +&
                                  force(ikind)%core_overlap(:,:) +&
                                  force(ikind)%gth_ppl(:,:) +&
                                  force(ikind)%gth_ppnl(:,:) +&
                                  force(ikind)%all_potential(:,:) +&
                                  force(ikind)%kinetic(:,:) +&
                                  force(ikind)%overlap(:,:) +&
                                  force(ikind)%rho_core(:,:) +&
                                  force(ikind)%rho_elec(:,:) +&
                                  force(ikind)%vhxc_atom(:,:) +&
                                  force(ikind)%g0s_Vh_elec(:,:) +&
                                  force(ikind)%hartree_2c(:,:) +&
                                  force(ikind)%hartree_3c(:,:)
      END DO

      DO iatom=1,natom
        ikind = kind_of(iatom)
        i = atom_of_kind(iatom)
        ! XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        ! the force is - dE/dR, what is called force is actually the gradient
        ! Things should have the right name
        ! The minus sign below is a hack
        ! XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
        force(ikind)%other(1:3,i)=-particle_set(iatom)%f(1:3)+force(ikind)%ch_pulay(1:3,i)
        force(ikind)%total(1:3,i)=force(ikind)%total(1:3,i)+force(ikind)%other(1:3,i)
        particle_set(iatom)%f = -force(ikind)%total(1:3,i)
      END DO

      !   *** distribute virial ***
      IF (virial%pv_availability) THEN
        CALL mp_sum(virial%pv_virial,para_env%group)
      !  *** add the volume terms of the virial ***
        IF (.NOT.virial%pv_numer) THEN
          DO dir=1, 3
            virial%pv_virial(dir,dir) = virial%pv_virial(dir,dir) - energy%exc  &
                                                                  - 2.0_dp*energy%hartree
            ! The factor 2 is a hack. It compensates the plus sign in h_stress/pw_poisson_solve.
            ! The sign in pw_poisson_solve is correct for FIST, but not for QS. 
            ! There should be a more elegant solution to that...
          END DO
        END IF 
      END IF
      
      output_unit = cp_print_key_unit_nr(logger,qs_env%input,"DFT%PRINT%DERIVATIVES",&
           extension=".Log",error=error)
      IF(dft_control%qs_control%semi_empirical .AND. obasis) THEN
        CALL write_forces(force,atomic_kind_set,2,globenv,output_unit=output_unit)
      ELSEIF(gapw) THEN
        CALL write_forces(force,atomic_kind_set,1,globenv,output_unit=output_unit)
      ELSEIF (virial%pv_availability) THEN
        CALL write_forces(force,atomic_kind_set,0,globenv,virial,output_unit=output_unit)
      ELSE
        CALL write_forces(force,atomic_kind_set,0,globenv,output_unit=output_unit)
      END IF
      CALL cp_print_key_finished_output(output_unit,logger,qs_env%input,&
           "DFT%PRINT%DERIVATIVES",error=error)  
    ELSE
      CALL get_qs_env(qs_env=qs_env, harris_env=harris_env)
      CALL harris_force_correction(qs_env=qs_env, harris_env=harris_env, &
                                   globenv=globenv,error=error)
      DO iatom = 1,natom
        i = atom_of_kind(iatom)
        particle_set(iatom)%f = -harris_env%harris_force%f_harris(iatom, 1:3)
      END DO
    END IF

    CALL deallocate_matrix_set(matrix_w)
    CALL set_qs_env(qs_env=qs_env,matrix_w=matrix_w)

    DEALLOCATE (atom_of_kind,STAT=istat)
    IF (istat /= 0) CALL stop_memory(routine,"atom_of_kind")

    DEALLOCATE (kind_of,STAT=istat)
    IF (istat /= 0) CALL stop_memory(routine,"kind_of")

    CALL timestop(0.0_dp,handle)

  END SUBROUTINE qs_forces

! *****************************************************************************

  SUBROUTINE write_forces(qs_force,atomic_kind_set,ftype,globenv,virial,output_unit)

!   Purpose: Write a Quickstep force data structure to

!   History: - Creation (05.06.2002,MK)

!   ***************************************************************************

    TYPE(qs_force_type), DIMENSION(:), &
      POINTER                                :: qs_force
    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    INTEGER, INTENT(IN)                      :: ftype
    TYPE(global_environment_type), POINTER   :: globenv
    TYPE(virial_type), OPTIONAL, POINTER     :: virial
    INTEGER, INTENT(IN)                      :: output_unit

    CHARACTER(LEN=*), PARAMETER :: &
      routine = "SUBROUTINE write_forces (MODULE qs_force_types)"

    CHARACTER(LEN=13)                        :: fmtstr5
    CHARACTER(LEN=15)                        :: fmtstr4
    CHARACTER(LEN=20)                        :: fmtstr3
    CHARACTER(LEN=35)                        :: fmtstr2
    CHARACTER(LEN=48)                        :: fmtstr1
    INTEGER                                  :: i, iatom, ikind, istat, &
                                                my_ftype, natom, ndigits
    INTEGER, ALLOCATABLE, DIMENSION(:)       :: atom_of_kind, kind_of
    LOGICAL                                  :: virial_present
    REAL(KIND=dp), DIMENSION(3)              :: grand_total
    REAL(kind=dp), DIMENSION(3, 3)           :: pv_virial

!   ---------------------------------------------------------------------------

    IF (output_unit>0) THEN

       IF (.NOT.ASSOCIATED(qs_force)) THEN
          CALL stop_program(routine,"The qs_force pointer is not associated "//&
                                    "and cannot be printed")
       END IF

       CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set,&
            natom=natom)
       ALLOCATE (atom_of_kind(natom),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routine,"atom_of_kind",natom*int_size)
       ALLOCATE (kind_of(natom),STAT=istat)
       IF (istat /= 0) CALL stop_memory(routine,"kind_of",natom*int_size)
       CALL get_atomic_kind_set(atomic_kind_set=atomic_kind_set,&
            atom_of_kind=atom_of_kind,&
            kind_of=kind_of)
       
       IF (PRESENT(virial)) THEN
          CALL virial_get(virial, pv_virial=pv_virial,&
               pv_availability=virial_present)
       ELSE
          virial_present=.FALSE.
       END IF
       
       
       !   *** Variable precision output of the forces ***
       
       ndigits = 6 
       
       fmtstr1 = "(/,/,T2,A,/,/,T3,A,T11,A,T23,A,T40,A1,2(  X,A1))"
       WRITE (UNIT=fmtstr1(41:42),FMT="(I2)") ndigits + 5
       
       fmtstr2 = "(/,(T2,I5,4X,I4,T18,A,T34,3F  .  ))"
       WRITE (UNIT=fmtstr2(32:33),FMT="(I2)") ndigits
       WRITE (UNIT=fmtstr2(29:30),FMT="(I2)") ndigits + 6
       
       fmtstr3 = "(/,T3,A,T34,3F  .  )"
       WRITE (UNIT=fmtstr3(18:19),FMT="(I2)") ndigits
       WRITE (UNIT=fmtstr3(15:16),FMT="(I2)") ndigits + 6
       
       fmtstr4 = "((T34,3F  .  ))"
       WRITE (UNIT=fmtstr4(12:13),FMT="(I2)") ndigits
       WRITE (UNIT=fmtstr4(9:10),FMT="(I2)") ndigits + 6
       
       fmtstr5 = "(/T2,A//T3,A)"
       
       
       WRITE (UNIT=output_unit,FMT=fmtstr1)&
            "FORCES","Atom","Kind","Component","X","Y","Z"
       
       grand_total(:) = 0.0_dp
       
       IF (globenv%print_level <= MEDIUM) THEN
          my_ftype=-1
       ELSE
          my_ftype=ftype
       ENDIF
!MK
       my_ftype = ftype

       SELECT CASE (my_ftype)
       CASE DEFAULT
          DO iatom=1,natom
             ikind = kind_of(iatom)
             i = atom_of_kind(iatom)
             WRITE (UNIT=output_unit,FMT=fmtstr2)&
                  iatom,ikind,"         total",qs_force(ikind)%total(1:3,i)
             grand_total(1:3) = grand_total(1:3) + qs_force(ikind)%total(1:3,i)
          END DO
       CASE (0)
          DO iatom=1,natom
             ikind = kind_of(iatom)
             i = atom_of_kind(iatom)
             WRITE (UNIT=output_unit,FMT=fmtstr2)&
                  iatom,ikind,"       overlap",qs_force(ikind)%overlap(1:3,i),&
                  iatom,ikind,"       kinetic",qs_force(ikind)%kinetic(1:3,i),&
                  iatom,ikind,"       gth_ppl",qs_force(ikind)%gth_ppl(1:3,i),&
                  iatom,ikind,"      gth_ppnl",qs_force(ikind)%gth_ppnl(1:3,i),&
                  iatom,ikind,"  core_overlap",qs_force(ikind)%core_overlap(1:3,i),&
                  iatom,ikind,"      rho_core",qs_force(ikind)%rho_core(1:3,i),&
                  iatom,ikind,"      rho_elec",qs_force(ikind)%rho_elec(1:3,i),&
                  iatom,ikind,"      ch_pulay",qs_force(ikind)%ch_pulay(1:3,i),&
                  iatom,ikind,"         other",qs_force(ikind)%other(1:3,i),&
                  iatom,ikind,"         total",qs_force(ikind)%total(1:3,i)
             grand_total(1:3) = grand_total(1:3) + qs_force(ikind)%total(1:3,i)
          END DO
       CASE (1)
          DO iatom=1,natom
             ikind = kind_of(iatom)
             i = atom_of_kind(iatom)
             WRITE (UNIT=output_unit,FMT=fmtstr2)&
                  iatom,ikind,"       overlap",qs_force(ikind)%overlap(1:3,i),&
                  iatom,ikind,"       kinetic",qs_force(ikind)%kinetic(1:3,i),&
                  iatom,ikind,"       gth_ppl",qs_force(ikind)%gth_ppl(1:3,i),&
                  iatom,ikind,"      gth_ppnl",qs_force(ikind)%gth_ppnl(1:3,i),&
                  iatom,ikind," all_potential",qs_force(ikind)%all_potential(1:3,i),&
                  iatom,ikind,"  core_overlap",qs_force(ikind)%core_overlap(1:3,i),&
                  iatom,ikind,"      rho_core",qs_force(ikind)%rho_core(1:3,i),&
                  iatom,ikind,"      rho_elec",qs_force(ikind)%rho_elec(1:3,i),&
                  iatom,ikind,"      vhxc_atom",qs_force(ikind)%vhxc_atom(1:3,i),&
                  iatom,ikind,"    g0s_Vh_elec",qs_force(ikind)%g0s_Vh_elec(1:3,i),& 
                  iatom,ikind,"     hartree_2c",qs_force(ikind)%hartree_2c(1:3,i),& 
                  iatom,ikind,"     hartree_3c",qs_force(ikind)%hartree_3c(1:3,i),&
                  iatom,ikind,"      ch_pulay",qs_force(ikind)%ch_pulay(1:3,i),&
                  iatom,ikind,"         total",qs_force(ikind)%total(1:3,i)
             grand_total(1:3) = grand_total(1:3) + qs_force(ikind)%total(1:3,i)
          END DO
       CASE (2)
          DO iatom=1,natom
             ikind = kind_of(iatom)
             i = atom_of_kind(iatom)
             WRITE (UNIT=output_unit,FMT=fmtstr2)&
                  iatom,ikind," all_potential",qs_force(ikind)%all_potential(1:3,i),&
                  iatom,ikind,"      rho_elec",qs_force(ikind)%rho_elec(1:3,i),&
                  iatom,ikind,"         total",qs_force(ikind)%total(1:3,i)
             grand_total(1:3) = grand_total(1:3) + qs_force(ikind)%total(1:3,i)
          END DO
       CASE (3)
          DO iatom=1,natom
             ikind = kind_of(iatom)
             i = atom_of_kind(iatom)
             WRITE (UNIT=output_unit,FMT=fmtstr2)&
                  iatom,ikind,"        overlap",qs_force(ikind)%overlap(1:3,i),&
                  iatom,ikind,"        kinetic",qs_force(ikind)%kinetic(1:3,i),&
                  iatom,ikind,"        gth_ppl",qs_force(ikind)%gth_ppl(1:3,i),&
                  iatom,ikind,"       gth_ppnl",qs_force(ikind)%gth_ppnl(1:3,i),&
                  iatom,ikind,"   core_overlap",qs_force(ikind)%core_overlap(1:3,i),&
                  iatom,ikind,"       rho_core",qs_force(ikind)%rho_core(1:3,i),&
                  iatom,ikind,"       rho_elec",qs_force(ikind)%rho_elec(1:3,i),&
                  iatom,ikind,"kg_gpw_ekin_mol",qs_force(ikind)%kg_gpw_ekin_mol(1:3,i),&
                  iatom,ikind,"   kg_gpw_pauli",qs_force(ikind)%kg_gpw_pauli(1:3,i),&
                  iatom,ikind,"       ch_pulay",qs_force(ikind)%ch_pulay(1:3,i),&
                  iatom,ikind,"          total",qs_force(ikind)%total(1:3,i)
             grand_total(1:3) = grand_total(1:3) + qs_force(ikind)%total(1:3,i)
          END DO
       END SELECT
       
       WRITE (UNIT=output_unit,FMT=fmtstr3) "Sum of total",grand_total(1:3)
       
       IF (virial_present) THEN
          WRITE (UNIT=output_unit,FMT=fmtstr5) "STRESS","pv_virial"
          WRITE (UNIT=output_unit,FMT=fmtstr4) (pv_virial(i,1:3), i=1,3)
       END IF
       
       DEALLOCATE (atom_of_kind,STAT=istat)
       IF (istat /= 0) CALL stop_memory(routine,"atom_of_kind")
       
       DEALLOCATE (kind_of,STAT=istat)
       IF (istat /= 0) CALL stop_memory(routine,"kind_of")
    END IF
  END SUBROUTINE write_forces

! *****************************************************************************

END MODULE qs_force
