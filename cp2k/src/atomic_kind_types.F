!-----------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations         !
!   Copyright (C) 2000 - 2007  CP2K developers group                          !
!-----------------------------------------------------------------------------!

!!****** cp2k/atomic_kind_types [1.0] *
!!
!!   NAME
!!     atomic_kind_types
!!
!!   FUNCTION
!!
!!   AUTHOR
!!     MK (02.01.2002)
!!
!!   MODIFICATION HISTORY
!!     - 01.2002 creation [MK]
!!     - 04.2002 added pao [fawzi]
!!     - 09.2002 adapted for POL/KG use [GT]
!!     - 02.2004 flexible normalization of basis sets [jgh]
!!     - 03.2004 attach/detach routines [jgh]
!!     - 10.2004 removed pao [fawzi]
!!   SOURCE
!******************************************************************************

MODULE atomic_kind_types

  USE basis_set_types,                 ONLY: &
       allocate_gto_basis_set, deallocate_gto_basis_set, get_gto_basis_set, &
       gto_basis_set_type, init_aux_basis_set, init_orb_basis_set, &
       read_gto_basis_set, set_gto_basis_set, write_aux_basis_set, &
       write_gto_basis_set, write_orb_basis_set
  USE cp_control_types,                ONLY: dft_control_type,&
                                             qs_control_type
  USE cp_output_handling,              ONLY: cp_p_file,&
                                             cp_print_key_finished_output,&
                                             cp_print_key_should_output,&
                                             cp_print_key_unit_nr
  USE cp_para_types,                   ONLY: cp_para_env_type
  USE external_potential_types,        ONLY: &
       all_potential_type, allocate_potential, deallocate_potential, &
       elp_potential_type, get_potential, gth_potential_type, init_potential, &
       read_potential, set_default_all_potential, set_potential, &
       write_potential
  USE input_constants,                 ONLY: do_fist,&
                                             do_kg,&
                                             do_method_am1,&
                                             do_method_dftb,&
                                             do_method_mndo,&
                                             do_method_pdg,&
                                             do_method_pm3,&
                                             do_qs
  USE input_section_types,             ONLY: section_vals_get,&
                                             section_vals_get_subs_vals,&
                                             section_vals_type,&
                                             section_vals_val_get
  USE kinds,                           ONLY: default_string_length,&
                                             dp,&
                                             int_size
  USE orbital_pointers,                ONLY: init_orbital_pointers,&
                                             ncoset
  USE paw_proj_set_types,              ONLY: allocate_paw_proj_set,&
                                             deallocate_paw_proj_set,&
                                             get_paw_proj_set,&
                                             paw_proj_set_type,&
                                             projectors
  USE periodic_table,                  ONLY: ptable
  USE physcon,                         ONLY: bohr,&
                                             massunit
  USE qs_dftb_types,                   ONLY: qs_dftb_atom_type
  USE qs_dftb_utils,                   ONLY: deallocate_dftb_atom_param,&
                                             get_dftb_atom_param
  USE qs_grid_atom,                    ONLY: allocate_grid_atom,&
                                             deallocate_grid_atom,&
                                             grid_atom_type
  USE qs_harmonics_atom,               ONLY: allocate_harmonics_atom,&
                                             deallocate_harmonics_atom,&
                                             harmonics_atom_type
  USE semi_empirical_types,            ONLY: semi_empirical_type
  USE semi_empirical_utils,            ONLY: allocate_se_param,&
                                             deallocate_se_param,&
                                             get_se_param,&
                                             init_se_param,&
                                             se_param_set_default,&
                                             write_se_param
  USE shell_potential_types,           ONLY: shell_kind_type,&
                                             shell_release,&
                                             shell_retain
  USE soft_basis_set,                  ONLY: create_soft_basis
  USE string_utilities,                ONLY: uppercase
  USE termination,                     ONLY: stop_memory,&
                                             stop_program
#include "cp_common_uses.h"

  IMPLICIT NONE

  PRIVATE

! *** Global parameters (only in this module)

  CHARACTER(len=*), PARAMETER, PRIVATE :: moduleN = 'atomic_kind_types'


! *** Define the atomic kind types ***

  TYPE atomic_kind_type
    TYPE(all_potential_type), POINTER      :: all_potential
    TYPE(elp_potential_type), POINTER      :: elp_potential
    TYPE(gth_potential_type), POINTER      :: gth_potential
    TYPE(semi_empirical_type), POINTER     :: se_parameter
    TYPE(qs_dftb_atom_type), POINTER       :: dftb_parameter
    TYPE(gto_basis_set_type), POINTER      :: aux_basis_set
    TYPE(gto_basis_set_type), POINTER      :: orb_basis_set
    TYPE(gto_basis_set_type), POINTER      :: soft_basis_set
    TYPE(gto_basis_set_type), POINTER      :: hard_basis_set
    TYPE(paw_proj_set_type),  POINTER      :: paw_proj_set
    REAL(dp)                               :: hard_radius  ! for hard and soft exp
    REAL(dp)                               :: hard0_radius ! for hard exp of rho0
    REAL(dp)                               :: max_rad_local ! max GTO radius used in GAPW
                                                            !projectors construction
    LOGICAL                                :: paw_atom     ! needs atomic rho1
    LOGICAL                                :: qm_atom    ! needs atomic rho1
    LOGICAL                                :: gpw_type_forced ! gpw atom even if with hard exponents
    LOGICAL                                :: ghost
    CHARACTER(LEN=default_string_length)   :: name
    CHARACTER(LEN=2)                       :: element_symbol
    REAL(KIND = dp)                        :: mass
    INTEGER                                :: kind_number,&
                                              natom,&
                                              number_of_grid_points
    INTEGER, DIMENSION(:), POINTER         :: atom_list
    TYPE(harmonics_atom_type), POINTER     :: harmonics
    TYPE(grid_atom_type), POINTER          :: grid_atom
    INTEGER                                :: ngrid_rad,ngrid_ang
    INTEGER                                :: lmax_rho0
    INTEGER, DIMENSION(:), POINTER         :: elec_conf ! used to set up the initial atomic guess
                                                        ! user can specify whatever...

    LOGICAL                                :: shell_active
    TYPE(shell_kind_type), POINTER              :: shell
  END TYPE atomic_kind_type

  TYPE atomic_kind_p_type
    TYPE(atomic_kind_type),DIMENSION(:),&
       POINTER                             :: atomic_kind_set
  END TYPE atomic_kind_p_type

! *** Public subroutines ***

  PUBLIC :: allocate_atomic_kind_set,&
            check_atomic_kind_set,&
            deallocate_atomic_kind_set,&
            get_atomic_kind,&
            get_atomic_kind_set,&
            init_atomic_kind_set,&
            init_gapw_basis_set,&
            read_atomic_kind_set,&
            set_atomic_kind,&
            write_atomic_kind,&
            write_atomic_kind_set,&
            write_gto_basis_sets

! *** Public data types ***

  PUBLIC :: atomic_kind_type,&
            atomic_kind_p_type

!!***
! *****************************************************************************

CONTAINS

! *****************************************************************************

  SUBROUTINE allocate_atomic_kind_set(atomic_kind_set,nkind,error)

!   Purpose: Allocate an atomic kind set.

!   History: - Creation (08.01.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    INTEGER, INTENT(IN)                      :: nkind
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'allocate_atomic_kind_set'

    INTEGER                                  :: ikind, istat

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind_set)) THEN
      CALL deallocate_atomic_kind_set(atomic_kind_set,error)
    END IF

    ALLOCATE (atomic_kind_set(nkind),STAT=istat)
    IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                     "atomic_kind_set",nkind*int_size)

    DO ikind=1,nkind
      NULLIFY (atomic_kind_set(ikind)%all_potential)
      NULLIFY (atomic_kind_set(ikind)%elp_potential)
      NULLIFY (atomic_kind_set(ikind)%gth_potential)
      NULLIFY (atomic_kind_set(ikind)%se_parameter)
      NULLIFY (atomic_kind_set(ikind)%dftb_parameter)
      NULLIFY (atomic_kind_set(ikind)%aux_basis_set)
      NULLIFY (atomic_kind_set(ikind)%orb_basis_set)
      NULLIFY (atomic_kind_set(ikind)%atom_list)
      NULLIFY (atomic_kind_set(ikind)%elec_conf)
      NULLIFY (atomic_kind_set(ikind)%hard_basis_set)
      NULLIFY (atomic_kind_set(ikind)%soft_basis_set)
      NULLIFY (atomic_kind_set(ikind)%paw_proj_set)
      NULLIFY (atomic_kind_set(ikind)%harmonics)
      NULLIFY (atomic_kind_set(ikind)%grid_atom)
      NULLIFY (atomic_kind_set(ikind)%shell)
      atomic_kind_set(ikind)%name = ""
      atomic_kind_set(ikind)%element_symbol = ""
      atomic_kind_set(ikind)%mass = 0.0_dp
      atomic_kind_set(ikind)%kind_number = 0
      atomic_kind_set(ikind)%natom = 0
      atomic_kind_set(ikind)%number_of_grid_points = 0
      atomic_kind_set(ikind)%paw_atom = .FALSE.
      atomic_kind_set(ikind)%qm_atom = .FALSE.
      atomic_kind_set(ikind)%gpw_type_forced = .FALSE.
      atomic_kind_set(ikind)%hard_radius = 0.8_dp*bohr
      atomic_kind_set(ikind)%hard0_radius = 0.8_dp*bohr
      atomic_kind_set(ikind)%max_rad_local = 13.2_dp*bohr
      atomic_kind_set(ikind)%ngrid_rad = 50
      atomic_kind_set(ikind)%ngrid_ang = 50
      atomic_kind_set(ikind)%lmax_rho0 = 0
      atomic_kind_set(ikind)%ghost = .FALSE.
      atomic_kind_set(ikind)%shell_active=.FALSE.
    END DO

  END SUBROUTINE allocate_atomic_kind_set

! *****************************************************************************

  SUBROUTINE deallocate_atomic_kind_set(atomic_kind_set,error)

!   Purpose: Deallocate an atomic kind set.

!   History: - Creation (09.01.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'deallocate_atomic_kind_set'

    INTEGER                                  :: ikind, istat, nkind

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind_set)) THEN

      nkind = SIZE(atomic_kind_set)

      DO ikind=1,nkind
        IF (ASSOCIATED(atomic_kind_set(ikind)%all_potential)) THEN
          CALL deallocate_potential(atomic_kind_set(ikind)%all_potential)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%elp_potential)) THEN
          CALL deallocate_potential(atomic_kind_set(ikind)%elp_potential)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%gth_potential)) THEN
          CALL deallocate_potential(atomic_kind_set(ikind)%gth_potential)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%se_parameter)) THEN
          CALL deallocate_se_param(atomic_kind_set(ikind)%se_parameter)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%dftb_parameter)) THEN
          CALL deallocate_dftb_atom_param(atomic_kind_set(ikind)%dftb_parameter,error)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%aux_basis_set)) THEN
          CALL deallocate_gto_basis_set(atomic_kind_set(ikind)%aux_basis_set)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%soft_basis_set).AND.&
                                         atomic_kind_set(ikind)%paw_atom) THEN
          CALL deallocate_gto_basis_set(atomic_kind_set(ikind)%soft_basis_set)
        ELSEIF(ASSOCIATED(atomic_kind_set(ikind)%soft_basis_set).AND.&
                          (.NOT.atomic_kind_set(ikind)%paw_atom)) THEN
          NULLIFY (atomic_kind_set(ikind)%soft_basis_set)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%orb_basis_set)) THEN
          CALL deallocate_gto_basis_set(atomic_kind_set(ikind)%orb_basis_set)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%paw_proj_set)) THEN
          CALL deallocate_paw_proj_set(atomic_kind_set(ikind)%paw_proj_set)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%harmonics)) THEN
          CALL deallocate_harmonics_atom(atomic_kind_set(ikind)%harmonics)
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%grid_atom)) THEN
          CALL deallocate_grid_atom(atomic_kind_set(ikind)%grid_atom)
        END IF

        IF (ASSOCIATED(atomic_kind_set(ikind)%atom_list)) THEN
           DEALLOCATE (atomic_kind_set(ikind)%atom_list,STAT=istat)
           IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                "atomic_kind_set(ikind)%atom_list")
        END IF
        IF (ASSOCIATED(atomic_kind_set(ikind)%elec_conf)) THEN
            DEALLOCATE (atomic_kind_set(ikind)%elec_conf,STAT=istat)
            IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                             "atomic_kind_set(ikind)%elec_conf")
        ENDIF
        CALL shell_release(atomic_kind_set(ikind)%shell,error)

      END DO

      DEALLOCATE (atomic_kind_set,STAT=istat)
      IF (istat /= 0) CALL stop_memory(routineN,moduleN,__LINE__,&
                                       "atomic_kind_set")

    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind_set is not associated and "//&
                        "cannot be deallocated")

    END IF

  END SUBROUTINE deallocate_atomic_kind_set

! *****************************************************************************

  SUBROUTINE get_atomic_kind(atomic_kind,all_potential,elp_potential,&
                             gth_potential,se_parameter,dftb_parameter,&
                             aux_basis_set,orb_basis_set,&
                             element_symbol,name,mass,kind_number,natom,&
                             atom_list,alpha_core_charge,ccore_charge,&
                             core_charge,&
                             core_charge_radius,ncgf,nsgf,z,zeff,qeff,&
                             soft_basis_set, elec_conf,&
                             hard_basis_set,paw_proj_set,softb,&
                             paw_atom,qm_atom,hard_radius,hard0_radius,&
                             max_rad_local, gpw_type_forced,&
                             harmonics, max_iso_not0, max_s_harm,&
                             grid_atom, ngrid_ang, ngrid_rad, lmax_rho0, ghost,&
                             shell, shell_active)

!   Purpose: Get informations about an atomic kind.

!   History: - Creation (10.01.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(all_potential_type), OPTIONAL, &
      POINTER                                :: all_potential
    TYPE(elp_potential_type), OPTIONAL, &
      POINTER                                :: elp_potential
    TYPE(gth_potential_type), OPTIONAL, &
      POINTER                                :: gth_potential
    TYPE(semi_empirical_type), OPTIONAL, &
      POINTER                                :: se_parameter
    TYPE(qs_dftb_atom_type), OPTIONAL, &
      POINTER                                :: dftb_parameter
    TYPE(gto_basis_set_type), OPTIONAL, &
      POINTER                                :: aux_basis_set, orb_basis_set
    CHARACTER(LEN=2), INTENT(OUT), OPTIONAL  :: element_symbol
    CHARACTER(LEN=default_string_length), &
      INTENT(OUT), OPTIONAL                  :: name
    REAL(KIND=dp), INTENT(OUT), OPTIONAL     :: mass
    INTEGER, INTENT(OUT), OPTIONAL           :: kind_number, natom
    INTEGER, DIMENSION(:), OPTIONAL, POINTER :: atom_list
    REAL(KIND=dp), INTENT(OUT), OPTIONAL     :: alpha_core_charge, &
                                                ccore_charge, core_charge, &
                                                core_charge_radius
    INTEGER, INTENT(OUT), OPTIONAL           :: ncgf, nsgf, z
    REAL(KIND=dp), INTENT(OUT), OPTIONAL     :: zeff, qeff
    TYPE(gto_basis_set_type), OPTIONAL, &
      POINTER                                :: soft_basis_set
    INTEGER, DIMENSION(:), OPTIONAL, POINTER :: elec_conf
    TYPE(gto_basis_set_type), OPTIONAL, &
      POINTER                                :: hard_basis_set
    TYPE(paw_proj_set_type), OPTIONAL, &
      POINTER                                :: paw_proj_set
    LOGICAL, INTENT(IN), OPTIONAL            :: softb
    LOGICAL, INTENT(OUT), OPTIONAL           :: paw_atom, qm_atom
    REAL(dp), INTENT(OUT), OPTIONAL          :: hard_radius, hard0_radius, &
                                                max_rad_local
    LOGICAL, INTENT(OUT), OPTIONAL           :: gpw_type_forced
    TYPE(harmonics_atom_type), OPTIONAL, &
      POINTER                                :: harmonics
    INTEGER, INTENT(OUT), OPTIONAL           :: max_iso_not0, max_s_harm
    TYPE(grid_atom_type), OPTIONAL, POINTER  :: grid_atom
    INTEGER, INTENT(OUT), OPTIONAL           :: ngrid_ang, ngrid_rad, &
                                                lmax_rho0
    LOGICAL, INTENT(OUT), OPTIONAL           :: ghost
    TYPE(shell_kind_type), OPTIONAL, POINTER :: shell
    LOGICAL, INTENT(OUT), OPTIONAL           :: shell_active

    CHARACTER(LEN=*), PARAMETER              :: routineN = 'get_atomic_kind'

    LOGICAL                                  :: softb_local

!   ---------------------------------------------------------------------------

    softb_local = .FALSE.

    IF (ASSOCIATED(atomic_kind)) THEN

      IF (PRESENT(softb)) softb_local = softb
      IF (PRESENT(all_potential)) all_potential => atomic_kind%all_potential
      IF (PRESENT(elp_potential)) elp_potential => atomic_kind%elp_potential
      IF (PRESENT(gth_potential)) gth_potential => atomic_kind%gth_potential
      IF (PRESENT(se_parameter))  se_parameter  => atomic_kind%se_parameter
      IF (PRESENT(dftb_parameter))  dftb_parameter  => atomic_kind%dftb_parameter
      IF (PRESENT(aux_basis_set)) aux_basis_set => atomic_kind%aux_basis_set
      IF (PRESENT(orb_basis_set)) THEN
        IF(softb_local) THEN
          orb_basis_set => atomic_kind%soft_basis_set
        ELSE
          orb_basis_set => atomic_kind%orb_basis_set
        END IF
      END IF
      IF (PRESENT(element_symbol)) element_symbol = atomic_kind%element_symbol
      IF (PRESENT(name)) name = atomic_kind%name
      IF (PRESENT(mass)) mass = atomic_kind%mass
      IF (PRESENT(kind_number)) kind_number = atomic_kind%kind_number
      IF (PRESENT(natom)) natom = atomic_kind%natom
      IF (PRESENT(atom_list)) atom_list => atomic_kind%atom_list
      IF (PRESENT(elec_conf)) elec_conf => atomic_kind%elec_conf
      IF (PRESENT(alpha_core_charge)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL get_potential(potential=atomic_kind%all_potential,&
                             alpha_core_charge=alpha_core_charge)
        ELSE IF (ASSOCIATED(atomic_kind%elp_potential)) THEN
          CALL get_potential(potential=atomic_kind%elp_potential,&
                             alpha_core_charge=alpha_core_charge)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL get_potential(potential=atomic_kind%gth_potential,&
                             alpha_core_charge=alpha_core_charge)
        ELSE
          alpha_core_charge = 1.0_dp
        END IF
      END IF
      IF (PRESENT(ccore_charge)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL get_potential(potential=atomic_kind%all_potential,&
                             ccore_charge=ccore_charge)
        ELSE IF (ASSOCIATED(atomic_kind%elp_potential)) THEN
          CALL get_potential(potential=atomic_kind%elp_potential,&
                             ccore_charge=ccore_charge)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL get_potential(potential=atomic_kind%gth_potential,&
                             ccore_charge=ccore_charge)
        ELSE
          ccore_charge = 0.0_dp
        END IF
      END IF
      IF (PRESENT(core_charge_radius)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL get_potential(potential=atomic_kind%all_potential,&
                             core_charge_radius=core_charge_radius)
        ELSE IF (ASSOCIATED(atomic_kind%elp_potential)) THEN
          CALL get_potential(potential=atomic_kind%elp_potential,&
                             core_charge_radius=core_charge_radius)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL get_potential(potential=atomic_kind%gth_potential,&
                             core_charge_radius=core_charge_radius)
        ELSE
          core_charge_radius = 0.0_dp
        END IF
      END IF
      IF (PRESENT(core_charge)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL get_potential(potential=atomic_kind%all_potential,&
                             zeff=core_charge)
        ELSE IF (ASSOCIATED(atomic_kind%elp_potential)) THEN
          CALL get_potential(potential=atomic_kind%elp_potential,&
                             qeff=core_charge)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL get_potential(potential=atomic_kind%gth_potential,&
                             zeff=core_charge)
        ELSE
          core_charge = 0.0_dp
        END IF
      END IF
      IF (PRESENT(ncgf)) THEN
        IF (ASSOCIATED(atomic_kind%orb_basis_set)) THEN
          CALL get_gto_basis_set(gto_basis_set=atomic_kind%orb_basis_set,&
                                 ncgf=ncgf)
        ELSE
          ncgf = 0
        END IF
      END IF
      IF (PRESENT(nsgf)) THEN
        IF (ASSOCIATED(atomic_kind%orb_basis_set)) THEN
          CALL get_gto_basis_set(gto_basis_set=atomic_kind%orb_basis_set,&
                                 nsgf=nsgf)
        ELSE IF(ASSOCIATED(atomic_kind%dftb_parameter)) THEN
          nsgf = atomic_kind%dftb_parameter%natorb
        ELSE
          nsgf = 0
        END IF
      END IF
      IF (PRESENT(z)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL get_potential(potential=atomic_kind%all_potential,z=z)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL get_potential(potential=atomic_kind%gth_potential,z=z)
        ELSE
          z = 0
        END IF
      END IF
      IF (PRESENT(zeff)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL get_potential(potential=atomic_kind%all_potential,zeff=zeff)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL get_potential(potential=atomic_kind%gth_potential,zeff=zeff)
        ELSE
          zeff = 0.0_dp
        END IF
      END IF
      IF (PRESENT(qeff)) THEN
        IF (ASSOCIATED(atomic_kind%elp_potential)) THEN
          CALL get_potential(potential=atomic_kind%elp_potential,qeff=qeff)
        ELSE
          qeff = -HUGE(0.0_dp)
        END IF
      END IF
      IF (PRESENT(soft_basis_set)) soft_basis_set => atomic_kind%soft_basis_set
      IF (PRESENT(hard_basis_set)) hard_basis_set => atomic_kind%hard_basis_set
      IF (PRESENT(paw_proj_set))   paw_proj_set => atomic_kind%paw_proj_set
      IF (PRESENT(paw_atom)) paw_atom = atomic_kind%paw_atom
      IF (PRESENT(qm_atom)) qm_atom = atomic_kind%qm_atom
      IF (PRESENT(gpw_type_forced)) gpw_type_forced = atomic_kind%gpw_type_forced
      IF (PRESENT(hard_radius)) hard_radius = atomic_kind%hard_radius
      IF (PRESENT(hard0_radius)) hard0_radius = atomic_kind%hard0_radius
      IF (PRESENT(max_rad_local)) max_rad_local = atomic_kind%max_rad_local
      IF (PRESENT(harmonics))  harmonics => atomic_kind%harmonics
      IF (PRESENT(max_s_harm)) THEN
         IF(ASSOCIATED(atomic_kind%harmonics)) THEN
            max_s_harm = atomic_kind%harmonics%max_s_harm
         ELSE
            max_s_harm = 0
         END IF
      END IF
      IF (PRESENT(max_iso_not0)) THEN
         IF(ASSOCIATED(atomic_kind%harmonics)) THEN
            max_iso_not0 = atomic_kind%harmonics%max_iso_not0
         ELSE
            max_iso_not0 = 0
         END IF
      END IF
      IF (PRESENT(grid_atom)) grid_atom => atomic_kind%grid_atom
      IF (PRESENT(ngrid_ang)) ngrid_ang = atomic_kind%ngrid_ang
      IF (PRESENT(ngrid_rad)) ngrid_rad = atomic_kind%ngrid_rad
      IF (PRESENT(lmax_rho0)) lmax_rho0 = atomic_kind%lmax_rho0
      IF (PRESENT(ghost)) ghost = atomic_kind%ghost
      IF (PRESENT(shell)) shell => atomic_kind%shell
      IF (PRESENT(shell_active)) shell_active = atomic_kind%shell_active

    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind is not associated")

    END IF

  END SUBROUTINE get_atomic_kind

! *****************************************************************************

  SUBROUTINE get_atomic_kind_set(atomic_kind_set,maxatom,maxcgf,&
                                 maxco,maxco_proj,maxgtop,maxgtops,maxlgto,&
                                 maxlppl,maxlppnl,maxnset,maxpgf,&
                                 maxppnl,maxsgf,maxsgf_set,maxshell,&
                                 natom,nelectron,ncgf,ncgf_aux,&
                                 npgf,nset,nsgf,nshell,&
                                 all_potential_present,gth_potential_present,&
                                 elp_potential_present,paw_atom_present,&
                                 qm_atom_present,shell_present, shell_adiabatic,&
                                 atom_of_kind,kind_of,natom_of_kind,maxder,&
                                 max_ngrid_rad,&
                                 max_sph_harm,maxg_iso_not0,lmax_rho0,&
                                 zetsoft_max)

!   Purpose: Get informations about an atomic kind set.

!   History: - Creation (14.01.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    INTEGER, INTENT(OUT), OPTIONAL :: maxatom, maxcgf, maxco, maxco_proj, &
      maxgtop, maxgtops, maxlgto, maxlppl, maxlppnl, maxnset, maxpgf, &
      maxppnl, maxsgf, maxsgf_set, maxshell, natom, nelectron, ncgf, &
      ncgf_aux, npgf, nset, nsgf, nshell
    LOGICAL, INTENT(OUT), OPTIONAL :: all_potential_present, &
      gth_potential_present, elp_potential_present, paw_atom_present, &
      qm_atom_present, shell_present, shell_adiabatic
    INTEGER, DIMENSION(:), INTENT(OUT), &
      OPTIONAL                               :: atom_of_kind, kind_of, &
                                                natom_of_kind
    INTEGER, INTENT(IN), OPTIONAL            :: maxder
    INTEGER, INTENT(OUT), OPTIONAL           :: max_ngrid_rad, max_sph_harm, &
                                                maxg_iso_not0, lmax_rho0
    REAL(kind=dp), INTENT(out), OPTIONAL     :: zetsoft_max

    CHARACTER(LEN=*), PARAMETER :: routineN = 'get_atomic_kind_set'

    INTEGER :: atom_a, iatom, ikind, imax, ipgf, iset, lmax_rho0_kind, &
      max_iso_not0, max_s_harm, n, ngrid_rad, nkind
    INTEGER, DIMENSION(:), POINTER           :: n_ppl, npgf_kind
    LOGICAL                                  :: paw_atom, qm_atom
    REAL(KIND=dp)                            :: zeff, zeff_correction
    REAL(kind=dp), DIMENSION(:, :), POINTER  :: zet_kind
    TYPE(all_potential_type), POINTER        :: all_potential
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(elp_potential_type), POINTER        :: elp_potential
    TYPE(gth_potential_type), POINTER        :: gth_potential
    TYPE(gto_basis_set_type), POINTER        :: aux_basis_set, orb_basis_set, &
                                                soft_basis_set
    TYPE(paw_proj_set_type), POINTER         :: paw_proj_set
    TYPE(qs_dftb_atom_type), POINTER         :: dftb_parameter
    TYPE(shell_kind_type), POINTER           :: shell

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind_set)) THEN

      IF (PRESENT(maxatom)) maxatom = 0
      IF (PRESENT(maxcgf)) maxcgf = 0
      IF (PRESENT(maxco)) maxco = 0
      IF (PRESENT(maxco_proj)) maxco_proj = 0
      IF (PRESENT(maxg_iso_not0)) maxg_iso_not0 = 0
      IF (PRESENT(maxgtop))  maxgtop = 0
      IF (PRESENT(maxgtops)) maxgtops = 0
      IF (PRESENT(maxlgto)) maxlgto = -1
      IF (PRESENT(maxlppl)) maxlppl = -1
      IF (PRESENT(maxlppnl)) maxlppnl = -1
      IF (PRESENT(maxnset)) maxnset = 0
      IF (PRESENT(maxpgf)) maxpgf = 0
      IF (PRESENT(maxppnl)) maxppnl = 0
      IF (PRESENT(maxsgf)) maxsgf = 0
      IF (PRESENT(maxsgf_set)) maxsgf_set = 0
      IF (PRESENT(maxshell)) maxshell = 0
      IF (PRESENT(natom)) natom = 0
      IF (PRESENT(ncgf)) ncgf = 0
      IF (PRESENT(ncgf_aux)) ncgf_aux = 0
      IF (PRESENT(nelectron)) nelectron = 0
      IF (PRESENT(npgf)) npgf = 0
      IF (PRESENT(nset)) nset = 0
      IF (PRESENT(nsgf)) nsgf = 0
      IF (PRESENT(nshell)) nshell = 0
      IF (PRESENT(all_potential_present)) all_potential_present = .FALSE.
      IF (PRESENT(elp_potential_present)) elp_potential_present = .FALSE.
      IF (PRESENT(gth_potential_present)) gth_potential_present = .FALSE.
      IF (PRESENT(paw_atom_present)) paw_atom_present = .FALSE.
      IF (PRESENT(qm_atom_present)) qm_atom_present = .FALSE.
      IF (PRESENT(shell_present)) shell_present = .FALSE.
      IF (PRESENT(shell_adiabatic)) shell_adiabatic = .FALSE.
      IF (PRESENT(paw_atom_present)) paw_atom_present = .FALSE.
      IF (PRESENT(atom_of_kind)) atom_of_kind(:) = 0
      IF (PRESENT(kind_of)) kind_of(:) = 0
      IF (PRESENT(natom_of_kind)) natom_of_kind(:) = 0
      IF (PRESENT(zetsoft_max))  zetsoft_max = 0.0_dp
      IF (PRESENT(max_ngrid_rad))  max_ngrid_rad = 0
      IF (PRESENT(max_sph_harm))   max_sph_harm = 0
      IF (PRESENT(lmax_rho0))      lmax_rho0 = 0

      nkind = SIZE(atomic_kind_set)
      DO ikind=1,nkind
        atomic_kind => atomic_kind_set(ikind)
        CALL get_atomic_kind(atomic_kind=atomic_kind,&
                             all_potential=all_potential,&
                             elp_potential=elp_potential,&
                             gth_potential=gth_potential,&
                             aux_basis_set=aux_basis_set,&
                             orb_basis_set=orb_basis_set,&
                             soft_basis_set=soft_basis_set,&
                             dftb_parameter=dftb_parameter,&
                             ngrid_rad=ngrid_rad,&
                             max_s_harm=max_s_harm, &
                             max_iso_not0=max_iso_not0,&
                             paw_atom=paw_atom,&
                             qm_atom=qm_atom,&
                             lmax_rho0=lmax_rho0_kind,&
                             shell=shell)
        IF (PRESENT(maxatom)) THEN
          maxatom = MAX(maxatom,atomic_kind%natom)
        END IF
        IF (PRESENT(maxlppl).AND.ASSOCIATED(gth_potential)) THEN
          CALL get_potential(potential=gth_potential,nexp_ppl=n)
          maxlppl = MAX(maxlppl,2*(n - 1))
        END IF
        IF (PRESENT(maxlppl).AND.ASSOCIATED(elp_potential)) THEN
          CALL get_potential(potential=elp_potential,nexp_ppl=n_ppl)
          n=MAXVAL(n_ppl)
          maxlppl = MAX(maxlppl,2*(n - 1))
        END IF
        IF (PRESENT(maxlppnl).AND.ASSOCIATED(gth_potential)) THEN
          CALL get_potential(potential=gth_potential,lprj_ppnl_max=imax)
          maxlppnl = MAX(maxlppnl,imax)
        END IF
        IF (ASSOCIATED(elp_potential)) THEN
          CALL get_potential(potential=elp_potential)
        END IF
        IF (PRESENT(maxcgf)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,ncgf=imax)
            maxcgf = MAX(maxcgf,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,ncgf=imax)
            maxcgf = MAX(maxcgf,imax)
          END IF
        END IF
        IF (PRESENT(maxco)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            IF (PRESENT(maxder)) THEN
              CALL get_gto_basis_set(gto_basis_set=aux_basis_set,&
                                     maxco=imax,maxder=maxder)
            ELSE
              CALL get_gto_basis_set(gto_basis_set=aux_basis_set,maxco=imax)
            END IF
            maxco = MAX(maxco,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            IF (PRESENT(maxder)) THEN
              CALL get_gto_basis_set(gto_basis_set=orb_basis_set,&
                                     maxco=imax,maxder=maxder)
            ELSE
              CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxco=imax)
            END IF
            maxco = MAX(maxco,imax)
          END IF
          IF (ASSOCIATED(gth_potential)) THEN
            CALL get_potential(potential=gth_potential,lprj_ppnl_max=imax)
            maxco = MAX(maxco,ncoset(imax))
          END IF
        END IF
        IF (PRESENT(maxco_proj)) THEN
          IF (ASSOCIATED(paw_proj_set)) THEN
            CALL get_paw_proj_set(paw_proj_set=paw_proj_set,ncgauprj=imax)
            maxco_proj = MAX(maxco_proj,imax)
          END IF
        ENDIF
        IF (PRESENT(maxgtop)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxco=imax,&
                              nset=n)
            maxgtop = MAX(maxgtop, n*imax)
          END IF
        END IF
        IF (PRESENT(maxgtops)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxso=imax,&
                              nset=n)
            maxgtops = MAX(maxgtops, n*imax)
          END IF
        END IF
        IF (PRESENT(maxlgto)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,maxl=imax)
            maxlgto = MAX(maxlgto,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxl=imax)
            maxlgto = MAX(maxlgto,imax)
          END IF
          IF (ASSOCIATED(dftb_parameter)) THEN
            CALL get_dftb_atom_param(dftb_parameter=dftb_parameter,lmax=imax)
            maxlgto = MAX(maxlgto,imax)
          END IF
        END IF
        IF (PRESENT(maxnset)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,&
                              nset=n)
            maxnset = MAX(maxnset, n)
          END IF
        END IF
        IF (PRESENT(maxpgf)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,maxpgf=imax)
            maxpgf = MAX(maxpgf,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxpgf=imax)
            maxpgf = MAX(maxpgf,imax)
          END IF
        END IF
        IF (PRESENT(maxppnl).AND.ASSOCIATED(gth_potential)) THEN
          CALL get_potential(potential=gth_potential,nppnl=imax)
          maxppnl = MAX(maxppnl,imax)
        END IF
        IF (PRESENT(maxsgf)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,nsgf=imax)
            maxsgf = MAX(maxsgf,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,nsgf=imax)
            maxsgf = MAX(maxsgf,imax)
          END IF
        END IF
        IF (PRESENT(maxsgf_set)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,maxsgf_set=imax)
            maxsgf_set = MAX(maxsgf_set,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxsgf_set=imax)
            maxsgf_set = MAX(maxsgf_set,imax)
          END IF
        END IF
        IF (PRESENT(maxshell)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,maxshell=imax)
            maxshell = MAX(maxshell,imax)
          END IF
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,maxshell=imax)
            maxshell = MAX(maxshell,imax)
          END IF
        END IF
        IF (PRESENT(natom)) THEN
          natom = natom + atomic_kind_set(ikind)%natom
        END IF
        IF (PRESENT(ncgf)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,ncgf=n)
            ncgf = ncgf + n*atomic_kind_set(ikind)%natom
          END IF
        END IF
        IF (PRESENT(ncgf_aux)) THEN
          IF (ASSOCIATED(aux_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=aux_basis_set,ncgf=n)
            ncgf_aux = ncgf_aux + n*atomic_kind_set(ikind)%natom
          END IF
        END IF
        IF (PRESENT(nelectron)) THEN
          IF (ASSOCIATED(atomic_kind%all_potential)) THEN
            CALL get_potential(potential=atomic_kind%all_potential,&
                 zeff=zeff,zeff_correction=zeff_correction)
          ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
            CALL get_potential(potential=atomic_kind%gth_potential,&
                 zeff=zeff,zeff_correction=zeff_correction)
          ELSE
            zeff = 0.0_dp
            zeff_correction = 0.0_dp
          END IF
          nelectron = nelectron + atomic_kind_set(ikind)%natom*INT(zeff-zeff_correction)
        END IF
        IF (PRESENT(npgf)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,npgf_sum=n)
            npgf = npgf + n*atomic_kind_set(ikind)%natom
          END IF
        END IF
        IF (PRESENT(nset)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,nset=n)
            nset = nset + n*atomic_kind_set(ikind)%natom
          END IF
        END IF
        IF (PRESENT(nsgf)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,nsgf=n)
            nsgf = nsgf + n*atomic_kind_set(ikind)%natom
          END IF
          IF (ASSOCIATED(dftb_parameter)) THEN
            CALL get_dftb_atom_param(dftb_parameter=dftb_parameter,natorb=n)
            nsgf = nsgf + n*atomic_kind_set(ikind)%natom
          END IF
        END IF
        IF (PRESENT(nshell)) THEN
          IF (ASSOCIATED(orb_basis_set)) THEN
            CALL get_gto_basis_set(gto_basis_set=orb_basis_set,nshell_sum=n)
            nshell = nshell + n*atomic_kind_set(ikind)%natom
          END IF
          IF (ASSOCIATED(dftb_parameter)) THEN
            CALL get_dftb_atom_param(dftb_parameter=dftb_parameter,lmax=n)
            nshell = nshell + (n+1)*atomic_kind_set(ikind)%natom
          END IF
        END IF
        IF (PRESENT(all_potential_present)) THEN
          IF (ASSOCIATED(all_potential)) THEN
            all_potential_present = .TRUE.
          END IF
        END IF
        IF (PRESENT(elp_potential_present)) THEN
          IF (ASSOCIATED(elp_potential)) THEN
            elp_potential_present = .TRUE.
          END IF
        END IF
        IF (PRESENT(gth_potential_present)) THEN
          IF (ASSOCIATED(gth_potential)) THEN
            gth_potential_present = .TRUE.
          END IF
        END IF
        IF (PRESENT(paw_atom_present)) THEN
          IF (paw_atom) THEN
            paw_atom_present = .TRUE.
          END IF
        END IF
        IF (PRESENT(qm_atom_present)) THEN
          IF (qm_atom) THEN
            qm_atom_present = .TRUE.
          END IF
        END IF
        IF (PRESENT(shell_present)) THEN
          IF (ASSOCIATED(shell)) THEN
            shell_present = .TRUE.
          END IF
        END IF
        IF (PRESENT(shell_adiabatic) .AND. ASSOCIATED(shell) )THEN
           IF(.NOT. shell_adiabatic) shell_adiabatic = (shell%massfrac /= 0.0_dp)
        END IF
        IF (PRESENT(atom_of_kind)) THEN
          DO iatom=1,atomic_kind%natom
            atom_a = atomic_kind%atom_list(iatom)
            atom_of_kind(atom_a) = iatom
          END DO
        END IF
        IF (PRESENT(kind_of)) THEN
          DO iatom=1,atomic_kind%natom
            atom_a = atomic_kind%atom_list(iatom)
            kind_of(atom_a) = ikind
          END DO
        END IF
        IF (PRESENT(natom_of_kind)) THEN
          natom_of_kind(ikind) = atomic_kind_set(ikind)%natom
        END IF
        IF(PRESENT(max_ngrid_rad)) THEN
          max_ngrid_rad = MAX(max_ngrid_rad,ngrid_rad)
        ENDIF
        IF(PRESENT(max_sph_harm)) THEN
          max_sph_harm = MAX(max_sph_harm,max_s_harm)
        ENDIF
        IF(PRESENT(maxg_iso_not0)) THEN
          maxg_iso_not0 = MAX(maxg_iso_not0,max_iso_not0)
        END IF
        IF( PRESENT(lmax_rho0) ) THEN
          lmax_rho0 = MAX(lmax_rho0,lmax_rho0_kind)
        END IF
        IF( PRESENT(zetsoft_max) ) THEN
          CALL  get_gto_basis_set(gto_basis_set=soft_basis_set, &
                nset = n, npgf = npgf_kind, zet = zet_kind )
          DO iset = 1,n
            DO ipgf = 1,npgf_kind(iset)
               zetsoft_max= MAX(zetsoft_max,zet_kind(ipgf,iset))
            END DO
          END DO
        END IF
      END DO
    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind_set is not associated")

   END IF

  END SUBROUTINE get_atomic_kind_set

! *****************************************************************************

  SUBROUTINE init_atomic_kind(atomic_kind,para_env,force_env_section,method,error)

!   Purpose: Initialise an atomic kind data set.

!   History: - Creation (11.01.2002,MK)
!              20.09.2002 adapted for pol/kg use, gtb

!   ***************************************************************************

    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(section_vals_type), POINTER         :: force_env_section
    CHARACTER(LEN=10), INTENT(IN), OPTIONAL  :: method
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER              :: routineN = 'init_atomic_kind'

    INTEGER                                  :: method_name_id

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind)) THEN
    CALL section_vals_val_get(force_env_section,"METHOD",i_val=method_name_id,error=error)
      IF (method_name_id == do_qs) THEN
        IF (ASSOCIATED(atomic_kind%gth_potential))THEN
          CALL init_potential(atomic_kind%gth_potential)
        END IF
        IF (ASSOCIATED(atomic_kind%orb_basis_set))THEN
          IF(atomic_kind%orb_basis_set%norm_type < 0) &
                        atomic_kind%orb_basis_set%norm_type = 2
          CALL init_orb_basis_set(atomic_kind%orb_basis_set)
        END IF
        IF (ASSOCIATED(atomic_kind%aux_basis_set)) THEN
          IF(atomic_kind%aux_basis_set%norm_type < 0) &
                        atomic_kind%aux_basis_set%norm_type = 1
          CALL init_aux_basis_set(atomic_kind%aux_basis_set)
        END IF
      ELSE IF (method_name_id == do_kg) THEN
        IF (ASSOCIATED(atomic_kind%gth_potential).AND. PRESENT(method))THEN
          IF(method == "KG_GPW")&
          CALL init_potential(atomic_kind%gth_potential)
        END IF

        IF (ASSOCIATED(atomic_kind%orb_basis_set))THEN
          IF(atomic_kind%orb_basis_set%norm_type < 0) THEN
            IF(PRESENT(method)) THEN
              IF(method == "KG_GPW") THEN
                atomic_kind%orb_basis_set%norm_type = 2
              ELSE
                atomic_kind%orb_basis_set%norm_type = 1
              END IF
            ELSE
              atomic_kind%orb_basis_set%norm_type = 1
            END IF
          END IF
          CALL init_orb_basis_set(atomic_kind%orb_basis_set)
        END IF
        IF (ASSOCIATED(atomic_kind%aux_basis_set))THEN
          IF(atomic_kind%aux_basis_set%norm_type < 0) &
                        atomic_kind%aux_basis_set%norm_type = 1
          CALL init_aux_basis_set(atomic_kind%aux_basis_set)
        END IF
      ELSE IF (method_name_id == do_fist) THEN
        IF (ASSOCIATED(atomic_kind%elp_potential))THEN
          CALL allocate_potential(atomic_kind%elp_potential)
        END IF
      END IF

    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind is not associated",para_env)

   END IF

  END SUBROUTINE init_atomic_kind

! *****************************************************************************

  SUBROUTINE init_atomic_kind_set(atomic_kind_set,para_env,force_env_section,method,error)

!   Purpose: Initialise an atomic kind set data set.

!   History: - Creation (17.01.2002,MK)
!            - 20.09.2002 para_env passed (gt)

!   ***************************************************************************

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(section_vals_type), POINTER         :: force_env_section
    CHARACTER(LEN=10), INTENT(IN), OPTIONAL  :: method
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'init_atomic_kind_set'

    INTEGER                                  :: ikind, nkind
    TYPE(atomic_kind_type), POINTER          :: atomic_kind

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind_set)) THEN

      nkind = SIZE(atomic_kind_set)

      DO ikind=1,nkind
        atomic_kind => atomic_kind_set(ikind)
        CALL init_atomic_kind(atomic_kind,para_env,force_env_section=force_env_section,&
             method=method,error=error)
      END DO

    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind_set is not associated",&
                        para_env)

    END IF

  END SUBROUTINE init_atomic_kind_set

  ! ***************************************************************************

  SUBROUTINE init_gapw_basis_set(atomic_kind_set,qs_control,force_env_section,&
                                 error)

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(qs_control_type), POINTER           :: qs_control
    TYPE(section_vals_type), POINTER         :: force_env_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'init_gapw_basis_set'

    INTEGER                                  :: ikind, nkind
    LOGICAL                                  :: gpw, paw_atom
    REAL(dp)                                 :: max_rad_local_type, rc
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(gto_basis_set_type), POINTER        :: orb_basis
    TYPE(paw_proj_set_type), POINTER         :: paw_proj

! -------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind_set)) THEN

      nkind = SIZE(atomic_kind_set)

      DO ikind=1,nkind

        atomic_kind => atomic_kind_set(ikind)

        CALL allocate_gto_basis_set(atomic_kind%soft_basis_set)
        ! CALL allocate_gto_basis_set(atomic_kind%hard_basis_set)

        atomic_kind%hard_basis_set => atomic_kind%orb_basis_set

        CALL get_atomic_kind(atomic_kind=atomic_kind,&
                             orb_basis_set=orb_basis,&
                             hard_radius=rc,&
                             max_rad_local=max_rad_local_type,gpw_type_forced=gpw)

        paw_atom = .FALSE.

        IF (.NOT.gpw) THEN
          CALL create_soft_basis(orb_basis,atomic_kind%soft_basis_set,&
                                 qs_control%gapw_control,rc,paw_atom)
        END IF

        CALL set_atomic_kind(atomic_kind=atomic_kind,&
                             paw_atom=paw_atom)
        IF (paw_atom) THEN
          ! The hard_basis points to the orb_basis
          CALL allocate_paw_proj_set(atomic_kind%paw_proj_set)
          CALL get_atomic_kind(atomic_kind=atomic_kind,&
                               paw_proj_set=paw_proj)

          CALL projectors(paw_proj,orb_basis,rc,qs_control,max_rad_local_type,&
                          force_env_section,error)

        END IF

        ! grid_atom and harmonics are allocated even if NOT PAW_ATOM
        CALL allocate_grid_atom(atomic_kind%grid_atom)
        CALL allocate_harmonics_atom(atomic_kind%harmonics)

      END DO

    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind_set is not associated")

    END IF

  END SUBROUTINE init_gapw_basis_set

  ! ***************************************************************************

  SUBROUTINE read_atomic_kind(atomic_kind,kind_section,para_env,force_env_section,&
       no_fail, error)

    !   Purpose: Read an atomic kind data set from the input file.

    !   History: - Creation (09.02.2002,MK)
    !            - 20.09.2002,gt: adapted for POL/KG use (elp_potential)

    !   ***************************************************************************

    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(section_vals_type), POINTER         :: kind_section
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(section_vals_type), POINTER         :: force_env_section
    LOGICAL, INTENT(IN)                      :: no_fail
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'read_atomic_kind', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=2)                         :: current_symbol, element_symbol
    CHARACTER(LEN=default_string_length) :: akind_name, aux_basis_set_name, &
      keyword, orb_basis_set_name, potential_name, potential_type
    INTEGER                                  :: i, i_rep, ipos, k_rep, n_rep, &
                                                naux, ngrid_ang, ngrid_rad, &
                                                norb, z
    INTEGER, DIMENSION(:), POINTER           :: elec_conf
    LOGICAL                                  :: failure
    REAL(KIND=dp)                            :: zeff_correction
    TYPE(section_vals_type), POINTER         :: dft_section

    NULLIFY (elec_conf)

    failure = .FALSE.
    aux_basis_set_name = ""
    orb_basis_set_name = ""
    potential_name = ""
    potential_type = ""
    z = -1
    atomic_kind%mass=-1.0_dp
    zeff_correction = 0.0_dp

    CALL section_vals_get(kind_section,n_repetition=n_rep,error=error)
    k_rep=-1
    akind_name=atomic_kind%name
    CALL uppercase(akind_name)
    ! First we use the atom_name to find out the proper KIND section
    DO i_rep=1,n_rep
       CALL section_vals_val_get(kind_section,"_SECTION_PARAMETERS_",&
            c_val=keyword,i_rep_section=i_rep,error=error)
       CALL uppercase(keyword)
       IF (keyword==akind_name) THEN
          k_rep=i_rep
          EXIT
       END IF
    END DO
    ! The search for the KIND section failed.. check for a QM/MM link atom
    IF (k_rep<1) THEN
       ipos = INDEX(atomic_kind%name,"_")
       IF (((ipos == 2).OR.(ipos == 3)).AND.(INDEX(atomic_kind%name,"_ghost")==0)) THEN
          ! If the atm_name could not match any KIND section it maybe be a QM/MM link atom.
          ! ghost atoms will be treated differently.
          akind_name = atomic_kind%name(1:ipos-1)
          CALL uppercase(akind_name)
          DO i_rep=1,n_rep
             CALL section_vals_val_get(kind_section,"_SECTION_PARAMETERS_",&
                  c_val=keyword,i_rep_section=i_rep,error=error)
             CALL uppercase(keyword)
             IF (keyword==akind_name) THEN
                k_rep=i_rep
                EXIT
             END IF
          END DO
       END IF
    END IF
    ! The search for the KIND section failed.. check element_symbol
    IF (k_rep<1) THEN
       ! If it's not a link atom let's check for the element and map
       ! the KIND section to the element.
       akind_name = atomic_kind%element_symbol(1:2)
       CALL uppercase(akind_name)
       DO i_rep=1,n_rep
          CALL section_vals_val_get(kind_section,"_SECTION_PARAMETERS_",&
               c_val=keyword,i_rep_section=i_rep,error=error)
          CALL uppercase(keyword)
          IF (keyword==akind_name) THEN
             k_rep=i_rep
             EXIT
          END IF
       END DO
    END IF
    ! In case it should not really match any possible KIND section
    ! let's look if a default one is defined..
    IF (k_rep<1) THEN
       DO i_rep=1,n_rep
          CALL section_vals_val_get(kind_section,"_SECTION_PARAMETERS_",&
               c_val=keyword,i_rep_section=i_rep,error=error)
          CALL uppercase(keyword)
          IF (keyword=="DEFAULT") THEN
             k_rep=i_rep
             EXIT
          END IF
       END DO
    END IF
    IF (k_rep<0.AND.(.NOT.no_fail)) THEN
       CALL stop_program(routineN,moduleN,__LINE__,&
            "No &KIND section was possible to associate to the atomic kind <"//&
            TRIM(akind_name)//">. The KIND section were also scanned for the"//&
            " corresponding element <"//TRIM(atomic_kind%element_symbol)//"> "//&
            " and for the DEFAULT section but no match was found. Check your input file!",para_env)
    END IF
    ! Defining the element name
    ipos = INDEX(atomic_kind%element_symbol,"_")
    IF ((ipos == 2).OR.(ipos == 3)) THEN
       element_symbol = atomic_kind%element_symbol(1:ipos-1)
    ELSE
       element_symbol = atomic_kind%element_symbol(1:2)
    END IF
    IF (k_rep>0) THEN
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="ELEMENT",n_rep_val=i,error=error)
       IF (i>0) THEN
          CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
               keyword_name="ELEMENT",c_val=element_symbol,error=error)
       END IF
    END IF
    CALL uppercase(element_symbol)
    DO i=LBOUND(ptable,1),UBOUND(ptable,1)
       current_symbol = ptable(i)%symbol
       CALL uppercase(current_symbol)
       IF (current_symbol == element_symbol) THEN
          atomic_kind%element_symbol = ptable(i)%symbol
          IF (atomic_kind%mass==-1.0_dp) THEN
             atomic_kind%mass = ptable(i)%amass
          END IF
          z = i
          EXIT
       END IF
    END DO
    ! If a proper element was not found exit the normal execution
    IF (z == -1) THEN
       CALL stop_program(routineN,moduleN,__LINE__,&
            "No element could be assign to the atomic kind <"//&
            TRIM(akind_name)//">. Specify a valid "//&
            "element symbol in the input section <KIND "//&
            TRIM(akind_name)//"> or select a valid "//&
            "element symbol for the atomic kind name",para_env)
    END IF
    ! Normal parsing of the KIND section
    IF (k_rep>0) THEN
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="AUX_BASIS_SET", c_val=aux_basis_set_name,error=error)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="AUX_BASIS_NORMALIZATION", i_val=naux,error=error)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="BASIS_SET",c_val=orb_basis_set_name,error=error)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="BASIS_NORMALIZATION", i_val=norb,error=error)
       ! seems like atomic_kind is not initialised here
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="ELEC_CONF",n_rep_val=i,error=error)
       IF (i>0) THEN
          CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
               keyword_name="ELEC_CONF",i_vals=elec_conf,error=error)
          CALL set_atomic_kind(atomic_kind,elec_conf=elec_conf)
       ENDIF
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="CORE_CORRECTION",r_val=zeff_correction,error=error)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="MASS",n_rep_val=i,error=error)
       IF (i>0) THEN
          CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
               keyword_name="MASS",r_val=atomic_kind%mass,error=error)
       END IF
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="POTENTIAL",c_val=potential_name,error=error)
       ! assign atom dependent defaults, only H special case
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,n_rep_val=i,&
            keyword_name="HARD_EXP_RADIUS",error=error)
       IF (i==0) THEN
          IF (z==1) THEN
             atomic_kind%hard_radius=1.2_dp
          ELSE
             atomic_kind%hard_radius=0.8_dp*bohr
          ENDIF
       ELSE
          CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
               keyword_name="HARD_EXP_RADIUS",r_val=atomic_kind%hard_radius,error=error)
       ENDIF

       ! assign atom dependent defaults, only H special case
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,n_rep_val=i,&
            keyword_name="RHO0_EXP_RADIUS",error=error)
       IF (i==0) THEN
          atomic_kind%hard0_radius=atomic_kind%hard_radius
       ELSE
          CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
               keyword_name="RHO0_EXP_RADIUS",r_val=atomic_kind%hard0_radius,error=error)
       ENDIF
       CALL cp_assert(atomic_kind%hard_radius>=atomic_kind%hard0_radius,&
            cp_failure_level,cp_assertion_failed,routineP,&
            "rc0 should be <= rc",error,failure)

       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="MAX_RAD_LOCAL",r_val=atomic_kind%max_rad_local,error=error)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="LEBEDEV_GRID",i_val=atomic_kind%ngrid_ang,error=error)
       CALL cp_assert(atomic_kind%ngrid_ang > 0,&
            cp_failure_level,cp_assertion_failed,routineP,&
            "# point lebedev grid < 0",error,failure)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="RADIAL_GRID",i_val=atomic_kind%ngrid_rad,error=error)
       CALL cp_assert(atomic_kind%ngrid_rad > 0,&
            cp_failure_level,cp_assertion_failed,routineP,&
            "# point radial grid < 0",error,failure)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="GPW_TYPE",l_val=atomic_kind%gpw_type_forced,error=error)
       CALL section_vals_val_get(kind_section,i_rep_section=k_rep,&
            keyword_name="GHOST",l_val=atomic_kind%ghost,error=error)
    END IF

    atomic_kind%mass = atomic_kind%mass*massunit

    !   *** Allocate and initialise the orbital basis set data set structure ***
    CALL init_orbital_pointers(5) ! debug the SUN optimizer

    IF (orb_basis_set_name /= '') THEN
       CALL allocate_gto_basis_set(atomic_kind%orb_basis_set)
       CALL read_gto_basis_set(atomic_kind%element_symbol,orb_basis_set_name,&
            atomic_kind%orb_basis_set,para_env,force_env_section,error)
       CALL set_gto_basis_set(gto_basis_set=atomic_kind%orb_basis_set,&
            norm_type=norb)
    END IF

    !   *** Allocate and initialise the auxiliary basis set data set structure ***

    IF (aux_basis_set_name /= '') THEN

       CALL allocate_gto_basis_set(atomic_kind%aux_basis_set)
       CALL read_gto_basis_set(atomic_kind%element_symbol,aux_basis_set_name,&
            atomic_kind%aux_basis_set,para_env,force_env_section,error)
       CALL set_gto_basis_set(gto_basis_set=atomic_kind%aux_basis_set,&
            norm_type=naux)
    END IF

    !   *** Allocate and initialise the potential data set structure ***

    IF (potential_name /= '') THEN

       ipos = INDEX(potential_name,"-")

       IF (ipos > 1) THEN
          potential_type = potential_name(:ipos-1)
       ELSE
          potential_type = potential_name
       END IF

       CALL uppercase(potential_type)
       dft_section => section_vals_get_subs_vals(force_env_section,"DFT",error=error)
       SELECT CASE (TRIM(potential_type))
       CASE ("ALL")
          CALL allocate_potential(atomic_kind%all_potential)
          CALL read_potential(atomic_kind%element_symbol,potential_name,&
               atomic_kind%all_potential,zeff_correction,para_env,&
               dft_section,error)
          CALL set_potential(atomic_kind%all_potential,z=z)
          CALL get_atomic_kind(atomic_kind,elec_conf=elec_conf)
          IF (.NOT.ASSOCIATED(elec_conf)) THEN
             CALL get_potential(potential=atomic_kind%all_potential,elec_conf=elec_conf)
             CALL set_atomic_kind(atomic_kind,elec_conf=elec_conf)
          END IF
          IF (atomic_kind%ghost) THEN
             CALL get_atomic_kind(atomic_kind=atomic_kind,&
                  elec_conf=elec_conf)
             elec_conf(:) = 0
             CALL get_potential(potential=atomic_kind%all_potential,&
                  elec_conf=elec_conf)
             elec_conf(:) = 0
             CALL set_potential(potential=atomic_kind%all_potential,&
                  zeff=0.0_dp,&
                  zeff_correction=0.0_dp)
          END IF
       CASE ("GTH")
          IF (atomic_kind%ghost) THEN
             IF (ASSOCIATED(atomic_kind%elec_conf)) atomic_kind%elec_conf = 0
          ELSE
             CALL allocate_potential(atomic_kind%gth_potential)
             CALL read_potential(atomic_kind%element_symbol,potential_name,&
                  atomic_kind%gth_potential,zeff_correction,para_env,&
                  dft_section,error)
             CALL set_potential(atomic_kind%gth_potential,z=z)
             CALL get_atomic_kind(atomic_kind,elec_conf=elec_conf)
             IF (.NOT.ASSOCIATED(elec_conf)) THEN
                CALL get_potential(potential=atomic_kind%gth_potential,elec_conf=elec_conf)
                CALL set_atomic_kind(atomic_kind,elec_conf=elec_conf)
             END IF
          END IF
       CASE ("ELP")
          CALL allocate_potential(atomic_kind%elp_potential)
          CALL read_potential(atomic_kind%element_symbol,potential_name,&
               atomic_kind%elp_potential,para_env,&
               dft_section,error)
       CASE DEFAULT
          CALL stop_program(routineN,moduleN,__LINE__,&
               "An invalid potential type <"//&
               TRIM(potential_name)//"> was specified "//&
               "for the atomic kind <"//&
               TRIM(atomic_kind%name),para_env)
       END SELECT

    ELSE
       IF (atomic_kind%gpw_type_forced) THEN
          IF (ASSOCIATED(atomic_kind%elec_conf)) atomic_kind%elec_conf = 0
       ELSE
          CALL allocate_potential(atomic_kind%all_potential)
          CALL set_default_all_potential(atomic_kind%all_potential,z,zeff_correction)
          CALL get_atomic_kind(atomic_kind,elec_conf=elec_conf)
          IF (.NOT.ASSOCIATED(elec_conf)) THEN
             CALL get_potential(potential=atomic_kind%all_potential,elec_conf=elec_conf)
             CALL set_atomic_kind(atomic_kind,elec_conf=elec_conf)
          END IF
          IF (atomic_kind%ghost) THEN
             CALL get_atomic_kind(atomic_kind=atomic_kind,&
                  elec_conf=elec_conf)
             elec_conf(:) = 0
             CALL get_potential(potential=atomic_kind%all_potential,&
                  elec_conf=elec_conf)
             elec_conf(:) = 0
             CALL set_potential(potential=atomic_kind%all_potential,&
                  zeff=0.0_dp,&
                  zeff_correction=0.0_dp)
          END IF
       END IF
    END IF

  END SUBROUTINE read_atomic_kind

! *****************************************************************************

  SUBROUTINE read_atomic_kind_set(atomic_kind_set,kind_section,para_env,force_env_section,error)

!   Purpose: Read an atomic kind set data set from the input file.

!   History: - Creation (09.02.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(section_vals_type), POINTER         :: kind_section
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(section_vals_type), POINTER         :: force_env_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'read_atomic_kind_set'

    INTEGER                                  :: ikind, method, nkind, &
                                                qs_method
    LOGICAL                                  :: no_fail
    TYPE(atomic_kind_type), POINTER          :: atomic_kind

    no_fail = .FALSE.
    ! between all methods only SE and DFTB do not need a KIND section.
    ! At this stage we still don't know if we are in a SE run or not..
    ! We've to figure it out now!
    CALL section_vals_val_get(force_env_section,"METHOD",i_val=method,error=error)
    IF (method==do_qs) THEN
       CALL section_vals_val_get(force_env_section,"DFT%QS%METHOD",i_val=qs_method,&
            error=error)
       SELECT CASE (qs_method)
       CASE (do_method_mndo,do_method_am1,do_method_pm3,do_method_pdg)
          no_fail = .TRUE.
       CASE (do_method_dftb)
          no_fail = .TRUE.
       END SELECT
    END IF
    IF (ASSOCIATED(atomic_kind_set)) THEN
      nkind = SIZE(atomic_kind_set)
      DO ikind=1,nkind
        atomic_kind => atomic_kind_set(ikind)
        CALL read_atomic_kind(atomic_kind,kind_section,para_env,force_env_section,&
             no_fail, error)
      END DO
    ELSE
      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind_set is not associated",&
                        para_env)
    END IF

  END SUBROUTINE read_atomic_kind_set

! *****************************************************************************

  SUBROUTINE check_atomic_kind(atomic_kind,dft_control,para_env,&
                               force_env_section,error)

    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(dft_control_type), INTENT(IN)       :: dft_control
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(section_vals_type), POINTER         :: force_env_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'check_atomic_kind', &
      routineP = moduleN//':'//routineN

    CHARACTER(LEN=default_string_length)     :: name
    INTEGER                                  :: method_name_id, z
    LOGICAL                                  :: defined, failure, ghost
    REAL(dp)                                 :: mass
    TYPE(all_potential_type), POINTER        :: all_potential
    TYPE(elp_potential_type), POINTER        :: elp_potential
    TYPE(gth_potential_type), POINTER        :: gth_potential
    TYPE(gto_basis_set_type), POINTER        :: orb_basis_set
    TYPE(qs_dftb_atom_type), POINTER         :: dftb_parameter
    TYPE(semi_empirical_type), POINTER       :: se_parameter

    CALL section_vals_val_get(force_env_section,"METHOD",i_val=method_name_id,error=error)
    NULLIFY ( orb_basis_set, all_potential, elp_potential, gth_potential )
    CALL get_atomic_kind(atomic_kind,name=name,z=z,mass=mass,&
                         orb_basis_set=orb_basis_set,&
                         all_potential=all_potential,&
                         elp_potential=elp_potential,&
                         gth_potential=gth_potential, ghost=ghost)

    IF (method_name_id == do_qs) THEN
      IF (z < 0) THEN
        CALL stop_program(routineN,moduleN,__LINE__,&
                     "No valid element is assign to the atomic kind ",para_env)
      END IF
      IF (dft_control%qs_control%semi_empirical) THEN
        CALL get_atomic_kind(atomic_kind,se_parameter=se_parameter)
        IF (.NOT.ASSOCIATED(se_parameter)) THEN
          CALL allocate_se_param(atomic_kind%se_parameter)
          CALL get_atomic_kind(atomic_kind,se_parameter=se_parameter)
        END IF
        CALL get_se_param(se_parameter,defined=defined)
        IF (.NOT.defined) THEN
          ! set default parameters
          CALL se_param_set_default(se_parameter,z,&
                 dft_control%qs_control%method)
        END IF
        CALL write_se_param(se_parameter,force_env_section,error)
        CALL init_se_param(atomic_kind%se_parameter,&
                           atomic_kind%orb_basis_set,error=error)
        IF ( ASSOCIATED(all_potential) ) THEN
           CALL init_potential ( all_potential, itype="BARE", &
                zeff=se_parameter%zeff, zeff_correction=all_potential%zeff_correction)
           se_parameter%zeff=se_parameter%zeff-all_potential%zeff_correction
        END IF
      ELSEIF (dft_control%qs_control%dftb) THEN
        CALL get_atomic_kind(atomic_kind,dftb_parameter=dftb_parameter)
        CPPostcondition(ASSOCIATED(dftb_parameter),cp_failure_level,routineP,error,failure)
        CALL get_dftb_atom_param(dftb_parameter,defined=defined,error=error)
        CPPostcondition(defined,cp_failure_level,routineP,error,failure)
      ELSE
        IF ((.NOT.ASSOCIATED(gth_potential)).AND.&
            (.NOT.ASSOCIATED(all_potential)).AND.&
            (.NOT.ASSOCIATED(elp_potential)).AND.&
            (.NOT.ghost)) THEN
          CALL stop_program(routineN,moduleN,__LINE__,&
                      "No potential type was defined for the "//&
                      "atomic kind <"//TRIM(atomic_kind%name)//">",para_env)
        END IF
        IF (.NOT.ASSOCIATED(orb_basis_set)) THEN
          CALL stop_program(routineN,moduleN,__LINE__,&
                      "No basis set type was defined for the "//&
                      "atomic kind <"//TRIM(atomic_kind%name)//">",para_env)
        END IF
      END IF
    ELSE IF (method_name_id == do_kg) THEN
      !no checks programmed yet
    END IF

  END SUBROUTINE check_atomic_kind

! *****************************************************************************

  SUBROUTINE check_atomic_kind_set(atomic_kind_set,dft_control,para_env,&
                                   force_env_section,error)

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(dft_control_type), INTENT(IN)       :: dft_control
    TYPE(cp_para_env_type), POINTER          :: para_env
    TYPE(section_vals_type), POINTER         :: force_env_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'check_atomic_kind_set'

    INTEGER                                  :: ikind, nkind
    TYPE(atomic_kind_type), POINTER          :: atomic_kind

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind_set)) THEN
      nkind = SIZE(atomic_kind_set)
      DO ikind=1,nkind
        atomic_kind => atomic_kind_set(ikind)
        CALL check_atomic_kind(atomic_kind,dft_control,para_env,force_env_section,error)
      END DO
    ELSE
      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind_set is not associated",&
                        para_env)
    END IF

  END SUBROUTINE check_atomic_kind_set

! *****************************************************************************

  SUBROUTINE set_atomic_kind(atomic_kind,element_symbol,name,mass,kind_number,&
                             natom,atom_list,elec_conf,&
                             paw_atom,qm_atom,hard_radius,hard0_radius,&
                             elp_potential,soft_basis_set,hard_basis_set,&
                             lmax_rho0,zeff,ghost,shell,shell_active,error)

!   Purpose: Set the components of an atomic kind data set.

!   History: - Creation (11.01.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    CHARACTER(LEN=*), INTENT(IN), OPTIONAL   :: element_symbol, name
    REAL(KIND=dp), INTENT(IN), OPTIONAL      :: mass
    INTEGER, INTENT(IN), OPTIONAL            :: kind_number, natom
    INTEGER, DIMENSION(:), INTENT(IN), &
      OPTIONAL                               :: atom_list, elec_conf
    LOGICAL, INTENT(IN), OPTIONAL            :: paw_atom, qm_atom
    REAL(dp), INTENT(IN), OPTIONAL           :: hard_radius, hard0_radius
    TYPE(elp_potential_type), OPTIONAL, &
      POINTER                                :: elp_potential
    TYPE(gto_basis_set_type), OPTIONAL, &
      POINTER                                :: soft_basis_set, hard_basis_set
    INTEGER, INTENT(IN), OPTIONAL            :: lmax_rho0
    REAL(KIND=dp), INTENT(IN), OPTIONAL      :: zeff
    LOGICAL, INTENT(IN), OPTIONAL            :: ghost
    TYPE(shell_kind_type), OPTIONAL, POINTER :: shell
    LOGICAL, INTENT(IN), OPTIONAL            :: shell_active
    TYPE(cp_error_type), INTENT(inout), &
      OPTIONAL                               :: error

    CHARACTER(LEN=*), PARAMETER              :: routineN = 'set_atomic_kind'

    INTEGER                                  :: istat, n

!   ---------------------------------------------------------------------------

    IF (ASSOCIATED(atomic_kind)) THEN

      IF (PRESENT(element_symbol)) atomic_kind%element_symbol = element_symbol
      IF (PRESENT(name)) atomic_kind%name = name
      IF (PRESENT(mass)) atomic_kind%mass = mass
      IF (PRESENT(kind_number)) atomic_kind%kind_number = kind_number
      IF (PRESENT(natom)) atomic_kind%natom = natom
      IF (PRESENT(atom_list)) THEN
        n = SIZE(atom_list)
        IF (n > 0) THEN
          IF (ASSOCIATED(atomic_kind%atom_list)) THEN
            DEALLOCATE (atomic_kind%atom_list,STAT=istat)
            IF (istat /= 0) THEN
              CALL stop_memory(routineN,moduleN,__LINE__,&
                               "atomic_kind%atom_list")
            END IF
          END IF
          ALLOCATE (atomic_kind%atom_list(n),STAT=istat)
          IF (istat /= 0) THEN
            CALL stop_memory(routineN,moduleN,__LINE__,&
                             "atomic_kind%atom_list",n*int_size)
          END IF
          atomic_kind%atom_list(:) = atom_list(:)
          atomic_kind%natom = n
        ELSE
          CALL stop_program(routineN,moduleN,__LINE__,&
                            "An invalid atom_list was supplied")
        END IF
      END IF
      IF (PRESENT(elec_conf)) THEN
          IF (ASSOCIATED(atomic_kind%elec_conf)) THEN
             DEALLOCATE(atomic_kind%elec_conf)
          ENDIF
          ALLOCATE(atomic_kind%elec_conf(0:SIZE(elec_conf)-1))
          atomic_kind%elec_conf(:)=elec_conf(:)
      ENDIF
      IF (PRESENT(paw_atom)) atomic_kind%paw_atom = paw_atom
      IF (PRESENT(qm_atom)) atomic_kind%qm_atom = qm_atom
      IF (PRESENT(hard_radius)) atomic_kind%hard_radius = hard_radius
      IF (PRESENT(hard0_radius)) atomic_kind%hard0_radius = hard0_radius
      IF (PRESENT(elp_potential)) atomic_kind%elp_potential => elp_potential
      IF (PRESENT(soft_basis_set)) atomic_kind%soft_basis_set => soft_basis_set
      IF (PRESENT(hard_basis_set)) atomic_kind%hard_basis_set => hard_basis_set
      IF (PRESENT(lmax_rho0)) atomic_kind%lmax_rho0 = lmax_rho0
      IF (PRESENT(zeff)) THEN
        IF (ASSOCIATED(atomic_kind%all_potential)) THEN
          CALL set_potential(potential=atomic_kind%all_potential,zeff=zeff)
        ELSE IF (ASSOCIATED(atomic_kind%gth_potential)) THEN
          CALL set_potential(potential=atomic_kind%gth_potential,zeff=zeff)
        END IF
      END IF
      IF (PRESENT(ghost)) atomic_kind%ghost = ghost
      IF (PRESENT(shell)) THEN
        atomic_kind%shell => shell
        CALL shell_retain(shell,error)
      END IF
      IF (PRESENT(shell_active)) atomic_kind%shell_active=shell_active

    ELSE

      CALL stop_program(routineN,moduleN,__LINE__,&
                        "The pointer atomic_kind is not associated")

    END IF

  END SUBROUTINE set_atomic_kind

! *****************************************************************************

  SUBROUTINE write_atomic_kind(atomic_kind,force_env_section,output_unit,error)

!   Purpose: Write an atomic kind data set to the output unit.

!   History: - Creation (09.02.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(section_vals_type), POINTER         :: force_env_section
    INTEGER, INTENT(in)                      :: output_unit
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'write_atomic_kind', &
      routineP = moduleN//':'//routineN

    LOGICAL                                  :: failure

! -------------------------------------------------------------------------

    failure = .FALSE.

    IF (output_unit > 0) THEN

      IF (ASSOCIATED(atomic_kind)) THEN

        WRITE (UNIT=output_unit,FMT="(/,T2,I2,A,T57,A,T75,I6)")&
          atomic_kind%kind_number,". Atomic kind: "//TRIM(atomic_kind%name),&
          "Number of atoms: ",atomic_kind%natom

        CALL write_orb_basis_set(atomic_kind%orb_basis_set,force_env_section,&
                                 output_unit,error)

        IF (atomic_kind%ghost) THEN
          WRITE (UNIT=output_unit,FMT="(/,T6,A)")&
            "The atoms of this atomic kind are GHOST atoms!"
        END IF

        IF (atomic_kind%paw_atom) THEN
          WRITE (UNIT=output_unit,FMT="(/,T6,A)")&
            "The atoms of this atomic kind are PAW atoms (GAPW):"
          WRITE (UNIT=output_unit,FMT="(T8,A,T71,F10.3)")&
            "Hard Gaussian function radius:",atomic_kind%hard_radius,&
            "Rho0 radius:",atomic_kind%hard0_radius,&
            "Maximum GTO radius used for PAW projector construction:",&
            atomic_kind%max_rad_local
          CALL write_orb_basis_set(atomic_kind%soft_basis_set,force_env_section,&
                                   output_unit,error)
        END IF

        CALL write_aux_basis_set(atomic_kind%aux_basis_set,force_env_section,&
                                 output_unit,error)

        CALL write_potential(atomic_kind%all_potential,force_env_section,&
                             output_unit,error)
        CALL write_potential(atomic_kind%elp_potential,force_env_section,&
                             output_unit,error)
        CALL write_potential(atomic_kind%gth_potential,force_env_section,&
                             output_unit,error)

      ELSE

        CPPrecondition(.FALSE.,cp_failure_level,routineP,error,failure)

      END IF

    END IF

  END SUBROUTINE write_atomic_kind

  ! ***************************************************************************

  SUBROUTINE write_atomic_kind_set(atomic_kind_set,force_env_section,error)

    ! Write an atomic kind set data set to the output unit.

    ! - Creation (09.02.2002,MK)

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(section_vals_type), POINTER         :: force_env_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(len=*), PARAMETER :: routineN = 'write_atomic_kind_set', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: ikind, nkind, output_unit
    LOGICAL                                  :: failure
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_logger_type), POINTER            :: logger

! -------------------------------------------------------------------------

    failure = .FALSE.

    NULLIFY (logger)

    logger => cp_error_get_logger(error)

    output_unit = cp_print_key_unit_nr(logger,force_env_section,&
                                       "SUBSYS%PRINT%KINDS",extension=".Log",&
                                       error=error)
    IF (output_unit > 0) THEN
      IF (ASSOCIATED(atomic_kind_set)) THEN
        WRITE (UNIT=output_unit,FMT="(/,/,T2,A)") "ATOMIC KIND INFORMATION"
        nkind = SIZE(atomic_kind_set)
        DO ikind=1,nkind
          atomic_kind => atomic_kind_set(ikind)
          CALL write_atomic_kind(atomic_kind,force_env_section,output_unit,error)
        END DO
      ELSE
        CPPrecondition(.FALSE.,cp_failure_level,routineP,error,failure)
      END IF
    END IF

    CALL cp_print_key_finished_output(output_unit,logger,force_env_section,&
                                      "SUBSYS%PRINT%KINDS",error=error)

  END SUBROUTINE write_atomic_kind_set

  ! ***************************************************************************

  SUBROUTINE write_gto_basis_sets(atomic_kind_set,force_env_section,error)

!   Purpose: Write all the GTO basis sets of an atomic kind set to the output
!            unit (for the printing of the unnormalized basis sets as read from
!            database).

!   History: - Creation (17.01.2002,MK)

!   ***************************************************************************

    TYPE(atomic_kind_type), DIMENSION(:), &
      POINTER                                :: atomic_kind_set
    TYPE(section_vals_type), POINTER         :: force_env_section
    TYPE(cp_error_type), INTENT(inout)       :: error

    CHARACTER(LEN=*), PARAMETER :: routineN = 'write_gto_basis_sets', &
      routineP = moduleN//':'//routineN

    INTEGER                                  :: ikind, nkind, output_unit
    LOGICAL                                  :: failure
    TYPE(atomic_kind_type), POINTER          :: atomic_kind
    TYPE(cp_logger_type), POINTER            :: logger

! -------------------------------------------------------------------------

    failure = .FALSE.

    NULLIFY (logger)
    logger => cp_error_get_logger(error)

    IF (.NOT.BTEST(cp_print_key_should_output(logger%iter_info,&
                                              force_env_section,&
                                              "SUBSYS%PRINT%KINDS/BASIS_SET",&
                                              error=error),&
                   cp_p_file)) RETURN

    output_unit = cp_print_key_unit_nr(logger,force_env_section,&
                                       "SUBSYS%PRINT%KINDS/BASIS_SET",&
                                       extension=".Log",error=error)

    IF (output_unit > 0) THEN
      IF (ASSOCIATED(atomic_kind_set)) THEN
        WRITE (UNIT=output_unit,FMT="(/,/,T2,A)")&
          "BASIS SET INFORMATION (Unnormalised Gaussian-type functions)"
        nkind = SIZE(atomic_kind_set)
        DO ikind=1,nkind
          atomic_kind => atomic_kind_set(ikind)
          WRITE (UNIT=output_unit,FMT="(/,T2,I2,A)")&
            atomic_kind%kind_number,". Atomic kind: "//TRIM(atomic_kind%name)
          CALL write_gto_basis_set(atomic_kind_set(ikind)%orb_basis_set,&
                                   output_unit,error)
          CALL write_gto_basis_set(atomic_kind_set(ikind)%aux_basis_set,&
                                   output_unit,error)
          CALL write_gto_basis_set(atomic_kind%soft_basis_set,&
                                   output_unit,error)
        END DO
      ELSE
        CPPrecondition(.FALSE.,cp_failure_level,routineP,error,failure)
      END IF
    END IF

    CALL cp_print_key_finished_output(output_unit,logger,force_env_section,&
         "SUBSYS%PRINT%KINDS/BASIS_SET",error=error)

  END SUBROUTINE write_gto_basis_sets

  ! ***************************************************************************

END MODULE atomic_kind_types
