!------------------------------------------------------------------------------!
!   CP2K: A general program to perform molecular dynamics simulations          !
!   Copyright (C) 2000  CP2K developers group                                  !
!------------------------------------------------------------------------------!
!!****** cp2k/brillouin [1.0] *
!!
!!   NAME
!!     brillouin
!!
!!   FUNCTION
!!
!!   AUTHOR
!!     JGH
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   SOURCE
!******************************************************************************
!
    MODULE brillouin
!
!------------------------------------------------------------------------------!

      USE kinds, ONLY : dbl

      USE global_types, ONLY : global_environment_type
      USE parser, ONLY : parser_init, parser_end, read_line, test_next, &
        cfield, p_error, get_real, get_int, stop_parser
      USE string_utilities, ONLY : uppercase
      USE termination, ONLY : stop_memory, stop_program
!
      IMPLICIT NONE
!
      PRIVATE
!
      PUBLIC :: kpoint_type, brillouin_info, kpoint_input
!
      TYPE kpoint_type
        CHARACTER (len=20) :: scheme
        INTEGER :: nk(3)
        REAL (dbl) :: shift(3)
        LOGICAL :: symmetry
        INTEGER :: wfn_type
        INTEGER :: nkpt
        REAL (dbl), DIMENSION (:), POINTER :: weight
        REAL (dbl), DIMENSION (:,:), POINTER :: xk
      END TYPE kpoint_type
!!*****
!------------------------------------------------------------------------------!
!
    CONTAINS
!
!------------------------------------------------------------------------------!
!!****** brillouin/kpoint_input [1.0] *
!!
!!   NAME
!!     kpoint_input
!!
!!   FUNCTION
!!
!!   AUTHOR
!!     JGH
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   INPUTS
!!I----------------------------------------------------------------------------I
!!I SECTION: &kpoint... &end                                                   I
!!I                                                                            I
!!I scheme           [Gamma, Monkhorst-Pack, MacDonald, General]               I
!!I   { nx ny nz }                                                             I
!!I   { nx ny nz  sx sy sz }                                                   I
!!I   { nkpt  x1 y1 z1 w1 ... xn yn zn wn }                                    I
!!I symmetry         [on, off]                                                 I
!!I wavefunction     [real, complex]                                           I
!!I                                                                            I
!!I----------------------------------------------------------------------------I
!!
!!   SOURCE
!******************************************************************************
      SUBROUTINE kpoint_input(kp,inpar)

        IMPLICIT NONE

        TYPE (kpoint_type), INTENT (OUT) :: kp
        TYPE (global_environment_type), INTENT (IN) :: inpar

        CHARACTER (len=20) :: string, str2
        CHARACTER (len=6) :: label
        INTEGER :: iw, ierror, ilen, isos, i, source, group

!..defaults
        kp%scheme = 'NULL'
        kp%symmetry = .FALSE.
        kp%wfn_type = 0
        kp%nkpt = 0
        kp%nk = 0
        kp%shift = 0._dbl
        iw = inpar%scr
!..parse the input section
        label = '&KPOINT'
        CALL parser_init(inpar%input_file_name,label,ierror,inpar)
        IF (ierror/=0) THEN
          IF (inpar%ionode) &
            WRITE (iw,'(a,a)') ' No input section &KPOINT found on file ', &
              adjustl(inpar%input_file_name)
        ELSE
          CALL read_line
          DO WHILE (test_next()/='X')
            ilen = 8
            CALL cfield(string,ilen)
            CALL uppercase(string)
            SELECT CASE (string)
            CASE DEFAULT
              CALL p_error()
              CALL stop_parser('kpoint_input','unknown option')
            CASE ('SCHEME')
              ilen = 20
              CALL cfield(str2,ilen)
              CALL uppercase(str2)
              SELECT CASE (str2)
              CASE DEFAULT
                CALL p_error()
                CALL stop_program("kpoint_input","Scheme: unknown option")
              CASE ('GAMMA')
                kp%scheme = str2
              CASE ('MONKHORST-PACK')
                kp%scheme = str2
                kp%nk(1) = get_int()
                kp%nk(2) = get_int()
                kp%nk(3) = get_int()
              CASE ('MACDONALD')
                kp%scheme = str2
                kp%nk(1) = get_int()
                kp%nk(2) = get_int()
                kp%nk(3) = get_int()
                kp%shift(1) = get_real()
                kp%shift(2) = get_real()
                kp%shift(3) = get_real()
              CASE ('GENERAL')
                kp%scheme = str2
                kp%nkpt = get_int()
                ALLOCATE (kp%xk(3,kp%nkpt),STAT=isos)
                IF (isos/=0) CALL stop_memory('kpoint_input', &
                  'kp%xk',3*kp%nkpt)
                ALLOCATE (kp%weight(kp%nkpt),STAT=isos)
                IF (isos/=0) CALL stop_memory('kpoint_input', &
                  'kp%weight',kp%nkpt)
                DO i = 1, kp%nkpt
                  kp%xk(1,i) = get_real()
                  kp%xk(2,i) = get_real()
                  kp%xk(3,i) = get_real()
                  kp%weight(i) = get_real()
                END DO
              END SELECT
            CASE ('SYMMETRY')
              ilen = 3
              CALL cfield(str2,ilen)
              CALL uppercase(str2)
              IF (str2=='OFF') kp%symmetry = .FALSE.
              IF (str2=='ON') kp%symmetry = .TRUE.
            CASE ('WAVEFUNC')
              ilen = 4
              CALL cfield(str2,ilen)
              CALL uppercase(str2)
              SELECT CASE (str2)
              CASE DEFAULT
                CALL p_error()
                CALL stop_parser('kpoint_input',&
                   'Wavefunctions: unknown option')
              CASE ('REAL')
                kp%wfn_type = 0
              CASE ('COMP')
                kp%wfn_type = 1
              END SELECT
            END SELECT
          END DO
        END IF
        CALL parser_end
!..update defaults
        IF (kp%scheme=='NULL' .OR. kp%scheme=='GAMMA') THEN
          kp%nkpt = 1
          ALLOCATE (kp%xk(3,1),STAT=isos)
          IF (isos/=0) CALL stop_memory('kpoint_input','kp%xk',3)
          ALLOCATE (kp%weight(1),STAT=isos)
          IF (isos/=0) CALL stop_memory('kpoint_input','kp%weight',1)
          kp%xk(:,:) = 0._dbl
          kp%weight(1) = 1._dbl
          kp%scheme = 'GAMMA'
        END IF
      END SUBROUTINE kpoint_input
!!*****
!------------------------------------------------------------------------------!
!!****** brillouin/brillouin_info [1.0] *
!!
!!   NAME
!!     brillouin_info
!!
!!   FUNCTION
!!
!!   AUTHOR
!!     JGH
!!
!!   MODIFICATION HISTORY
!!     none
!!
!!   SOURCE
!******************************************************************************
      SUBROUTINE brillouin_info(kp,punit)
        IMPLICIT NONE
        TYPE (kpoint_type), INTENT (IN) :: kp
        INTEGER, INTENT (IN) :: punit
        INTEGER :: i

        IF (kp%scheme=='GAMMA') THEN
          WRITE (punit,*)
          WRITE (punit,'(A,T57,A)') ' BRILLOUIN|', ' Gamma-point calculation'
          WRITE (punit,'(A,T76,A)') ' BRILLOUIN| Wavefunction type', ' REAL'
        ELSE
          WRITE (punit,*)
          WRITE (punit,'(A,T61,A)') ' BRILLOUIN| K-point scheme ', &
            adjustr(kp%scheme)
          IF (kp%scheme=='MONKHORST-PACK') THEN
            WRITE (punit,'(A,T66,3I5)') ' BRILLOUIN| K-Point grid', kp%nk
          ELSE IF (kp%scheme=='MACDONALD') THEN
            WRITE (punit,'(A,T66,3I5)') ' BRILLOUIN| K-Point grid', kp%nk
            WRITE (punit,'(A,T51,3F10.4)') ' BRILLOUIN| K-Point shift', &
              kp%shift
          END IF
          IF (kp%symmetry) THEN
            WRITE (punit,'(A,T76,A)') ' BRILLOUIN| K-Point symmetry', '   ON'
          ELSE
            WRITE (punit,'(A,T76,A)') ' BRILLOUIN| K-Point symmetry', '  OFF'
          END IF
          IF (kp%wfn_type==0) THEN
            WRITE (punit,'(A,T76,A)') ' BRILLOUIN| Wavefunction type', ' REAL'
          ELSE
            WRITE (punit,'(A,T73,A)') ' BRILLOUIN| Wavefunction type', &
              ' COMPLEX'
          END IF
          WRITE (punit,'(A,T71,I10)') ' BRILLOUIN| Number of K-points ', &
            kp%nkpt
          WRITE (punit,'(A,T30,A,T48,A,T63,A,T78,A)') ' BRILLOUIN| Number ', &
            'Weight', 'X', 'Y', 'Z'
          DO i = 1, kp%nkpt
            WRITE (punit,'(A,I5,3X,4F15.5)') ' BRILLOUIN| ', i, kp%weight(i), &
              kp%xk(1,i), kp%xk(2,i), kp%xk(3,i)
          END DO
        END IF
      END SUBROUTINE brillouin_info

!!*****
!------------------------------------------------------------------------------!

    END MODULE brillouin

!------------------------------------------------------------------------------!
